<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Manipulating files</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Introduction to Linux"
HREF="index.html"><LINK
REL="UP"
TITLE="About files and the file system"
HREF="chap_03.html"><LINK
REL="PREVIOUS"
TITLE="Orientation in the file system"
HREF="sect_03_02.html"><LINK
REL="NEXT"
TITLE="File security"
HREF="sect_03_04.html"><link rel="stylesheet" type="text/css" href="../bookstyle.css"> </HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Introduction to Linux: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="sect_03_02.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. About files and the file system</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="sect_03_04.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="sect_03_03"
></A
>3.3. Manipulating files</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_03_01"
></A
>3.3.1. Viewing file properties</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_01_01"
></A
>3.3.1.1. More about ls</H3
><P
>Besides the name of the file, <B
CLASS="command"
>ls</B
> can give a lot of other information, such as the file type, as we already discussed.  It can also show permissions on a file, file size, inode number, creation date and time, owners and amount of links to the file.  With the <TT
CLASS="option"
>-a</TT
> option to <B
CLASS="command"
>ls</B
>, files that are normally hidden from view can be displayed as well.  These are files that have a name starting with a dot.  A couple of typical examples include the configuration files in your home directory.  When you've worked with a certain system for a while, you will notice that tens of files and directories have been created that are not automatically listed in a directory index.  Next to that, every directory contains a file named just dot (.) and one with two dots (..), which are used in combination with their inode number to determine the directory's position in the file system's tree structure.</P
><P
>You should really read the <SPAN
CLASS="application"
>Info</SPAN
> pages about <B
CLASS="command"
>ls</B
>, since it is a very common command with a lot of useful options.  Options can be combined, as is the case with most UNIX commands and their options.  A common combination is <B
CLASS="command"
>ls <TT
CLASS="option"
>-al</TT
></B
>; it shows a long list of files and their properties as well as the destinations that any symbolic links point to.  <B
CLASS="command"
>ls <TT
CLASS="option"
>-latr</TT
></B
> displays the same files, only now in reversed order of the last change, so that the file changed most recently occurs at the bottom of the list.  Here are a couple of examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>krissie:~/mp3&#62;</TT
> <B
CLASS="command"
>ls</B
>
Albums/  Radio/  Singles/  gene/  index.html

<TT
CLASS="prompt"
>krissie:~/mp3&#62;</TT
> <B
CLASS="command"
>ls -a</B
>
./   .thumbs  Radio     gene/
../  Albums/  Singles/  index.html

<TT
CLASS="prompt"
>krissie:~/mp3&#62;</TT
> <B
CLASS="command"
>ls -l Radio/</B
>
total 8
drwxr-xr-x    2 krissie krissie  4096 Oct 30  1999 Carolina/
drwxr-xr-x    2 krissie krissie  4096 Sep 24  1999 Slashdot/

<TT
CLASS="prompt"
>krissie:~/mp3&#62;</TT
> <B
CLASS="command"
>ls -ld Radio/</B
>
drwxr-xr-x    4 krissie krissie  4096 Oct 30  1999 Radio/

<TT
CLASS="prompt"
>krissie:~/mp3&#62;</TT
> <B
CLASS="command"
>ls -ltr</B
>
total 20
drwxr-xr-x    4 krissie krissie  4096 Oct 30  1999 Radio/
-rw-r--r--    1 krissie krissie   453 Jan  7  2001 index.html
drwxrwxr-x   30 krissie krissie  4096 Oct 20 17:32 Singles/
drwxr-xr-x    2 krissie krissie  4096 Dec  4 23:22 gene/
drwxrwxr-x   13 krissie krissie  4096 Dec 21 11:40 Albums/
</PRE
></FONT
></TD
></TR
></TABLE
><P
>On most Linux versions <B
CLASS="command"
>ls</B
> is <EM
>aliased</EM
> to color-ls by default.  This feature allows to see the file type without using any options to <B
CLASS="command"
>ls</B
>.  To achieve this, every file type has its own color.  The standard scheme is in <TT
CLASS="filename"
>/etc/DIR_COLORS</TT
>:</P
><DIV
CLASS="table"
><A
NAME="AEN3003"
></A
><P
><B
>Table 3-5. Color-ls default color scheme</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Color</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>File type</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>blue</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>directories</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>red</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>compressed archives</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>white</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>text files</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>pink</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>images</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>cyan</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>links</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>yellow</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>devices</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>green</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>executables</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>flashing red</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>broken links</TD
></TR
></TBODY
></TABLE
></DIV
><P
>More information is in the man page.  The same information was in earlier days displayed using suffixes to every non-standard file name.  For mono-color use (like printing a directory listing) and for general readability, this scheme is still in use:</P
><DIV
CLASS="table"
><A
NAME="AEN3039"
></A
><P
><B
>Table 3-6. Default suffix scheme for ls</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Character</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>File type</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>nothing</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>regular file</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>/</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>directory</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>*</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>executable file</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>@</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>link</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>=</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>socket</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>|</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>named pipe</TD
></TR
></TBODY
></TABLE
></DIV
><P
>A description of the full functionality and features of the <B
CLASS="command"
>ls</B
> command can be read with <B
CLASS="command"
>info <TT
CLASS="parameter"
><I
>coreutils ls</I
></TT
></B
>.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_01_02"
></A
>3.3.1.2. More tools</H3
><P
>To find out more about the kind of data we are dealing with, we use the <B
CLASS="command"
>file</B
> command.  By applying certain tests that check properties of a file in the file system, magic numbers and language tests, <B
CLASS="command"
>file</B
> tries to make an educated guess about the format of a file.  Some examples:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file Documents/</B
>
Documents/: directory

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file high-tech-stats.pdf</B
>
high-tech-stats.pdf: PDF document, version 1.2

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file Nari-288.rm</B
>
Nari-288.rm: RealMedia file

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file bijlage10.sdw</B
>
bijlage10.sdw: Microsoft Office Document

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file logo.xcf</B
>
logo.xcf: GIMP XCF image data, version 0, 150 x 38, RGB Color

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file cv.txt</B
>
cv.txt: ISO-8859 text

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file image.png</B
>
image.png: PNG image data, 616 x 862, 8-bit grayscale, non-interlaced

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file figure</B
>
figure: ASCII text

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file me+tux.jpg</B
>
me+tux.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI),
            "28 Jun 1999", 144 x 144

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file 42.zip.gz</B
>
42.zip.gz: gzip compressed data, deflated, original filename,
         `42.zip', last modified: Thu Nov  1 23:45:39 2001, os: Unix

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file vi.gif</B
>
vi.gif: GIF image data, version 89a, 88 x 31

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file slide1</B
>
slide1: HTML document text

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file template.xls</B
>
template.xls: Microsoft Office Document

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file abook.ps</B
>
abook.ps: PostScript document text conforming at level 2.0

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file /dev/log</B
>
/dev/log: socket

<TT
CLASS="prompt"
>mike:~&#62;</TT
> <B
CLASS="command"
>file /dev/hda</B
>
/dev/hda: block special (3/0)
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The <B
CLASS="command"
>file</B
> command has a series of options, among others the <TT
CLASS="option"
>-z</TT
> option to look into compressed files.  See <B
CLASS="command"
>info <TT
CLASS="parameter"
><I
>file</I
></TT
></B
> for a detailed description.  Keep in mind that the results of <B
CLASS="command"
>file</B
> are not absolute, it is only a guess.  In other words, <B
CLASS="command"
>file</B
> can be tricked.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Why all the fuss about file types and formats?</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Shortly, we will discuss a couple of command-line tools for looking at <EM
>plain text files</EM
>.  These tools will not work when used on the wrong type of files.  In the worst case, they will crash your terminal and/or make a lot of beeping noises.  If this happens to you, just close the terminal session and start a new one.  But try to avoid it, because it is usually very disturbing for other people.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_03_02"
></A
>3.3.2. Creating and deleting files and directories</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_02_01"
></A
>3.3.2.1. Making a mess...</H3
><P
>... Is not a difficult thing to do.  Today almost every system is networked, so naturally files get copied from one machine to another.  And especially when working in a graphical environment, creating new files is a piece of cake and is often done without the approval of the user.  To illustrate the problem, here's the full content of a new user's directory, created on a standard RedHat system:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[newuser@blob user]$</TT
> <B
CLASS="command"
>ls -al</B
>
total 32
drwx------   3 user 	user        4096 Jan 16 13:32 .
drwxr-xr-x   6 root     root        4096 Jan 16 13:32 ..
-rw-r--r--   1 user 	user      24 Jan 16 13:32 .bash_logout
-rw-r--r--   1 user 	user     191 Jan 16 13:32 .bash_profile
-rw-r--r--   1 user 	user     124 Jan 16 13:32 .bashrc
drwxr-xr-x   3 user 	user    4096 Jan 16 13:32 .kde
-rw-r--r--   1 user 	user    3511 Jan 16 13:32 .screenrc
-rw-------   1 user 	user      61 Jan 16 13:32 .xauthDqztLr
</PRE
></FONT
></TD
></TR
></TABLE
><P
>On first sight, the content of a <SPAN
CLASS="QUOTE"
>"used"</SPAN
> home directory doesn't look that bad either:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>olduser:~&#62;</TT
> <B
CLASS="command"
>ls</B
>
app-defaults/ crossover/   Fvwm@     mp3/      OpenOffice.org638/
articles/     Desktop/     GNUstep/  Nautilus/ staroffice6.0/
bin/          Desktop1/    images/   nqc/      training/
brol/         desktoptest/ Machines@ ns_imap/  webstart/
C/            Documents/   mail/     nsmail/   xml/
closed/       Emacs@       Mail/     office52/ Xrootenv.0
</PRE
></FONT
></TD
></TR
></TABLE
><P
>But when all the directories and files starting with a dot are included, there are 185 items in this directory.  This is because most applications have their own directories and/or files, containing user-specific settings, in the home directory of that user.  Usually these files are created the first time you start an application.  In some cases you will be notified when a non-existent directory needs to be created, but most of the time everything is done automatically.</P
><P
>Furthermore, new files are created seemingly continuously because users want to save files, keep different versions of their work, use Internet applications, and download files and attachments to their local machine.  It doesn't stop.  It is clear that one definitely needs a scheme to keep an overview on things.</P
><P
>In the next section, we will discuss our means of keeping order.  We only discuss text tools available to the shell, since the graphical tools are very intuitive and have the same look and feel as the well known point-and-click MS Windows-style file managers, including graphical help functions and other features you expect from this kind of applications.  The following list is an overview of the most popular file managers for GNU/Linux.  Most file managers can be started from the menu of your desktop manager, or by clicking your home directory icon, or from the command line, issuing these commands:</P
><P
></P
><UL
><LI
><P
><B
CLASS="command"
>nautilus</B
>: The default file manager in <SPAN
CLASS="application"
>Gnome</SPAN
>, the GNU desktop.  Excellent documentation about working with this tool can be found at <A
HREF="http://www.gnome.org/learn/users-guide/latest/gosnautilus-1.html"
TARGET="_top"
>http://www.gnome.org</A
>.</P
></LI
><LI
><P
><B
CLASS="command"
>konqueror</B
>: The file manager typically used on a <SPAN
CLASS="application"
>KDE</SPAN
> desktop.  The handbook is at <A
HREF="http://docs.kde.org/en/3.1/kdebase/konqueror/"
TARGET="_top"
>http://docs.kde.org</A
>.</P
></LI
><LI
><P
><B
CLASS="command"
>mc</B
>: <SPAN
CLASS="application"
>Midnight Commander</SPAN
>, the Unix file manager after the fashion of Norton Commander.  All documentation available from <A
HREF="http://www.gnu.org/directory/midnightcommander.html"
TARGET="_top"
>http://gnu.org/directory/</A
> or a mirror, such as <A
HREF="http://www.ibiblio.org"
TARGET="_top"
>http://www.ibiblio.org</A
>.</P
></LI
></UL
><P
>These applications are certainly worth giving a try and usually impress newcomers to Linux, if only because there is such a wide variety: these are only the most popular tools for managing directories and files, and many other projects are being developed.  Now let's find out about the internals and see how these graphical tools use common UNIX commands.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_02_03"
></A
>3.3.2.2. The tools</H3
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="AEN3176"
></A
>3.3.2.2.1. Creating directories</H4
><P
>A way of keeping things in place is to give certain files specific default locations by creating directories and subdirectories (or folders and sub-folders if you wish).  This is done with the <B
CLASS="command"
>mkdir</B
> command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>richard:~&#62;</TT
> <B
CLASS="command"
>mkdir archive</B
>

<TT
CLASS="prompt"
>richard:~&#62;</TT
> <B
CLASS="command"
>ls -ld archive</B
>
drwxrwxrwx  2 richard richard           4096 Jan 13 14:09 archive/
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Creating directories and subdirectories in one step is done using the <TT
CLASS="option"
>-p</TT
> option:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>richard:~&#62;</TT
> <B
CLASS="command"
>cd archive</B
>

<TT
CLASS="prompt"
>richard:~/archive&#62;</TT
> <B
CLASS="command"
>mkdir 1999 2000 2001</B
>

<TT
CLASS="prompt"
>richard:~/archive&#62;</TT
> <B
CLASS="command"
>ls</B
>
1999/  2000/  2001/

<TT
CLASS="prompt"
>richard:~/archive&#62;</TT
> <B
CLASS="command"
>mkdir 2001/reports/Restaurants-Michelin/</B
>
mkdir: cannot create directory `2001/reports/Restaurants-Michelin/':
No such file or directory

<TT
CLASS="prompt"
>richard:~/archive&#62;</TT
> <B
CLASS="command"
>mkdir -p 2001/reports/Restaurants-Michelin/</B
>

<TT
CLASS="prompt"
>richard:~/archive&#62;</TT
> <B
CLASS="command"
>ls 2001/reports/</B
>
Restaurants-Michelin/
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If the new file needs other permissions than the default file creation permissions, the new access rights can be set in one move, still using the <B
CLASS="command"
>mkdir</B
> command, see the <SPAN
CLASS="application"
>Info</SPAN
> pages for more.  We are going to discuss access modes in the next section on file security.</P
><P
>The name of a directory has to comply with the same rules as those applied on regular file names.  One of the most important restrictions is that you can't have two files with the same name in one directory (but keep in mind that Linux is, like UNIX, a case sensitive operating system).  There are virtually no limits on the length of a file name, but it is usually kept shorter than 80 characters, so it can fit on one line of a terminal.  You can use any character you want in a file name, although it is advised to exclude characters that have a special meaning to the shell.  When in doubt, check with <A
HREF="app3.html"
>Appendix C</A
>.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="AEN3213"
></A
>3.3.2.2.2. Moving files</H4
><P
>Now that we have properly structured our home directory, it is time to clean up unclassified files using the <B
CLASS="command"
>mv</B
> command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>richard:~/archive&#62;</TT
> <B
CLASS="command"
>mv ../report[1-4].doc reports/Restaurants-Michelin/</B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This command is also applicable when renaming files:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>richard:~&#62;</TT
> <B
CLASS="command"
>ls To_Do</B
>
-rw-rw-r--    1 richard richard      2534 Jan 15 12:39 To_Do

<TT
CLASS="prompt"
>richard:~&#62;</TT
> <B
CLASS="command"
>mv To_Do done</B
>

<TT
CLASS="prompt"
>richard:~&#62;</TT
> <B
CLASS="command"
>ls -l done</B
>
-rw-rw-r--    1 richard richard      2534 Jan 15 12:39 done
</PRE
></FONT
></TD
></TR
></TABLE
><P
>It is clear that only the name of the file changes.  All other properties remain the same.</P
><P
>Detailed information about the syntax and features of the <B
CLASS="command"
>mv</B
> command can be found in the man or Info pages.  The use of this documentation should always be your first reflex when confronted with a problem.  The answer to your problem is likely to be in the system documentation.  Even experienced users read man pages every day, so beginning users should read them all the time.  After a while, you will get to know the most common options to the common commands, but you will still need the documentation as a primary source of information.  Note that the information contained in the HOWTOs, FAQs, man pages and other sources is slowly being merged into the Info pages, which are today the most up-to-date source of online (as in readily available on the system) documentation.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="AEN3239"
></A
>3.3.2.2.3. Copying files</H4
><P
>Copying files and directories is done with the <B
CLASS="command"
>cp</B
> command.  A useful option is recursive copy (copy all underlying files and subdirectories), using the <TT
CLASS="option"
>-R</TT
> option to <B
CLASS="command"
>cp</B
>.  The general syntax is</P
><P
><B
CLASS="command"
>cp [<SPAN
CLASS="optional"
><TT
CLASS="option"
>-R</TT
></SPAN
>] <TT
CLASS="filename"
>fromfile</TT
> <TT
CLASS="filename"
>tofile</TT
></B
> </P
><P
>As an example the case of user <EM
>newguy</EM
>, who wants the same Gnome desktop settings user <EM
>oldguy</EM
> has.  One way to solve the problem is to copy the settings of <EM
>oldguy</EM
> to the home directory of <EM
>newguy</EM
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>victor:~&#62;</TT
> <B
CLASS="command"
>cp -R ../oldguy/.gnome/ .</B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This gives some errors involving file permissions, but all the errors have to do with private files that <EM
>newguy</EM
> doesn't need anyway.  We will discuss in the next part how to change these permissions in case they really are a problem.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="AEN3266"
></A
>3.3.2.2.4. Removing files</H4
><P
>Use the <B
CLASS="command"
>rm</B
> command to remove single files, <B
CLASS="command"
>rmdir</B
> to remove empty directories.  (Use <B
CLASS="command"
>ls <TT
CLASS="option"
>-a</TT
></B
> to check whether a directory is empty or not).  The <B
CLASS="command"
>rm</B
> command also has options for removing non-empty directories with all their subdirectories, read the Info pages for these rather dangerous options.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>How empty can a directory be?</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It is normal that the directories . (dot) and .. (dot-dot) can't be removed, since they are also necessary in an empty directory to determine the directories ranking in the file system hierarchy.</P
></TD
></TR
></TABLE
></DIV
><P
>On Linux, just like on UNIX, there is no garbage can - at least not for the shell, although there are plenty of solutions for graphical use.  So once removed, a file is really gone, and there is generally no way to get it back unless you have backups, or you are really fast and have a real good system administrator.  To protect the beginning user from this malice, the interactive behavior of the <B
CLASS="command"
>rm</B
>, <B
CLASS="command"
>cp</B
> and <B
CLASS="command"
>mv</B
> commands can be activated using the <TT
CLASS="option"
>-i</TT
> option.  In that case the system won't immediately act upon request.  Instead it will ask for confirmation, so it takes an additional click on the <B
CLASS="keycap"
>Enter</B
> key to inflict the damage:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>mary:~&#62;</TT
> <B
CLASS="command"
>rm -ri archive/</B
>
rm: descend into directory `archive'? <B
CLASS="command"
>y</B
>
rm: descend into directory `archive/reports'? <B
CLASS="command"
>y</B
>
rm: remove directory `archive/reports'? <B
CLASS="command"
>y</B
>
rm: descend into directory `archive/backup'? <B
CLASS="command"
>y</B
>
rm: remove `archive/backup/sysbup200112.tar'? <B
CLASS="command"
>y</B
>
rm: remove directory `archive/backup'? <B
CLASS="command"
>y</B
>
rm: remove directory `archive'? <B
CLASS="command"
>y</B
>
</PRE
></FONT
></TD
></TR
></TABLE
><P
>We will discuss how to make this option the default in <A
HREF="chap_07.html"
>Chapter 7</A
>, which discusses customizing your shell environment.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_03_03"
></A
>3.3.3. Finding files</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_03_01"
></A
>3.3.3.1. Using shell features</H3
><P
>In the example on moving files we already saw how the shell can manipulate multiple files at once.  In that example, the shell finds out automatically what the user means by the requirements between the square braces <SPAN
CLASS="QUOTE"
>"["</SPAN
> and <SPAN
CLASS="QUOTE"
>"]"</SPAN
>.  The shell can substitute ranges of numbers and upper or lower case characters alike.  It also substitutes as many characters as you want with an asterisk, and only one character with a question mark.</P
><P
>All sorts of substitutions can be used simultaneously; the shell is very logical about it.  The <SPAN
CLASS="application"
>Bash</SPAN
> shell, for instance, has no problem with expressions like <B
CLASS="command"
>ls <TT
CLASS="parameter"
><I
>dirname/*/*/*[2-3]</I
></TT
></B
>.</P
><P
>In other shells, the asterisk is commonly used to minimize the efforts of typing:  people would enter <B
CLASS="command"
>cd <TT
CLASS="parameter"
><I
>dir*</I
></TT
></B
> instead of <B
CLASS="command"
>cd <TT
CLASS="filename"
>directory</TT
></B
>.  In <SPAN
CLASS="application"
>Bash</SPAN
> however, this is not necessary because the GNU shell has a feature called file name completion.  It means that you can type the first few characters of a command (anywhere) or a file (in the current directory) and if no confusion is possible, the shell will find out what you mean.   For example in a directory containing many files, you can check if there are any files beginning with the letter A just by typing <B
CLASS="command"
>ls <TT
CLASS="parameter"
><I
>A</I
></TT
></B
> and pressing the <B
CLASS="keycap"
>Tab</B
> key twice, rather than pressing <B
CLASS="keycap"
>Enter</B
>.  If there is only one file starting with <SPAN
CLASS="QUOTE"
>"A"</SPAN
>, this file will be shown as the argument to <B
CLASS="command"
>ls</B
> (or any shell command, for that matter) immediately.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_03_02"
></A
>3.3.3.2. Which</H3
><P
>A very simple way of looking up files is using the <B
CLASS="command"
>which</B
> command, to look in the directories listed in the user's search path for the required file.  Of course, since the search path contains only paths to directories containing executable programs, <B
CLASS="command"
>which</B
> doesn't work for ordinary files.  The <B
CLASS="command"
>which</B
> command is useful when troubleshooting <SPAN
CLASS="QUOTE"
>"Command not Found"</SPAN
> problems.  In the example below, user <EM
>tina</EM
> can't use the <B
CLASS="command"
>acroread</B
> program, while her colleague has no troubles whatsoever on the same system.  The problem is similar to the <TT
CLASS="varname"
>PATH</TT
> problem in the previous part: Tina's colleague tells her that he can see the required program in <TT
CLASS="filename"
>/opt/acroread/bin</TT
>, but this directory is not in her path:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tina:~&#62;</TT
> <B
CLASS="command"
>which acroread</B
>
/usr/bin/which: no acroread in (/bin:/usr/bin:/usr/bin/X11)
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The problem can be solved by giving the full path to the command to run, or by re-exporting the content of the <TT
CLASS="varname"
>PATH</TT
> variable:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tina:~&#62;</TT
> <B
CLASS="command"
>export PATH=$PATH:/opt/acroread/bin</B
>

<TT
CLASS="prompt"
>tina:~&#62;</TT
> <B
CLASS="command"
>echo $PATH</B
>
/bin:/usr/bin:/usr/bin/X11:/opt/acroread/bin
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Using the <B
CLASS="command"
>which</B
> command also checks to see if a command is an alias for another command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>gerrit:~&#62;</TT
> <B
CLASS="command"
>which -a ls</B
>
ls is aliased to `ls -F --color=auto'
ls is /bin/ls
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If this does not work on your system, use the <B
CLASS="command"
>alias</B
> command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tille@www:~/mail$</TT
> <B
CLASS="command"
>alias ls</B
>
alias ls='ls --color'
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_03_03"
></A
>3.3.3.3. Find and locate</H3
><P
>These are the real tools, used when searching other paths beside those listed in the search path.  The <B
CLASS="command"
>find</B
> tool, known from UNIX, is very powerful, which may be the cause of a somewhat more difficult syntax.  GNU <B
CLASS="command"
>find</B
>, however, deals with the syntax problems.  This command not only allows you to search file names, it can also accept file size, date of last change and other file properties as criteria for a search.  The most common use is for finding file names:</P
><P
><B
CLASS="command"
>find <TT
CLASS="filename"
>&#60;path&#62;</TT
> <TT
CLASS="option"
>-name</TT
> <TT
CLASS="parameter"
><I
>&#60;searchstring&#62;</I
></TT
></B
> </P
><P
>This can be interpreted as <SPAN
CLASS="QUOTE"
>"Look in all files and subdirectories contained in a given path, and print the names of the files containing the search string in their name"</SPAN
> (not in their content).</P
><P
>Another application of <B
CLASS="command"
>find</B
> is for searching files of a certain size, as in the example below, where user <EM
>peter</EM
> wants to find all files in the current directory or one of its subdirectories, that are bigger than 5 MB:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>peter:~&#62;</TT
> <B
CLASS="command"
>find . -size +5000k</B
>
psychotic_chaos.mp3
</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you dig in the man pages, you will see that <B
CLASS="command"
>find</B
> can also perform operations on the found files.  A common example is removing files.  It is best to first test without the <TT
CLASS="option"
>-exec</TT
> option that the correct files are selected, after that the command can be rerun to delete the selected files.  Below, we search for files ending in <TT
CLASS="filename"
>.tmp</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>peter:~&#62; </TT
> <B
CLASS="command"
>find . -name "*.tmp" -exec rm {} \;</B
>

<TT
CLASS="prompt"
>peter:~&#62;</TT
>
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Optimize!</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>This command will call on <B
CLASS="command"
>rm</B
> as many times as a file answering the requirements is found.  In the worst case, this might be thousands or millions of times.  This is quite a load on your system.</P
><P
>A more realistic way of working would be the use of a pipe (|) and the <B
CLASS="command"
>xargs</B
> tool with <B
CLASS="command"
>rm</B
> as an argument.  This way, the <B
CLASS="command"
>rm</B
> command is only called when the command line is full, instead of for every file.  See <A
HREF="chap_05.html"
>Chapter 5</A
> for more on using I/O redirection to ease everyday tasks.</P
></TD
></TR
></TABLE
></DIV
><P
>Later on (in 1999 according to the man pages, after 20 years of <B
CLASS="command"
>find</B
>), <B
CLASS="command"
>locate</B
> was developed.  This program is easier to use, but more restricted than <B
CLASS="command"
>find</B
>, since its output is based on a file index database that is updated only once every day.  On the other hand, a search in the <B
CLASS="command"
>locate</B
> database uses less resources than <B
CLASS="command"
>find</B
> and therefore shows the results nearly instantly.</P
><P
>Most Linux distributions use <B
CLASS="command"
>slocate</B
> these days, security enhanced locate, the modern version of <B
CLASS="command"
>locate</B
> that prevents users from getting output they have no right to read.  The files in <EM
>root</EM
>'s home directory are such an example, these are not normally accessible to the public.  A user who wants to find someone who knows about the <SPAN
CLASS="application"
>C shell</SPAN
> may issue the command <B
CLASS="command"
>locate <TT
CLASS="filename"
>.cshrc</TT
></B
>, to display all users who have a customized configuration file for the <SPAN
CLASS="application"
>C shell</SPAN
>.  Supposing the users <EM
>root</EM
> and <EM
>jenny</EM
> are running <SPAN
CLASS="application"
>C shell</SPAN
>, then only the file <TT
CLASS="filename"
>/home/jenny/.cshrc</TT
> will be displayed, and not the one in <EM
>root</EM
>'s home directory.  On most systems, <B
CLASS="command"
>locate</B
> is a symbolic link to the <B
CLASS="command"
>slocate</B
> program:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>billy:~&#62;</TT
> <B
CLASS="command"
>ls -l /usr/bin/locate</B
>
lrwxrwxrwx 1 root slocate  7 Oct 28 14:18 /usr/bin/locate -&#62; slocate*
</PRE
></FONT
></TD
></TR
></TABLE
><P
>User <EM
>tina</EM
> could have used <B
CLASS="command"
>locate</B
> to find the application she wanted:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tina:~&#62;</TT
> <B
CLASS="command"
>locate acroread</B
>
/usr/share/icons/hicolor/16x16/apps/acroread.png
/usr/share/icons/hicolor/32x32/apps/acroread.png
/usr/share/icons/locolor/16x16/apps/acroread.png
/usr/share/icons/locolor/32x32/apps/acroread.png
/usr/local/bin/acroread
/usr/local/Acrobat4/Reader/intellinux/bin/acroread
/usr/local/Acrobat4/bin/acroread
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Directories that don't contain the name <TT
CLASS="filename"
>bin</TT
> can't contain the program - they don't contain executable files.  There are three possibilities left.  The file in <TT
CLASS="filename"
>/usr/local/bin</TT
> is the one <EM
>tina</EM
> would have wanted: it is a link to the shell script that starts the actual program:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tina:~&#62;</TT
> <B
CLASS="command"
>file /usr/local/bin/acroread</B
>
/usr/local/bin/acroread: symbolic link to ../Acrobat4/bin/acroread

<TT
CLASS="prompt"
>tina:~&#62;</TT
> <B
CLASS="command"
>file /usr/local/Acrobat4/bin/acroread</B
>
/usr/local/Acrobat4/bin/acroread: Bourne shell script text executable

<TT
CLASS="prompt"
>tina:~&#62;</TT
> <B
CLASS="command"
>file /usr/local/Acrobat4/Reader/intellinux/bin/acroread</B
>
/usr/local/Acrobat4/Reader/intellinux/bin/acroread: ELF 32-bit LSB 
executable, Intel 80386, version 1, dynamically linked (uses 
shared libs), not stripped
</PRE
></FONT
></TD
></TR
></TABLE
><P
>In order to keep the path as short as possible, so the system doesn't have to search too long every time a user wants to execute a command, we add <TT
CLASS="filename"
>/usr/local/bin</TT
> to the path and not the other directories, which only contain the binary files of one specific program, while <TT
CLASS="filename"
>/usr/local/bin</TT
> contains other useful programs as well.</P
><P
>Again, a description of the full features of <B
CLASS="command"
>find</B
> and <B
CLASS="command"
>locate</B
> can be found in the <SPAN
CLASS="application"
>Info</SPAN
> pages.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_03_04"
></A
>3.3.3.4. The grep command</H3
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="sect_03_03_03_04_01"
></A
>3.3.3.4.1. General line filtering</H4
><P
>A simple but powerful program, <B
CLASS="command"
>grep</B
> is used for filtering input lines and returning certain patterns to the output.  There are literally thousands of applications for the <B
CLASS="command"
>grep</B
> program.  In the example below, <EM
>jerry</EM
> uses <B
CLASS="command"
>grep</B
> to see how he did the thing with <B
CLASS="command"
>find</B
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>jerry:~&#62;</TT
> <B
CLASS="command"
>grep -a find .bash_history</B
>
find . -name userinfo
man find
find ../ -name common.cfg
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Search history</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Also useful in these cases is the search function in <B
CLASS="command"
>bash</B
>, activated by pressing <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>R</B
> at once, such as in the example where we want to check how we did that last <B
CLASS="command"
>find</B
> again:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>thomas ~&#62;</TT
> <B
CLASS="command"
>^R</B
> 
(reverse-i-search)`find': find `/home/thomas` -name *.xml
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Type your search string at the search prompt.  The more characters you type, the more restricted the search gets.  This reads the command history for this shell session (which is written to <TT
CLASS="filename"
>.bash_history</TT
> in your home directory when you quit that session).  The most recent occurrence of your search string is shown.  If you want to see previous commands containing the same string, type <B
CLASS="keycap"
>Ctrl</B
>+<B
CLASS="keycap"
>R</B
> again.</P
><P
>See the <SPAN
CLASS="application"
>Info</SPAN
> pages on <B
CLASS="command"
>bash</B
> for more.</P
></TD
></TR
></TABLE
></DIV
><P
>All UNIXes with just a little bit of decency have an online dictionary.  So does Linux.  The dictionary is a list of known words in a file named <TT
CLASS="filename"
>words</TT
>, located in <TT
CLASS="filename"
>/usr/share/dict</TT
>.  To quickly check the correct spelling of a word, no graphical application is needed:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>william:~&#62;</TT
> <B
CLASS="command"
>grep pinguin /usr/share/dict/words</B
>

<TT
CLASS="prompt"
>william:~&#62;</TT
> <B
CLASS="command"
>grep penguin /usr/share/dict/words</B
>
penguin
penguins
</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="tip"
><P
></P
><TABLE
CLASS="tip"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Dictionary vs. word list</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Some distributions offer the <B
CLASS="command"
>dict</B
> command, which offers more features than simply searching words in a list.</P
></TD
></TR
></TABLE
></DIV
><P
>Who is the owner of that home directory next to mine?  Hey, there's his telephone number!</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>lisa:~&#62;</TT
> <B
CLASS="command"
>grep gdbruyne /etc/passwd</B
>
gdbruyne:x:981:981:Guy Debruyne, tel 203234:/home/gdbruyne:/bin/bash
</PRE
></FONT
></TD
></TR
></TABLE
><P
>And what was the E-mail address of Arno again?</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>serge:~/mail&#62;</TT
> <B
CLASS="command"
>grep -i arno *</B
>
sent-mail: To: &#60;Arno.Hintjens@celeb.com&#62;
sent-mail: On Mon, 24 Dec 2001, Arno.Hintjens@celeb.com wrote:
</PRE
></FONT
></TD
></TR
></TABLE
><P
><B
CLASS="command"
>find</B
> and <B
CLASS="command"
>locate</B
> are often used in combination with <B
CLASS="command"
>grep</B
> to define some serious queries.  For more information, see <A
HREF="chap_05.html"
>Chapter 5</A
> on I/O redirection.</P
></DIV
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="sect_03_03_03_04_02"
></A
>3.3.3.4.2. Special characters</H4
><P
>Characters that have a special meaning to the shell have to be <EM
>escaped</EM
>.  The escape character in <SPAN
CLASS="application"
>Bash</SPAN
> is backslash, as in most shells; this takes away the special meaning of the following character.  The shell knows about quite some special characters, among the most common /, ., ? and *.  A full list can be found in the Info pages and documentation for your shell.</P
><P
>For instance, say that you want to display the file <SPAN
CLASS="QUOTE"
>"*"</SPAN
> instead of all the files in a directory, you would have to use </P
><P
><B
CLASS="command"
>less <TT
CLASS="filename"
>\*</TT
></B
> </P
><P
>The same goes for filenames containing a space:</P
><P
><B
CLASS="command"
>cat <TT
CLASS="filename"
>This\ File</TT
></B
> </P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_03_04"
></A
>3.3.4. More ways to view file content</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_04_01"
></A
>3.3.4.1. General</H3
><P
>Apart from <B
CLASS="command"
>cat</B
>, which really doesn't do much more than sending files to the standard output, there are other tools to view file content.</P
><P
>The easiest way of course would be to use graphical tools instead of command line tools.  In the introduction we already saw a glimpse of an office application, <SPAN
CLASS="application"
>OpenOffice.org</SPAN
>.  Other examples are the <SPAN
CLASS="application"
>GIMP</SPAN
> (start up with <B
CLASS="command"
>gimp</B
> from the command line), the GNU Image Manipulation Program; <B
CLASS="command"
>xpdf</B
> to view Portable Document Format files (PDF); <SPAN
CLASS="application"
>GhostView</SPAN
> (<B
CLASS="command"
>gv</B
>) for viewing PostScript files; <SPAN
CLASS="application"
>Mozilla/FireFox</SPAN
>, <B
CLASS="command"
>links</B
> (a text mode browser), <SPAN
CLASS="application"
>Konqueror</SPAN
>, <SPAN
CLASS="application"
>Opera</SPAN
> and many others for web content; XMMS, <SPAN
CLASS="application"
>CDplay</SPAN
> and others for multimedia file content; <SPAN
CLASS="application"
>AbiWord</SPAN
>, <SPAN
CLASS="application"
>Gnumeric</SPAN
>, <SPAN
CLASS="application"
>KOffice</SPAN
> etc. for all kinds of office applications and so on.  There are thousands of Linux applications; to list them all would take days.</P
><P
>Instead we keep concentrating on shell- or text-mode applications, which form the basics for all other applications.  These commands work best in a text environment on files containing text.  When in doubt, check first using the <B
CLASS="command"
>file</B
> command.</P
><P
>So let's see what text tools we have that are useful to look inside files.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Font problems</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Plain text tools such as the ones we will now be discussing, often have problems with <SPAN
CLASS="QUOTE"
>"plain"</SPAN
> text files because of the font encoding used in those files.  Special characters, such as accented alphabetical characters, Chinese characters and other characters from languages using different character sets than the default <EM
>en_US</EM
> encoding and so on, are then displayed the wrong way or replaced by unreadable rubbish.  These problems are discussed in <A
HREF="sect_07_05.html"
>Section 7.4</A
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_04_02"
></A
>3.3.4.2. <SPAN
CLASS="QUOTE"
>"<B
CLASS="command"
>less</B
> is <B
CLASS="command"
>more</B
>"</SPAN
></H3
><P
>Undoubtedly you will hear someone say this phrase sooner or later when working in a UNIX environment.  A little bit of UNIX history explains this:</P
><P
></P
><UL
><LI
><P
>First there was <B
CLASS="command"
>cat</B
>.  Output was streamed in an uncontrollable way.</P
></LI
><LI
><P
>Then there was <B
CLASS="command"
>pg</B
>, which may still be found on older UNIXes.  This command puts text to the output one page at the time.</P
></LI
><LI
><P
>The <B
CLASS="command"
>more</B
> program was a revised version of <B
CLASS="command"
>pg</B
>.  This command is still available on every Linux system.</P
></LI
><LI
><P
><B
CLASS="command"
>less</B
> is the GNU version of more and has extra features allowing highlighting of search strings, scrolling back etc.  The syntax is very simple:</P
><P
><B
CLASS="command"
>less <TT
CLASS="filename"
>name_of_file</TT
></B
> </P
><P
>More information is located in the <SPAN
CLASS="application"
>Info</SPAN
> pages.</P
></LI
></UL
><P
>You already know about pagers by now, because they are used for viewing the man pages.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_04_03"
></A
>3.3.4.3. The head and tail commands</H3
><P
>These two commands display the n first/last lines of a file respectively.  To see the last ten commands entered:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>tony:~&#62;</TT
> <B
CLASS="command"
>tail -10 .bash_history </B
>
locate configure | grep bin
man bash
cd
xawtv &#38;
grep usable /usr/share/dict/words 
grep advisable /usr/share/dict/words 
info quota
man quota
echo $PATH
frm
</PRE
></FONT
></TD
></TR
></TABLE
><P
><B
CLASS="command"
>head</B
> works similarly.  The <B
CLASS="command"
>tail</B
> command has a handy feature to continuously show the last n lines of a file that changes all the time.  This <TT
CLASS="option"
>-f</TT
> option is often used by system administrators to check on log files.  More information is located in the system documentation files.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="sect_03_03_05"
></A
>3.3.5. Linking files</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_05_01"
></A
>3.3.5.1. Link types</H3
><P
>Since we know more about files and their representation in the file system, understanding links (or shortcuts) is a piece of cake.  A link is nothing more than a way of matching two or more file names to the same set of file data.  There are two ways to achieve this:</P
><P
></P
><UL
><LI
><P
>Hard link: Associate two or more file names with the same inode.  Hard links share the same data blocks on the hard disk, while they continue to behave as independent files.</P
><P
>There is an immediate disadvantage: hard links can't span partitions, because inode numbers are only unique within a given partition.</P
></LI
><LI
><P
>Soft link or symbolic link (or for short: symlink): a small file that is a pointer to another file.  A symbolic link contains the path to the target file instead of a physical location on the hard disk.  Since inodes are not used in this system, soft links can span across partitions.</P
></LI
></UL
><P
>The two link types behave similar, but are not the same, as illustrated in the scheme below:</P
><DIV
CLASS="figure"
><A
NAME="AEN3699"
></A
><P
><B
>Figure 3-2. Hard and soft link mechanism</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/links.png"></P
></DIV
></DIV
><P
>Note that removing the target file for a symbolic link makes the link useless.</P
><P
>Each regular file is in principle a hardlink.  Hardlinks can not span across partitions, since they refer to inodes, and inode numbers are only unique within a given partition.</P
><P
>It may be argued that there is a third kind of link, the <EM
>user-space</EM
> link, which is similar to a shortcut in MS Windows.  These are files containing meta-data which can only be interpreted by the graphical file manager.  To the kernel and the shell these are just normal files.  They may end in a <EM
>.desktop</EM
> or <EM
>.lnk</EM
> suffix; an example can be found in <TT
CLASS="filename"
>~/.gnome-desktop</TT
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[dupont@boulot .gnome-desktop]$</TT
> <B
CLASS="command"
>cat La\ Maison\ Dupont</B
>
[Desktop Entry]
Encoding=Legacy-Mixed
Name=La Maison Dupont
Type=X-nautilus-home
X-Nautilus-Icon=temp-home
URL=file:///home/dupont
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This example is from a <SPAN
CLASS="application"
>KDE</SPAN
> desktop:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>[lena@venus Desktop]$</TT
> <B
CLASS="command"
>cat camera</B
>
[Desktop Entry]
Dev=/dev/sda1
FSType=auto
Icon=memory
MountPoint=/mnt/camera
Type=FSDevice
X-KDE-Dynamic-Device=true
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Creating this kind of link is easy enough using the features of your graphical environment.  Should you need help, your system documentation should be your first resort.</P
><P
>In the next section, we will study the creation of UNIX-style symbolic links using the command line.</P
></DIV
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="sect_03_03_05_02"
></A
>3.3.5.2. Creating symbolic links</H3
><P
>The symbolic link is particularly interesting for beginning users: they are fairly obvious to see and you don't need to worry about partitions.</P
><P
>The command to make links is <B
CLASS="command"
>ln</B
>.  In order to create symlinks, you need to use the <TT
CLASS="option"
>-s</TT
> option:</P
><P
><B
CLASS="command"
>ln <TT
CLASS="option"
>-s</TT
> <TT
CLASS="filename"
>targetfile</TT
> <TT
CLASS="filename"
>linkname</TT
></B
> </P
><P
>In the example below, user <EM
>freddy</EM
> creates a link in a subdirectory of his home directory to a directory on another part of the system:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;<TT
CLASS="prompt"
>freddy:~/music&#62;</TT
> <B
CLASS="command"
>ln -s /opt/mp3/Queen/ Queen</B
>

<TT
CLASS="prompt"
>freddy:~/music&#62;</TT
> <B
CLASS="command"
>ls -l</B
>
lrwxrwxrwx  1 freddy  freddy  17 Jan 22 11:07 Queen -&#62; /opt/mp3/Queen
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Symbolic links are always very small files, while hard links have the same size as the original file.</P
><P
>The application of symbolic links is widespread.  They are often used to save disk space, to make a copy of a file in order to satisfy installation requirements of a new program that expects the file to be in another location, they are used to fix scripts that suddenly have to run in a new environment and can generally save a lot of work.  A system admin may decide to move the home directories of the users to a new location, <TT
CLASS="filename"
>disk2</TT
> for instance, but if he wants everything to work like before, like the <TT
CLASS="filename"
>/etc/passwd</TT
> file, with a minimum of effort he will create a symlink from <TT
CLASS="filename"
>/home</TT
> to the new location <TT
CLASS="filename"
>/disk2/home</TT
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sect_03_02.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sect_03_04.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Orientation in the file system</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="chap_03.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>File security</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>