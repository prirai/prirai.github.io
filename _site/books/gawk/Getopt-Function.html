<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2020 

Free Software Foundation, Inc.



This is Edition 5.1 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.1.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Getopt Function (The GNU Awk User&rsquo;s Guide)</title>

<meta name="description" content="Getopt Function (The GNU Awk User&rsquo;s Guide)">
<meta name="keywords" content="Getopt Function (The GNU Awk User&rsquo;s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Library-Functions.html" rel="up" title="Library Functions">
<link href="Passwd-Functions.html" rel="next" title="Passwd Functions">
<link href="Ignoring-Assigns.html" rel="prev" title="Ignoring Assigns">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


<link rel="stylesheet" type="text/css" href="../bookstyle.css"></head>

<body lang="en">
<span id="Getopt-Function"></span><div class="header">
<p>
Next: <a href="Passwd-Functions.html" accesskey="n" rel="next">Passwd Functions</a>, Previous: <a href="Data-File-Management.html" accesskey="p" rel="prev">Data File Management</a>, Up: <a href="Library-Functions.html" accesskey="u" rel="up">Library Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Processing-Command_002dLine-Options"></span><h3 class="section">10.4 Processing Command-Line Options</h3>

<span id="index-libraries-of-awk-functions-8"></span>
<span id="index-functions-23"></span>
<span id="index-command-line-12"></span>
<span id="index-options-7"></span>
<span id="index-functions-24"></span>
<span id="index-arguments-5"></span>
<p>Most utilities on POSIX-compatible systems take options on
the command line that can be used to change the way a program behaves.
<code>awk</code> is an example of such a program
(see section <a href="Options.html">Command-Line Options</a>).
Often, options take <em>arguments</em> (i.e., data that the program needs to
correctly obey the command-line option).  For example, <code>awk</code>&rsquo;s
<samp>-F</samp> option requires a string to use as the field separator.
The first occurrence on the command line of either <samp>--</samp> or a
string that does not begin with &lsquo;<samp>-</samp>&rsquo; ends the options.
</p>
<span id="index-getopt_0028_0029-function-_0028C-library_0029"></span>
<span id="index-C-library-functions-1"></span>
<p>Modern Unix systems provide a C function named <code>getopt()</code> for processing
command-line arguments.  The programmer provides a string describing the
one-letter options. If an option requires an argument, it is followed in the
string with a colon.  <code>getopt()</code> is also passed the
count and values of the command-line arguments and is called in a loop.
<code>getopt()</code> processes the command-line arguments for option letters.
Each time around the loop, it returns a single character representing the
next option letter that it finds, or &lsquo;<samp>?</samp>&rsquo; if it finds an invalid option.
When it returns -1, there are no options left on the command line.
</p>
<p>When using <code>getopt()</code>, options that do not take arguments can be
grouped together.  Furthermore, options that take arguments require that the
argument be present.  The argument can immediately follow the option letter,
or it can be a separate command-line argument.
</p>
<p>Given a hypothetical program that takes
three command-line options, <samp>-a</samp>, <samp>-b</samp>, and <samp>-c</samp>, where
<samp>-b</samp> requires an argument, all of the following are valid ways of
invoking the program:
</p>
<div class="example">
<pre class="example">prog -a -b foo -c data1 data2 data3
prog -ac -bfoo -- data1 data2 data3
prog -acbfoo data1 data2 data3
</pre></div>

<p>Notice that when the argument is grouped with its option, the rest of
the argument is considered to be the option&rsquo;s argument.
In this example, <samp>-acbfoo</samp> indicates that all of the
<samp>-a</samp>, <samp>-b</samp>, and <samp>-c</samp> options were supplied,
and that &lsquo;<samp>foo</samp>&rsquo; is the argument to the <samp>-b</samp> option.
</p>
<p><code>getopt()</code> provides four external variables that the programmer can use:
</p>
<dl compact="compact">
<dt><code>optind</code></dt>
<dd><p>The index in the argument value array (<code>argv</code>) where the first
nonoption command-line argument can be found.
</p>
</dd>
<dt><code>optarg</code></dt>
<dd><p>The string value of the argument to an option.
</p>
</dd>
<dt><code>opterr</code></dt>
<dd><p>Usually <code>getopt()</code> prints an error message when it finds an invalid
option.  Setting <code>opterr</code> to zero disables this feature.  (An
application might want to print its own error message.)
</p>
</dd>
<dt><code>optopt</code></dt>
<dd><p>The letter representing the command-line option.
</p></dd>
</dl>

<p>The following C fragment shows how <code>getopt()</code> might process command-line
arguments for <code>awk</code>:
</p>
<div class="example">
<pre class="example">int
main(int argc, char *argv[])
{
    &hellip;
    /* print our own message */
    opterr = 0;
    while ((c = getopt(argc, argv, &quot;v:f:F:W:&quot;)) != -1) {
        switch (c) {
        case 'f':    /* file */
            &hellip;
            break;
        case 'F':    /* field separator */
            &hellip;
            break;
        case 'v':    /* variable assignment */
            &hellip;
            break;
        case 'W':    /* extension */
            &hellip;
            break;
        case '?':
        default:
            usage();
            break;
        }
    }
    &hellip;
}
</pre></div>

<p>The GNU project&rsquo;s version of the original Unix utilities popularized
the use of long command line options.  For example, <samp>--help</samp>
in addition to <samp>-h</samp>. Arguments to long options are either provided
as separate command line arguments (&lsquo;<samp>--source '<var>program-text</var>'</samp>&rsquo;)
or separated from the option with an &lsquo;<samp>=</samp>&rsquo; sign
(&lsquo;<samp>--source='<var>program-text</var>'</samp>&rsquo;).
</p>
<p>As a side point, <code>gawk</code> actually uses the GNU <code>getopt_long()</code>
function to process both normal and GNU-style long options
(see section <a href="Options.html">Command-Line Options</a>).
</p>
<p>The abstraction provided by <code>getopt()</code> is very useful and is quite
handy in <code>awk</code> programs as well.  Following is an <code>awk</code>
version of <code>getopt()</code> that accepts both short and long options.
</p>
<p>This function highlights one of the
greatest weaknesses in <code>awk</code>, which is that it is very poor at
manipulating single characters.  The function needs repeated calls to
<code>substr()</code> in order to access individual characters
(see section <a href="String-Functions.html">String-Manipulation Functions</a>).<a id="DOCF73" href="#FOOT73"><sup>73</sup></a>
</p>
<p>The discussion that follows walks through the code a bit at a time:
</p>
<span id="index-getopt_0028_0029-user_002ddefined-function"></span>
<span id="index-user_002ddefined-17"></span>
<div class="example">
<pre class="example"># getopt.awk --- Do C library getopt(3) function in awk
#                Also supports long options.

# External variables:
#    Optind -- index in ARGV of first nonoption argument
#    Optarg -- string value of argument to current option
#    Opterr -- if nonzero, print our own diagnostic
#    Optopt -- current option letter

# Returns:
#    -1     at end of options
#    &quot;?&quot;    for unrecognized option
#    &lt;s&gt;    a string representing the current option

# Private Data:
#    _opti  -- index in multiflag option, e.g., -abc
</pre></div>

<p>The function starts out with comments presenting
a list of the global variables it uses,
what the return values are, what they mean, and any global variables that
are &ldquo;private&rdquo; to this library function.  Such documentation is essential
for any program, and particularly for library functions.
</p>
<p>The <code>getopt()</code> function first checks that it was indeed called with
a string of options (the <code>options</code> parameter).  If both
<code>options</code> and <code>longoptions</code> have a zero length,
<code>getopt()</code> immediately returns -1:
</p>
<span id="index-getopt_0028_0029-user_002ddefined-function-1"></span>
<span id="index-user_002ddefined-18"></span>
<div class="example">
<pre class="example">function getopt(argc, argv, options, longopts,    thisopt, i, j)
{
    if (length(options) == 0 &amp;&amp; length(longopts) == 0)
        return -1                # no options given

</pre><pre class="example">    if (argv[Optind] == &quot;--&quot;) {  # all done
        Optind++
        _opti = 0
        return -1
</pre><pre class="example">    } else if (argv[Optind] !~ /^-[^:[:space:]]/) {
        _opti = 0
        return -1
    }
</pre></div>

<p>The next thing to check for is the end of the options.  A <samp>--</samp>
ends the command-line options, as does any command-line argument that
does not begin with a &lsquo;<samp>-</samp>&rsquo; (unless it is an argument to a preceding
option).  <code>Optind</code> steps through
the array of command-line arguments; it retains its value across calls
to <code>getopt()</code>, because it is a global variable.
</p>
<p>The regular expression <code><span class="nolinebreak">/^-[^:[:space:]/</span><!-- /@w --></code>
checks for a &lsquo;<samp>-</samp>&rsquo; followed by anything
that is not whitespace and not a colon.
If the current command-line argument does not match this pattern,
it is not an option, and it ends option processing.
Now, we
check to see if we are processing a short (single letter) option, or a
long option (indicated by two dashes, e.g., &lsquo;<samp>--filename</samp>&rsquo;).  If it
is a short option, we continue on:
</p>
<div class="example">
<pre class="example">    if (argv[Optind] !~ /^--/) {        # if this is a short option
        if (_opti == 0)
            _opti = 2
        thisopt = substr(argv[Optind], _opti, 1)
        Optopt = thisopt
        i = index(options, thisopt)
        if (i == 0) {
            if (Opterr)
                printf(&quot;%c -- invalid option\n&quot;, thisopt) &gt; &quot;/dev/stderr&quot;
            if (_opti &gt;= length(argv[Optind])) {
                Optind++
                _opti = 0
            } else
                _opti++
            return &quot;?&quot;
        }
</pre></div>

<p>The <code>_opti</code> variable tracks the position in the current command-line
argument (<code>argv[Optind]</code>).  If multiple options are
grouped together with one &lsquo;<samp>-</samp>&rsquo; (e.g., <samp>-abx</samp>), it is necessary
to return them to the user one at a time.
</p>
<p>If <code>_opti</code> is equal to zero, it is set to two, which is the index in
the string of the next character to look at (we skip the &lsquo;<samp>-</samp>&rsquo;, which
is at position one).  The variable <code>thisopt</code> holds the character,
obtained with <code>substr()</code>.  It is saved in <code>Optopt</code> for the main
program to use.
</p>
<p>If <code>thisopt</code> is not in the <code>options</code> string, then it is an
invalid option.  If <code>Opterr</code> is nonzero, <code>getopt()</code> prints an error
message on the standard error that is similar to the message from the C
version of <code>getopt()</code>.
</p>
<p>Because the option is invalid, it is necessary to skip it and move on to the
next option character.  If <code>_opti</code> is greater than or equal to the
length of the current command-line argument, it is necessary to move on
to the next argument, so <code>Optind</code> is incremented and <code>_opti</code> is reset
to zero. Otherwise, <code>Optind</code> is left alone and <code>_opti</code> is merely
incremented.
</p>
<p>In any case, because the option is invalid, <code>getopt()</code> returns <code>&quot;?&quot;</code>.
The main program can examine <code>Optopt</code> if it needs to know what the
invalid option letter actually is. Continuing on:
</p>
<div class="example">
<pre class="example">        if (substr(options, i + 1, 1) == &quot;:&quot;) {
            # get option argument
            if (length(substr(argv[Optind], _opti + 1)) &gt; 0)
                Optarg = substr(argv[Optind], _opti + 1)
            else
                Optarg = argv[++Optind]
            _opti = 0
        } else
            Optarg = &quot;&quot;
</pre></div>

<p>If the option requires an argument, the option letter is followed by a colon
in the <code>options</code> string.  If there are remaining characters in the
current command-line argument (<code>argv[Optind]</code>), then the rest of that
string is assigned to <code>Optarg</code>.  Otherwise, the next command-line
argument is used (&lsquo;<samp>-xFOO</samp>&rsquo; versus &lsquo;<samp><span class="nolinebreak">-x</span>&nbsp;FOO<!-- /@w --></samp>&rsquo;). In either case,
<code>_opti</code> is reset to zero, because there are no more characters left to
examine in the current command-line argument. Continuing:
</p>
<div class="example">
<pre class="example">        if (_opti == 0 || _opti &gt;= length(argv[Optind])) {
            Optind++
            _opti = 0
        } else
            _opti++
        return thisopt
</pre></div>

<p>Finally, for a short option, if <code>_opti</code> is either zero or greater
than the length of the current command-line argument, it means this
element in <code>argv</code> is through being processed, so <code>Optind</code> is
incremented to point to the next element in <code>argv</code>.  If neither
condition is true, then only <code>_opti</code> is incremented, so that the
next option letter can be processed on the next call to <code>getopt()</code>.
</p>
<p>On the other hand, if the earlier test found that this was a long
option, we take a different branch:
</p>
<div class="example">
<pre class="example">    } else {
        j = index(argv[Optind], &quot;=&quot;)
        if (j &gt; 0)
            thisopt = substr(argv[Optind], 3, j - 3)
        else
            thisopt = substr(argv[Optind], 3)
        Optopt = thisopt
</pre></div>

<p>First, we search this option for a possible embedded equal sign, as the
specification of long options allows an argument to an option
&lsquo;<samp>--someopt:</samp>&rsquo; to be specified as &lsquo;<samp>--someopt=answer</samp>&rsquo; as well as
&lsquo;<samp><span class="nolinebreak">--someopt</span>&nbsp;answer<!-- /@w --></samp>&rsquo;.
</p>
<div class="example">
<pre class="example">        i = match(longopts, &quot;(^|,)&quot; thisopt &quot;($|[,:])&quot;)
        if (i == 0) {
            if (Opterr)
                 printf(&quot;%s -- invalid option\n&quot;, thisopt) &gt; &quot;/dev/stderr&quot;
            Optind++
            return &quot;?&quot;
        }
</pre></div>

<p>Next, we try to find the current option in <code>longopts</code>.  The regular
expression given to <code>match()</code>, <code>&quot;(^|,)&quot;&nbsp;thisopt&nbsp;&quot;($|[,:])&quot;<!-- /@w --></code>,
matches this option at the beginning of <code>longopts</code>, or at the
beginning of a subsequent long option (the previous long option would
have been terminated by a comma), and, in any case, either at the end of
the <code>longopts</code> string (&lsquo;<samp>$</samp>&rsquo;), or followed by a comma
(separating this option from a subsequent option) or a colon (indicating
this long option takes an argument (&lsquo;<samp>[,:]<!-- /@w --></samp>&rsquo;).
</p>
<p>Using this regular expression, we check to see if the current option
might possibly be in <code>longopts</code> (if <code>longopts</code> is not
specified, this test will also fail).  In case of an error, we possibly
print an error message and then return <code>&quot;?&quot;</code>. Continuing on:
</p>
<div class="example">
<pre class="example">        if (substr(longopts, i+1+length(thisopt), 1) == &quot;:&quot;) {
            if (j &gt; 0)
                Optarg = substr(argv[Optind], j + 1)
            else
                Optarg = argv[++Optind]
        } else
            Optarg = &quot;&quot;
</pre></div>

<p>We now check to see if this option takes an argument and, if so, we set
<code>Optarg</code> to the value of that argument (either a value after an
equal sign specified on the command line, immediately adjoining the long
option string, or as the next argument on the command line).
</p>
<div class="example">
<pre class="example">        Optind++
        return thisopt
    }
}
</pre></div>

<p>We increase <code>Optind</code> (which we already increased once if a required
argument was separated from its option by an equal sign), and return the
long option (minus its leading dashes).
</p>
<p>The <code>BEGIN</code> rule initializes both <code>Opterr</code> and <code>Optind</code> to one.
<code>Opterr</code> is set to one, because the default behavior is for <code>getopt()</code>
to print a diagnostic message upon seeing an invalid option.  <code>Optind</code>
is set to one, because there&rsquo;s no reason to look at the program name, which is
in <code>ARGV[0]</code>:
</p>
<div class="example">
<pre class="example">BEGIN {
    Opterr = 1    # default is to diagnose
    Optind = 1    # skip ARGV[0]

    # test program
    if (_getopt_test) {
        _myshortopts = &quot;ab:cd&quot;
        _mylongopts = &quot;longa,longb:,otherc,otherd&quot;

        while ((_go_c = getopt(ARGC, ARGV, _myshortopts, _mylongopts)) != -1)
            printf(&quot;c = &lt;%s&gt;, Optarg = &lt;%s&gt;\n&quot;, _go_c, Optarg)
        printf(&quot;non-option arguments:\n&quot;)
        for (; Optind &lt; ARGC; Optind++)
            printf(&quot;\tARGV[%d] = &lt;%s&gt;\n&quot;, Optind, ARGV[Optind])
    }
}
</pre></div>

<p>The rest of the <code>BEGIN</code> rule is a simple test program.  Here are the
results of some sample runs of the test program:
</p>
<div class="example">
<pre class="example">$ <kbd>awk -f getopt.awk -v _getopt_test=1 -- -a -cbARG bax -x</kbd>
-| c = &lt;a&gt;, Optarg = &lt;&gt;
-| c = &lt;c&gt;, Optarg = &lt;&gt;
-| c = &lt;b&gt;, Optarg = &lt;ARG&gt;
-| non-option arguments:
-|         ARGV[3] = &lt;bax&gt;
-|         ARGV[4] = &lt;-x&gt;

$ <kbd>awk -f getopt.awk -v _getopt_test=1 -- -a -x -- xyz abc</kbd>
-| c = &lt;a&gt;, Optarg = &lt;&gt;
error&rarr; x -- invalid option
-| c = &lt;?&gt;, Optarg = &lt;&gt;
-| non-option arguments:
-|         ARGV[4] = &lt;xyz&gt;
-|         ARGV[5] = &lt;abc&gt;

$ <kbd>awk -f getopt.awk -v _getopt_test=1 -- -a \</kbd>
&gt; <kbd>--longa -b xx --longb=foo=bar --otherd --otherc arg1 arg2</kbd>
-| c = &lt;a&gt;, Optarg = &lt;&gt;
-| c = &lt;longa&gt;, Optarg = &lt;&gt;
-| c = &lt;b&gt;, Optarg = &lt;xx&gt;
-| c = &lt;longb&gt;, Optarg = &lt;foo=bar&gt;
-| c = &lt;otherd&gt;, Optarg = &lt;&gt;
-| c = &lt;otherc&gt;, Optarg = &lt;&gt;
-| non-option arguments:
-| 	ARGV[8] = &lt;arg1&gt;
-| 	ARGV[9] = &lt;arg2&gt;
</pre></div>

<p>In all the runs, the first <samp>--</samp> terminates the arguments to
<code>awk</code>, so that it does not try to interpret the <samp>-a</samp>,
etc., as its own options.
</p>
<blockquote>
<p><b>NOTE:</b> After <code>getopt()</code> is through,
user-level code must clear out all the elements of <code>ARGV</code> from 1
to <code>Optind</code>, so that <code>awk</code> does not try to process the
command-line options as file names.
</p></blockquote>

<p>Using &lsquo;<samp>#!</samp>&rsquo; with the <samp>-E</samp> option may help avoid
conflicts between your program&rsquo;s options and <code>gawk</code>&rsquo;s options,
as <samp>-E</samp> causes <code>gawk</code> to abandon processing of
further options
(see section <a href="Executable-Scripts.html">Executable <code>awk</code> Programs</a> and
see section <a href="Options.html">Command-Line Options</a>).
</p>
<p>Several of the sample programs presented in
<a href="Sample-Programs.html">Practical <code>awk</code> Programs</a>,
use <code>getopt()</code> to process their arguments.
</p>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT73" href="#DOCF73">(73)</a></h3>
<p>This
function was written before <code>gawk</code> acquired the ability to
split strings into single characters using <code>&quot;&quot;</code> as the separator.
We have left it alone, as using <code>substr()</code> is more portable.</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Passwd-Functions.html" accesskey="n" rel="next">Passwd Functions</a>, Previous: <a href="Data-File-Management.html" accesskey="p" rel="prev">Data File Management</a>, Up: <a href="Library-Functions.html" accesskey="u" rel="up">Library Functions</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
