<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- 
Copyright (C) 1989, 1991, 1992, 1993, 1996-2005, 2007, 2009-2020 

Free Software Foundation, Inc.



This is Edition 5.1 of GAWK: Effective AWK Programming: A User's Guide for GNU Awk,
for the 5.1.0 (or later) version of the GNU
implementation of AWK.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License", with the
Front-Cover Texts being "A GNU Manual", and with the Back-Cover Texts
as in (a) below.
A copy of the license is included in the section entitled
"GNU Free Documentation License".

a. The FSF's Back-Cover Text is: "You have the freedom to
copy and modify this GNU manual." -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Egrep Program (The GNU Awk User&rsquo;s Guide)</title>

<meta name="description" content="Egrep Program (The GNU Awk User&rsquo;s Guide)">
<meta name="keywords" content="Egrep Program (The GNU Awk User&rsquo;s Guide)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Clones.html" rel="up" title="Clones">
<link href="Id-Program.html" rel="next" title="Id Program">
<link href="Cut-Program.html" rel="prev" title="Cut Program">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="/software/gnulib/manual.css">


<link rel="stylesheet" type="text/css" href="../bookstyle.css"></head>

<body lang="en">
<span id="Egrep-Program"></span><div class="header">
<p>
Next: <a href="Id-Program.html" accesskey="n" rel="next">Id Program</a>, Previous: <a href="Cut-Program.html" accesskey="p" rel="prev">Cut Program</a>, Up: <a href="Clones.html" accesskey="u" rel="up">Clones</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Searching-for-Regular-Expressions-in-Files"></span><h4 class="subsection">11.2.2 Searching for Regular Expressions in Files</h4>

<span id="index-regular-expressions-21"></span>
<span id="index-searching"></span>
<span id="index-files-19"></span>
<span id="index-egrep-utility-1"></span>
<p>The <code>egrep</code> utility searches files for patterns.  It uses regular
expressions that are almost identical to those available in <code>awk</code>
(see section <a href="Regexp.html">Regular Expressions</a>).
You invoke it as follows:
</p>
<div class="display">
<pre class="display"><code>egrep</code> [<var>options</var>] <code>'<var>pattern</var>'</code> <var>files</var> &hellip;
</pre></div>

<p>The <var>pattern</var> is a regular expression.  In typical usage, the regular
expression is quoted to prevent the shell from expanding any of the
special characters as file name wildcards.  Normally, <code>egrep</code>
prints the lines that matched.  If multiple file names are provided on
the command line, each output line is preceded by the name of the file
and a colon.
</p>
<p>The options to <code>egrep</code> are as follows:
</p>
<dl compact="compact">
<dt><code>-c</code></dt>
<dd><p>Print out a count of the lines that matched the pattern, instead of the
lines themselves.
</p>
</dd>
<dt><code>-s</code></dt>
<dd><p>Be silent.  No output is produced and the exit value indicates whether
the pattern was matched.
</p>
</dd>
<dt><code>-v</code></dt>
<dd><p>Invert the sense of the test. <code>egrep</code> prints the lines that do
<em>not</em> match the pattern and exits successfully if the pattern is not
matched.
</p>
</dd>
<dt><code>-i</code></dt>
<dd><p>Ignore case distinctions in both the pattern and the input data.
</p>
</dd>
<dt><code>-l</code></dt>
<dd><p>Only print (list) the names of the files that matched, not the lines that matched.
</p>
</dd>
<dt><code>-e <var>pattern</var></code></dt>
<dd><p>Use <var>pattern</var> as the regexp to match.  The purpose of the <samp>-e</samp>
option is to allow patterns that start with a &lsquo;<samp>-</samp>&rsquo;.
</p></dd>
</dl>

<p>This version uses the <code>getopt()</code> library function
(see section <a href="Getopt-Function.html">Processing Command-Line Options</a>)
and the file transition library program
(see section <a href="Filetrans-Function.html">Noting Data file Boundaries</a>).
</p>
<p>The program begins with a descriptive comment and then a <code>BEGIN</code> rule
that processes the command-line arguments with <code>getopt()</code>.  The <samp>-i</samp>
(ignore case) option is particularly easy with <code>gawk</code>; we just use the
<code>IGNORECASE</code> predefined variable
(see section <a href="Built_002din-Variables.html">Predefined Variables</a>):
</p>
<span id="index-egrep_002eawk-program"></span>
<div class="example">
<pre class="example"># egrep.awk --- simulate egrep in awk
#
# Options:
#    -c    count of lines
#    -s    silent - use exit value
#    -v    invert test, success if no match
#    -i    ignore case
#    -l    print filenames only
#    -e    argument is pattern
#
# Requires getopt and file transition library functions

BEGIN {
    while ((c = getopt(ARGC, ARGV, &quot;ce:svil&quot;)) != -1) {
        if (c == &quot;c&quot;)
            count_only++
        else if (c == &quot;s&quot;)
            no_print++
        else if (c == &quot;v&quot;)
            invert++
        else if (c == &quot;i&quot;)
            IGNORECASE = 1
        else if (c == &quot;l&quot;)
            filenames_only++
        else if (c == &quot;e&quot;)
            pattern = Optarg
        else
            usage()
    }
</pre></div>

<p>Next comes the code that handles the <code>egrep</code>-specific behavior. If no
pattern is supplied with <samp>-e</samp>, the first nonoption on the
command line is used.  The <code>awk</code> command-line arguments up to <code>ARGV[Optind]</code>
are cleared, so that <code>awk</code> won&rsquo;t try to process them as files.  If no
files are specified, the standard input is used, and if multiple files are
specified, we make sure to note this so that the file names can precede the
matched lines in the output:
</p>
<div class="example">
<pre class="example">    if (pattern == &quot;&quot;)
        pattern = ARGV[Optind++]

    for (i = 1; i &lt; Optind; i++)
        ARGV[i] = &quot;&quot;
    if (Optind &gt;= ARGC) {
        ARGV[1] = &quot;-&quot;
        ARGC = 2
    } else if (ARGC - Optind &gt; 1)
        do_filenames++

#    if (IGNORECASE)
#        pattern = tolower(pattern)
}
</pre></div>

<p>The last two lines are commented out, as they are not needed in
<code>gawk</code>.  They should be uncommented if you have to use another version
of <code>awk</code>.
</p>
<p>The next set of lines should be uncommented if you are not using
<code>gawk</code>.  This rule translates all the characters in the input line
into lowercase if the <samp>-i</samp> option is specified.<a id="DOCF76" href="#FOOT76"><sup>76</sup></a>
The rule is
commented out as it is not necessary with <code>gawk</code>:
</p>
<div class="example">
<pre class="example">#{
#    if (IGNORECASE)
#        $0 = tolower($0)
#}
</pre></div>

<p>The <code>beginfile()</code> function is called by the rule in <samp>ftrans.awk</samp>
when each new file is processed.  In this case, it is very simple; all it
does is initialize a variable <code>fcount</code> to zero. <code>fcount</code> tracks
how many lines in the current file matched the pattern.
Naming the parameter <code>junk</code> shows we know that <code>beginfile()</code>
is called with a parameter, but that we&rsquo;re not interested in its value:
</p>
<div class="example">
<pre class="example">function beginfile(junk)
{
    fcount = 0
}
</pre></div>

<p>The <code>endfile()</code> function is called after each file has been processed.
It affects the output only when the user wants a count of the number of lines that
matched.  <code>no_print</code> is true only if the exit status is desired.
<code>count_only</code> is true if line counts are desired.  <code>egrep</code>
therefore only prints line counts if printing and counting are enabled.
The output format must be adjusted depending upon the number of files to
process.  Finally, <code>fcount</code> is added to <code>total</code>, so that we
know the total number of lines that matched the pattern:
</p>
<div class="example">
<pre class="example">function endfile(file)
{
    if (! no_print &amp;&amp; count_only) {
        if (do_filenames)
            print file &quot;:&quot; fcount
        else
            print fcount
    }

</pre><pre class="example">    total += fcount
}
</pre></div>

<p>The <code>BEGINFILE</code> and <code>ENDFILE</code> special patterns
(see section <a href="BEGINFILE_002fENDFILE.html">The <code>BEGINFILE</code> and <code>ENDFILE</code> Special Patterns</a>) could be used, but then the program would be
<code>gawk</code>-specific. Additionally, this example was written before
<code>gawk</code> acquired <code>BEGINFILE</code> and <code>ENDFILE</code>.
</p>
<p>The following rule does most of the work of matching lines. The variable
<code>matches</code> is true if the line matched the pattern. If the user
wants lines that did not match, the sense of <code>matches</code> is inverted
using the &lsquo;<samp>!</samp>&rsquo; operator. <code>fcount</code> is incremented with the value of
<code>matches</code>, which is either one or zero, depending upon a
successful or unsuccessful match.  If the line does not match, the
<code>next</code> statement just moves on to the next record.
</p>
<p>A number of additional tests are made, but they are only done if we
are not counting lines.  First, if the user only wants the exit status
(<code>no_print</code> is true), then it is enough to know that <em>one</em>
line in this file matched, and we can skip on to the next file with
<code>nextfile</code>.  Similarly, if we are only printing file names, we can
print the file name, and then skip to the next file with <code>nextfile</code>.
Finally, each line is printed, with a leading file name and colon
if necessary:
</p>
<span id="index-_0021-_0028exclamation-point_0029-13"></span>
<span id="index-exclamation-point-_0028_0021_0029-12"></span>
<div class="example">
<pre class="example">{
    matches = ($0 ~ pattern)
    if (invert)
        matches = ! matches

    fcount += matches    # 1 or 0

    if (! matches)
        next

    if (! count_only) {
        if (no_print)
            nextfile

        if (filenames_only) {
            print FILENAME
            nextfile
        }

        if (do_filenames)
            print FILENAME &quot;:&quot; $0
        else
            print
    }
}
</pre></div>

<p>The <code>END</code> rule takes care of producing the correct exit status. If
there are no matches, the exit status is one; otherwise, it is zero:
</p>
<div class="example">
<pre class="example">END {
    exit (total == 0)
}
</pre></div>

<p>The <code>usage()</code> function prints a usage message in case of invalid options,
and then exits:
</p>
<div class="example">
<pre class="example">function usage()
{
    print(&quot;Usage: egrep [-csvil] [-e pat] [files ...]&quot;) &gt; &quot;/dev/stderr&quot;
    print(&quot;\n\tegrep [-csvil] pat [files ...]&quot;) &gt; &quot;/dev/stderr&quot;
    exit 1
}
</pre></div>


<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT76" href="#DOCF76">(76)</a></h3>
<p>It
also introduces a subtle bug;
if a match happens, we output the translated line, not the original.</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Id-Program.html" accesskey="n" rel="next">Id Program</a>, Previous: <a href="Cut-Program.html" accesskey="p" rel="prev">Cut Program</a>, Up: <a href="Clones.html" accesskey="u" rel="up">Clones</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
