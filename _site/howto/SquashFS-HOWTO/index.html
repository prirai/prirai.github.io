<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>SquashFS HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><META
NAME="KEYWORD"
CONTENT="linux"><META
NAME="KEYWORD"
CONTENT="squashfs"><META
NAME="KEYWORD"
CONTENT="squashed"><META
NAME="KEYWORD"
CONTENT="squash"><META
NAME="KEYWORD"
CONTENT="compressed"><META
NAME="KEYWORD"
CONTENT="filesystem"><META
NAME="KEYWORD"
CONTENT="kernel"><META
NAME="KEYWORD"
CONTENT="embedded"><META
NAME="KEYWORD"
CONTENT="tiny"><link rel="stylesheet" href="../bookstyle.css"></HEAD
><BODY
CLASS="article"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
></A
>SquashFS HOWTO</H1
><DIV
CLASS="authorgroup"
><A
NAME="AEN4"
></A
><H3
CLASS="author"
><A
NAME="AEN5"
>Artemiy I. Pavlov</A
></H3
><DIV
CLASS="affiliation"
><SPAN
CLASS="orgname"
><A
HREF="http://www.sinevibes.com/"
TARGET="_top"
>Sinevibes</A
><BR></SPAN
><DIV
CLASS="address"
><P
CLASS="address"
></P
></DIV
></DIV
><H3
CLASS="author"
><A
NAME="AEN13"
>Marco  Cecchetti</A
></H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
><TT
CLASS="email"
>&#60;<A
HREF="mailto:mrc (dot) ildp (dot) com"
>mrc (dot) ildp (dot) com</A
>&#62;</TT
></P
></DIV
></DIV
></DIV
><DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.9</TD
><TD
ALIGN="LEFT"
>2008-07-24</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Text corrections.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.8</TD
><TD
ALIGN="LEFT"
>2008-01-06</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Changes according to SquashFS release 3.3. Some parts added.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.7</TD
><TD
ALIGN="LEFT"
>2005-03-25</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Changes according to SquashFS release 2.1.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.6</TD
><TD
ALIGN="LEFT"
>2004-11-10</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Changes according to SquashFS release 2.0.
			Text corrections.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.5</TD
><TD
ALIGN="LEFT"
>2004-06-07</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Changes according to SquashFS release 2.0 alpha.
			Lots of description improvements and clarifications. Split 
			instructions for Linux kernels of 2.6.x (new) and 2.4.x series.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.1</TD
><TD
ALIGN="LEFT"
>2004-05-22</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Changes according to SquashFS release 1.3r3.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0</TD
><TD
ALIGN="LEFT"
>2004-02-19</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial Release, reviewed by LDP.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.2</TD
><TD
ALIGN="LEFT"
>2003-12-08</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Text corrections, license added.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.1</TD
><TD
ALIGN="LEFT"
>2003-11-24</TD
><TD
ALIGN="LEFT"
>Revised by: </TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial version. Instructions for SquashFS release 1.3r2.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="abstract"
><A
NAME="AEN30"
></A
><P
><B
>Abstract</B
></P
><P
>This HOWTO describes the usage of SquashFS - a highly-compressed 
		read-only file system for Linux, which is intended for use in tiny-sized and 
		embedded systems, and anywhere else you'd want to use a compressed file system.
		With this document, you'll learn how to prepare a SquashFS-ready
		Linux kernel, create a squashed file system and happily use it.
		</P
></DIV
></DIV
><DIV
><DIV
CLASS="abstract"
><A
NAME="AEN33"
></A
><P
><B
>Home of this HOWTO</B
></P
><P
>&#13;		The SquashFS HOWTO lives at <A
HREF="http://artemio.net/projects/linuxdoc/squashfs"
TARGET="_top"
>http://artemio.net/projects/linuxdoc/squashfs</A
>.
		There you will always find the latest version of the document, and will be able to send
		your feedback.
		</P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#whatis"
>What is SquashFS</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#intro"
>Introduction</A
></DT
><DT
>1.2. <A
HREF="#overview"
>Overview of SquashFS</A
></DT
><DT
>1.3. <A
HREF="#makingclear"
>Making it clear</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#gettingready"
>Getting ready for SquashFS</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#acquiring"
>Acquiring SquashFS</A
></DT
><DT
>2.2. <A
HREF="#preparing"
>Preparing a SquashFS-capable kernel</A
></DT
><DT
>2.3. <A
HREF="#tools"
>Compiling the SquashFS tools</A
></DT
><DT
>2.4. <A
HREF="#debian"
>Installing SquashFS on Debian</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#mksqoverview"
>The SquashFS tools exposed</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#mksqusing"
>Using mksquashfs</A
></DT
><DT
>3.2. <A
HREF="#mksqoptions"
>Command-line options</A
></DT
><DT
>3.3. <A
HREF="#unsquashing"
>Using unsquashfs</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#creatingandusing"
>Creating and using squashed file systems</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#creating"
>Basic steps</A
></DT
><DT
>4.2. <A
HREF="#squashing"
>Squashing file systems</A
></DT
><DT
>4.3. <A
HREF="#tinyemb"
>Creating tiny/embedded systems</A
></DT
><DT
>4.4. <A
HREF="#sqwrite"
>Making it writeble</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#acknowledgements"
>Acknowledgements</A
></DT
><DT
>6. <A
HREF="#license"
>License</A
></DT
></DL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="whatis"
></A
>1. What is SquashFS</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="intro"
></A
>1.1. Introduction</H2
><P
>&#13;When creating tiny-sized and embedded Linux systems, every byte of the storage device (floppy, flash disk, etc.)
is very important, so compression is used everywhere possible. Also, compressed file systems are frequently needed
for archiving purposes. For huge public archives, as well as for personal media archives, this is essential.
</P
><P
>&#13;SquashFS brings all this to a new level. It is a read-only file system that lets you compress whole file systems or
single directories, write them to other devices/partitions or to ordinary files, and then mount them directly (if
a device) or using a loopback device (if it is a file). The modular, compact system design of SquashFS is bliss.
For archiving purposes, SquashFS gives you a lot more flexibility and performance speed than a tarball archive.
</P
><P
>&#13;SquashFS is distributed as a Linux kernel source patch (which enables SquashFS read support in your kernel),
the <B
CLASS="command"
>mksquashfs</B
> tool, which creates squashed file systems (in a file or on a block device) and
the <B
CLASS="command"
>unsquashfs</B
> tool, which extracts multiple files from an existing squashed file system.
</P
><P
>&#13;The latest SquashFS release tree is 3.x, the former one was 2.x. This document
describes both these releases with proper notes given. For example, if some feature or 
parameter is different in these release trees, it will be written as follows: 
<EM
>new value (3.x) or old value (2.x)</EM
>
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="overview"
></A
>1.2. Overview of SquashFS</H2
><P
></P
><UL
><LI
><P
>Data, inodes and directories are compressed
</P
></LI
><LI
><P
>SquashFS stores full uid/gids (32 bits), and file creation time
</P
></LI
><LI
><P
>Files up to 2^64 bytes are supported; file systems can be up to 2^64 bytes
</P
></LI
><LI
><P
>Inode and directory data are highly compacted, and packed on byte
boundaries;  each compressed inode is on average 8 bytes in length
(the exact length varies on file type, i.e. regular file, directory,
symbolic link, and block/character device inodes have different sizes)
</P
></LI
><LI
><P
>SquashFS can use block sizes up to up to 64 Kb (2.x) and 1Mb (3.x). The default size is 128Kb (3.x), which achieves 
greater compression ratios than the normal 4K block size
</P
></LI
><LI
><P
>By the 2.x release it was introduced the concept of <EM
>fragment blocks</EM
>:
an ability to join multiple files smaller than block size into a single
block, achieving greater compression ratios
</P
></LI
><LI
><P
>File duplicates are detected and removed
</P
></LI
><LI
><P
>Both big and little endian architectures are supported;  SquashFS can
mount file systems created on different byte-order machines
</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="makingclear"
></A
>1.3. Making it clear</H2
><P
>&#13;Now let's make sure any further discussions will be clearer
for you to understand.
The procedure of getting SquashFS working basically  
consists of the following steps:
</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Patching and recompiling the target Linux kernel to enable SquashFS support
</P
></LI
><LI
><P
>Compiling the <B
CLASS="command"
>mksquashfs </B
> and the <B
CLASS="command"
>unsquashfs </B
> tools 
</P
></LI
><LI
><P
>Creating a compressed file system with <B
CLASS="command"
>mksquashfs</B
>
</P
></LI
><LI
><P
>Testing: mounting a squashed file system to a temporary location
</P
></LI
><LI
><P
>Modifying the <TT
CLASS="filename"
>/etc/fstab </TT
> or startup scripts of 
your target Linux system to mount the new squashed file system when needed
</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="gettingready"
></A
>2. Getting ready for SquashFS</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="acquiring"
></A
>2.1. Acquiring SquashFS</H2
><P
>&#13;The SquashFS home site is located at 
<A
HREF="http://squashfs.sourceforge.net/"
TARGET="_top"
>http://squashfs.sourceforge.net/</A
> 
- it contains news for the latest release and it's changelog, as well as general information 
about SquashFS. You can grab the latest version at the SquashFS
<A
HREF="http://sourceforge.net/project/showfiles.php?group_id=63835"
TARGET="_top"
>project page</A
>
at SourceForge.
</P
><P
>&#13;Squashfs is also avaliable with LZMA compression at
<A
HREF="http://www.squashfs-lzma.org/"
TARGET="_top"
>http://www.squashfs-lzma.org/</A
>
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="preparing"
></A
>2.2. Preparing a SquashFS-capable kernel</H2
><P
>&#13;In order to read SquashFS, you need it supported in your kernel - just as if it was a 
<TT
CLASS="filename"
>reiserfs</TT
> or <TT
CLASS="filename"
>ext3</TT
> file system. You have to make sure 
there is an appropriate patch for your kernel version. It should be located in
<TT
CLASS="filename"
>kernel-patches/linux-2.x.y</TT
> subdirectory of the SquashFS source tree. Also, remember 
that in most cases you will need a <EM
>clean</EM
> (original) Linux kernel 
source from <A
HREF="http://kernel.org/"
TARGET="_top"
>kernel.org</A
>. If your kernel source is 
from a distro vendor, it may be already pre-patched with custom vendor patches, and patching 
with a SquashFS patch will almost surely not work, as SquashFS patches are made against 
<EM
>original</EM
> Linux kernels. 
However some distributions make avaliable SquashFS-kernel-modules and SquashFS-tools packages from the repositories.
If you consider to use these packages from your distro, you don't need to patch your kernel or 
to build SquashFS tools from source. In such case, make sure to get the proper module for your kernel from the distro 
repositories. Please note that doing so you will have an easy installation step, but no control on 
kernel configuration parameters if you mind to use SquashFS for particular purposes (eg. for embedded systems).
</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="patching"
></A
>2.2.1. Patching the kernel source</H3
><P
>&#13;With a kernel source and a proper SquashFS patch present, all you have to do is 
(we'll assume that you have your Linux kernel source in <TT
CLASS="filename"
>/usr/src/linux</TT
> and 
that you have the SquashFS source in <TT
CLASS="filename"
>/usr/src/squashfs</TT
>):
</P
><P
>&#13;Change to the SquashFS source directory and
copy the kernel patch (we'll assume it's named <TT
CLASS="filename"
>squashfs-patch</TT
>) to 
<TT
CLASS="filename"
>/usr/src/linux</TT
>.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src/squashfs
	bash# cp linux-2.x.y/squashfs-patch /usr/src/linux
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Go to the linux kernel source directory <TT
CLASS="filename"
>/usr/src/linux</TT
>:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src/linux
</PRE
></FONT
></TD
></TR
></TABLE
><P
><EM
>Note:</EM
> please remember that we will not be leaving this 
directory during all further kernel-related procedures, and all paths
will be given relative to <TT
CLASS="filename"
>/usr/src/linux</TT
>.</P
><P
>Now patch the source with the SquashFS patch:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# patch -p1 &#60; squashfs-patch
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="compiling1"
></A
>2.2.2. Compiling a 2.6.x kernel</H3
><P
>Cleanup and prepare the kernel source:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make distclean
	bash# make mrproper
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Configure the kernel using your favourite method
(config/menuconfig/xconfig/gconfig):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make menuconfig
</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><OL
TYPE="1"
><LI
><P
>&#13;In the <SPAN
CLASS="QUOTE"
>"<EM
>File systems</EM
>"</SPAN
> section, 
<SPAN
CLASS="QUOTE"
>"<EM
>Miscellaneous file systems</EM
>"</SPAN
> subsection, enable 
the <SPAN
CLASS="QUOTE"
>"<EM
>Squashed filesystem</EM
>"</SPAN
> option, whether as 
module or bundled with the kernel. It is only obligatory to compile SquashFS inside 
the kernel if you plan using squashed initial RAM disks (<B
CLASS="command"
>initrd</B
>). 
</P
></LI
><LI
><P
>&#13;In the same subsection, <B
CLASS="command"
>"do NOT"</B
> enable the <SPAN
CLASS="QUOTE"
>"<EM
>Additional option for memory-constrained system</EM
>"</SPAN
>, unless
you are configuring your kernel for an embedded system.
</P
></LI
><LI
><P
>&#13;If you would like to use a squashed initial RAM disk, enable the 
<SPAN
CLASS="QUOTE"
>"<EM
>Initial RAM disk support</EM
>"</SPAN
>  in the 
<SPAN
CLASS="QUOTE"
>"<EM
>Device drivers</EM
>"</SPAN
>  section, 
<SPAN
CLASS="QUOTE"
>"<EM
>Block devices</EM
>"</SPAN
>  subsection.
</P
></LI
><LI
><P
>&#13;If you want to be able to mount the squashed file system via a <EM
>loopback device</EM
> in future, you should enable 
<SPAN
CLASS="QUOTE"
>"<EM
>Loopback device support</EM
>"</SPAN
>  in the 
<SPAN
CLASS="QUOTE"
>"<EM
>Device drivers</EM
>"</SPAN
>  section, 
<SPAN
CLASS="QUOTE"
>"<EM
>Block devices</EM
>"</SPAN
>  subsection.
</P
></LI
></OL
><P
>Now you may compile the kernel and modules:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="compiling2"
></A
>2.2.3. Compiling a 2.4.x kernel</H3
><P
>Configure the kernel:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make menuconfig
</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><OL
TYPE="1"
><LI
><P
>&#13;In the <SPAN
CLASS="QUOTE"
>"<EM
>File systems</EM
>"</SPAN
>  section, enable 
the <SPAN
CLASS="QUOTE"
>"<EM
>Squashed filesystem</EM
>"</SPAN
>  option, whether as 
module or bundled with the kernel. It is only obligatory to compile SquashFS inside 
the kernel if you plan using squashed initial RAM disks (<B
CLASS="command"
>initrd</B
>). 
</P
></LI
><LI
><P
>&#13;If you would like to use a squashed initial RAM disk, enable the 
<SPAN
CLASS="QUOTE"
>"<EM
>Initial RAM disk support</EM
>"</SPAN
>  in the <SPAN
CLASS="QUOTE"
>"<EM
>Block 
devices</EM
>"</SPAN
>  section.
</P
></LI
><LI
><P
>&#13;If you want to be able to mount the squashed file system via a <EM
>loopback 
device</EM
> in future, you should enable <SPAN
CLASS="QUOTE"
>"<EM
> Loopback device 
support </EM
>"</SPAN
> in the <SPAN
CLASS="QUOTE"
>"<EM
>Block devices </EM
>"</SPAN
>  section.
</P
></LI
></OL
><P
>Now you may compile the kernel and modules:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make dep
	bash# make bzImage
	bash# make modules
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="installkernel"
></A
>2.2.4. Installing and testing the kernel</H3
><P
>It's time to install your new SquashFS-enabled kernel.
The instructions below are for installing and booting the kernel
on the host machine. You may want to install and test it on the
target system.
</P
><P
>We assume that the kernel was compiled for a x86 
architecture, and the compressed kernel image is located in the 
<TT
CLASS="filename"
>arch/i386/boot/</TT
> subdirectory of the kernel tree. 
Now copy the kernel to the <TT
CLASS="filename"
>/boot</TT
> directory (and name it 
<TT
CLASS="filename"
>bzImage-sqsh</TT
> for convenience, if you like):</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cp arch/i386/boot/bzImage /boot/bzImage-sqsh
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Don't forget to install the kernel modules
if you have any:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make modules_install
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Modify your boot loader's configuration file to include your new kernel and install
(update) the boot loader. Now you may reboot with your new kernel. When it boots, check that 
everything went fine:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cat /proc/filesystems
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Or, if you built SquashFS support as a kernel module:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# insmod squashfs
	bash# cat /proc/filesystems
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;If you see the <TT
CLASS="computeroutput"
>squashfs</TT
> line among other file systems,
this means you have successfully enabled SquashFS in your kernel.
</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="tools"
></A
>2.3. Compiling the SquashFS tools</H2
><P
>&#13;Now you need to compile <B
CLASS="command"
>mksquashfs</B
> - the tool for creating squashed file systems and the
<B
CLASS="command"
>unsquashfs</B
> which extracts files from an existing squashed file system.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src/squashfs/squashfs-tools
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Compile and install the tools:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make
	bash# cp mksquashfs /usr/sbin
	bash# cp unsquashfs /usr/sbin
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;If everything went fine, typing <B
CLASS="command"
>mksquashfs</B
> or <B
CLASS="command"
>unsquashfs</B
> at the shell prompt should print the <SPAN
CLASS="QUOTE"
>"usage"</SPAN
> message.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="debian"
></A
>2.4. Installing SquashFS on Debian</H2
><P
>If you use Debian (or onother Linux distribution) you may want to get SquashFS module and tools from the distro repositories. With Debian you have to install the proper kernel module and the tools with the following commands:
</P
><P
>&#13;(Assuming your architecture is x86)
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# apt-get install squashfs-modules-2.6-486  squashfs-tools
</PRE
></FONT
></TD
></TR
></TABLE
><P
> Now load the squashfs module for the Linux kernel and if it was correctly loaded you should find it in the relative list
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# modprobe squashfs
	
	bash# lsmod|grep squash
	squashfs               39620  0

	
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Then you have to add the squashfs module to /etc/modules if you need it loaded at boot time.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# echo squashfs &#62;&#62; /etc/modules
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Note that at the time of writing, the Debian packages (Etch. 4.0 r2) relates to squashfs 3.1 release. Some latest options and features of 3.2 release may be not supported. Look at the next section for details.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="mksqoverview"
></A
>3. The SquashFS tools exposed</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="mksqusing"
></A
>3.1. Using mksquashfs</H2
><P
>&#13;<B
CLASS="command"
>mksquashfs</B
> is the tool for creating new squashed 
file systems, and for appending new data to existing squashed file 
systems. The general command-line format for <B
CLASS="command"
>mksquashfs</B
> is:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mksquashfs source1 source2 ... destination [options]
</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>source1</TT
>, <TT
CLASS="filename"
>source2</TT
>, etc.: files and directories to be
added to the resulting file system, given with relative and/or absolute paths 
</P
></LI
><LI
><P
><TT
CLASS="filename"
>destination</TT
>: a regular file (filesystem 
image file), or a block device (such as <TT
CLASS="filename"
>/dev/fd0</TT
> or <TT
CLASS="filename"
>/dev/hda3</TT
>)
where you want to have your squashed file system
</P
></LI
></UL
><P
>&#13;
Notes for default <B
CLASS="command"
>mksquashfs</B
> behavior:

<P
></P
><UL
><LI
><P
>&#13;When the new files are added to the new file system or appended to an existing one,
<B
CLASS="command"
>mksquashfs </B
> will automatically rename files with duplicate names:
if two or more files named <TT
CLASS="filename"
>text</TT
> will appear in the same
resulting directory, the second file will be renamed to
<TT
CLASS="filename"
>text_1</TT
>, third one to <TT
CLASS="filename"
>text_2</TT
> and so on.
</P
></LI
><LI
><P
>&#13;Duplicate files will be removed, so there will be only one physical instance
(By the SquashFS 2.x, you can disable the detection/removal of the duplicates
with the <B
CLASS="command"
>-no-duplicates </B
> option).
</P
></LI
><LI
><P
>&#13;If <EM
>destination </EM
> has a pre-existing SquashFS
file system on it, by default, the new <EM
>source</EM
> items will be appended to
the existing root directory. Examine the options table below to force <B
CLASS="command"
>mksquashfs </B
> to overwrite the whole destination
and/or change the way new source items are added. 
</P
></LI
><LI
><P
>&#13;If a single source file or directory is given, it becomes the root in a newly created file system. If two
or more source files and/or directories are given, they will all become sub-items in the root of
the new file system.
</P
></LI
><LI
><P
>&#13;The resulting filesystem will be padded to a multiple of 4 Kb: this
is required for filesystems to be used on block devices. If you are very sure
you don't ned this, use the <B
CLASS="command"
>-nopad </B
> option to disable this
operation.
</P
></LI
></UL
>

</P
><P
>&#13;See the next section for more details about all possible options.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="mksqoptions"
></A
>3.2. Command-line options</H2
><P
>&#13;All possible options for <B
CLASS="command"
>mksquashfs</B
> are shown in the table below.
</P
><DIV
CLASS="table"
><A
NAME="AEN317"
></A
><P
><B
>Table 1. Command-line options of the <B
CLASS="command"
>mksquashfs</B
> tool</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Option</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-2.0 </B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>force <B
CLASS="command"
>mksquashfs</B
> version 2.1 to create a version 2.0 
filesystem</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-all-root</B
> or <B
CLASS="command"
>-root-owned</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>make all files in the target file system owned by root (UID=0, GID=0)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-always-use-fragments</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>divide all files greater than block size into fragments (by the version 2.x).
It will result in greater compression ratios</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-b [block size]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>use [block size] filesystem block size (32 Kbytes default for 2.x, 128 kbytes for 3.x) - this can be either 4096, 8192, 16384, 32768, 65536 or 131072</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-be</B
> or <B
CLASS="command"
>-le</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>force a big or little endian file system, respectively</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-check-data</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>enable additional file system checks</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-e [file1] ( [file2] ... )</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>specify which files and/or directories to omit
from the new file system that is to be created</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-ef [file]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>specify a <TT
CLASS="filename"
>file</TT
> which contains the list of
files/directories to exclude</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-force-gid [GID]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set all group IDs in target file system to [GID]
(can be specified as a name or a number)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-force-uid [UID]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set all user IDs in target file system to [UID]
(can be specified as a name or a number)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-info</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>print files, their original size and compression ratio, as they are added to 
the file system</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-keep-as-directory</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>if the source is a single directory, force this directory to be a subdirectory 
of the root in the created file system</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-noappend</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>if the destination file/device already contains a squashed file system, 
overwrite it, rather than append the new data to an existing file system</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-no-duplicates</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>do not detect/remove duplicate file names</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-noD</B
> or <B
CLASS="command"
>-noDataCompression</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>do not compress the data</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-noF</B
> or <B
CLASS="command"
>-noFragmentCompression</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>do not compress the fragments (avaliable by 2.x)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-no-fragments</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>do not generate fragment blocks (avaliable by 2.x, this will
produce almost the same filesystem as 1.x did)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-noI</B
> or <B
CLASS="command"
>-noInodeCompression</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>do not compress the inode table</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-nopad</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>do not pad the resulting file system to a multiple of 4 KBytes</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-root-becomes [name]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>can be used while appending to a pre-existing squashed file system: it will make a new root, 
and [name] directory will contain all pre-existing files/directories
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-version</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>print the version, copyright and license message
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-recover [name]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>recover filesystem data using recovery file [name] (3.3)
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-no-recovery</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>don't create a recovery file (3.3). 
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-no-exports</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>don't make avaliable file system to export via NFS (3.x)
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-no-sparse</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>don't check for sparse files (3.x)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-processors [number]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set the number of CPU to create file system. By default it will be used all avaliable processors (3.x)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>--read-queue [size]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set input queue to [size] Mb.  (Default is 64 Mb)(3.x)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-write-queue [size]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>set output queue to [size] Mb (3.x)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-sort [sort_file]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>sort files relating to priorities in [sort_file] (3.x)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-wildcards</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>enable the extended shell wildcards to exclude directories/files (to be used with -e)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-regex</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>enable to use POSIX regular expressions (3.3)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>&#13;In most cases, you should leave all compression/block options by default, as they allow 
<B
CLASS="command"
>mksquashfs</B
> to achieve the best possible compression ratios.
</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="unsquashing"
></A
>3.3. Using unsquashfs</H2
><P
>&#13;<B
CLASS="command"
>unsquashfs</B
> is the tool for extracting data from squashed 
file systems. The general command-line format for <B
CLASS="command"
>unsquashfs</B
> is:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;unsquashfs [options] target [files/directories to extract]
</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>&#13;target is the squashed file system to extract.
</P
></LI
></UL
><P
>&#13;Notes for <B
CLASS="command"
>unsquashfs</B
> behavior:
</P
><P
></P
><UL
><LI
><P
> 
By not specifying any <EM
>destination path</EM
>, unsquashfs extracts the compressed file system in the
<EM
>./squashfs-root </EM
> directory.
</P
></LI
><LI
><P
> 
The tool does not extract a squashed file system on already exsisting directory
unless the <B
CLASS="command"
>-f</B
> option is specified.
</P
></LI
><LI
><P
>&#13;You can specify on the command line, a multiple number of files/directories to extract and the items
to be extracted can be also be given in a file with <B
CLASS="command"
>-e [file]</B
> option.
</P
></LI
></UL
><P
>&#13;All possible options for <B
CLASS="command"
>unsquashfs</B
> are shown in the table below.
</P
><DIV
CLASS="table"
><A
NAME="AEN483"
></A
><P
><B
>Table 2. Command-line options of the <B
CLASS="command"
>unsquashfs</B
> tool</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Option</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-v[ersion] </B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>print the version, licence and copyright message
</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-i[nfo]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>print the files as they are extracted from the file system</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-l[ist]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>list the squashed file system without extracting files</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-li</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>list files with theyr attributes as they are unsquashed (3.3)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-ll</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>list the squashed file system files with attributes without any extraction (3.3)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-d[estination] path</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>specify a destination path for unsquashed items</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-f[orce]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>if files exist overwrite them</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-s[tat]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>display file system's superblock informations (it can discover the file system version and the options used to compress it) (3.3)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-e[f] [extract file]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>list of directories or files to extract (entries given one per line) (3.3)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>-r[egex]</B
></TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>treat extract names as POSIX regular expressions (3.3)</TD
></TR
></TBODY
></TABLE
></DIV
><P
>&#13;Note that by 3.x release you can extract 1.x and 2.x squashed file system too.
</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="creatingandusing"
></A
>4. Creating and using squashed file systems</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="creating"
></A
>4.1. Basic steps</H2
><P
>&#13;In order to create a squashed file system out of a single directory 
(say, <TT
CLASS="filename"
>/some/dir</TT
>), and output it to a regular file 
(thus, producing a file system image), you need to say only one magic phrase:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mksquashfs /some/dir dir.sqsh
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;<B
CLASS="command"
>mksquashfs</B
> will perform the squashing and print the resulting 
number of inodes and size of data written, as well as the average compression ratio. 
Now you have your <TT
CLASS="filename"
>/some/dir</TT
> directory image in the
<TT
CLASS="filename"
>dir.sqsh</TT
> file. You can now use the <B
CLASS="command"
>mount</B
> command 
to mount it using a loopback device:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mkdir /mnt/dir
	bash# mount dir.sqsh /mnt/dir -t squashfs -o loop
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;To check if you have what's expected:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# ls /mnt/dir
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;If you want to output the file system directly into a device (say, your floppy at 
<TT
CLASS="filename"
>/dev/fd0</TT
>):
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mksquashfs /some/dir /dev/fd0
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Then just <B
CLASS="command"
>mount</B
> the device:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mount /dev/fd0 /mnt/floppy -t squashfs
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;And check if it's okay:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# ls /mnt/floppy
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="squashing"
></A
>4.2. Squashing file systems</H2
><P
>&#13;Operations described here correspond to most cases where a read-only compressed file 
system can be used, whether you want it to be on a block device or in a file. This 
could be anything from large FTP/HTTP-served archives that don't change often, to 
having a squashed <TT
CLASS="filename"
>/usr</TT
> partition and anything alike
with these. 
</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="squashing-ex1"
></A
>4.2.1. Example 1</H3
><P
>&#13;Let's suppose you have a <TT
CLASS="filename"
>/var/arch</TT
> directory with lots of files and
that you want to turn it into a squashed file system and keep it on your root partition
as a file (it will be a file system image that you will mount via a loopback device).
The operations needed to perform are as follows.
</P
><P
>&#13;Squash the directory, then mount it via loopback to test it:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mksquashfs /var/arch /var/arch.sqsh
	bash# mkdir /mnt/tmp
	bash# mount /var/arch.sqsh /mnt/tmp -t squashfs -o loop
	bash# ls /mnt/tmp
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;If everything is as expected, make this file system mount automatically at boot time by
adding this line to your <TT
CLASS="filename"
>/etc/fstab</TT
>:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	/var/arch.sqsh	/var/arch	squashfs	ro,defaults	0 0
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Unmount the file system from the temporary mount point, and mount using it's fstab entry:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# umount /mnt/tmp
	bash# mount /var/arch
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Now just ensure that everything works fine:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# ls /var/arch
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="squashing-ex2"
></A
>4.2.2. Example 2</H3
><P
>&#13;Say you have two hard disk partitions, <TT
CLASS="filename"
>/dev/hda6</TT
> (which
is empty) and <TT
CLASS="filename"
>/dev/hda7</TT
> (which is bigger than <TT
CLASS="filename"
>/dev/hda6</TT
>,
mounted at <TT
CLASS="filename"
>/var/arch</TT
>, contains some data and is full). Now, say you want to squash the <TT
CLASS="filename"
>/dev/hda7</TT
> file system and move it to <TT
CLASS="filename"
>/dev/hda6</TT
>, 
then use <TT
CLASS="filename"
>/dev/hda7</TT
> for some other purposes. We will suppose you have
the following line in <TT
CLASS="filename"
>/etc/fstab</TT
> (<B
CLASS="command"
>reiserfs</B
> is just an example file system
used on <TT
CLASS="filename"
>/dev/hda7</TT
>):
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	/dev/hda7	/var/arch	reiserfs	defaults	0 0
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;In the same fashion as with the previous example:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mksquashfs /var/arch /var/arch.sqsh
	bash# mkdir /mnt/tmp
	bash# mount /var/arch.sqsh /mnt/tmp -t squashfs -o loop
	bash# ls /mnt/tmp
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;If everything went fine, unmount <TT
CLASS="filename"
>/dev/hda7</TT
> (if needed) and 
use <B
CLASS="command"
>dd</B
> to copy <TT
CLASS="filename"
>/var/arch.sqsh</TT
>
to <TT
CLASS="filename"
>/dev/hda6</TT
>:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# umount /dev/hda7
	bash# dd if=/var/arch.sqsh of=/dev/hda6
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Now change the line in <TT
CLASS="filename"
>/etc/fstab</TT
> for <TT
CLASS="filename"
>/dev/hda7</TT
> to:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	/dev/hda6	/var/arch	squashfs	ro,defaults	0 0
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Mount the new file system and check to see if all went fine:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mount /var/arch
	bash# ls /var/arch
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Don't forget to erase the unneeded file system image:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# rm /var/arch.sqsh
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="tinyemb"
></A
>4.3. Creating tiny/embedded systems</H2
><P
>&#13;By saying "tiny/embedded", I mean Linux systems that are being built for
booting from floppy disks, IDE/USB flash disks, iso9660 CD-ROMs, small-sized hard drives and the like.
Whether you want to have your whole root file system on a single media (a single partition, a single floppy),
or have a modular system (several floppies or disk partitions), the procedure is almost identical.
Creating such Linux systems themselves is out of scope of this HOWTO - there are dedicated HOWTOs and guides
for this (like the <EM
>Bootdisk HOWTO</EM
> and <EM
>Linux From Scratch</EM
> - visit
<A
HREF="http://www.tldp.org"
TARGET="_top"
>www.tldp.org</A
> to retrieve these documents).
</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sqflash"
></A
>4.3.1. Squashed file systems on floppy/flash/hard disks</H3
><P
>&#13;In order to use SquashFS for creating Linux systems on small disks, you just have to follow
the usual steps for creating a minimal system, performing the following operations
at respective points:
</P
><P
></P
><OL
TYPE="1"
><LI
><P
>&#13;When developing a kernel for your system, make sure you enable SquashFS support
so it can mount squashed file systems
</P
></LI
><LI
><P
>&#13;Use <B
CLASS="command"
>mksquashfs</B
> for creating read-only initial ram disks and/or root and/or other file systems
</P
></LI
><LI
><P
>&#13;Don't forget to set file system types to <TT
CLASS="filename"
>squashfs</TT
> in <TT
CLASS="filename"
>/etc/fstab</TT
>
and/or the startup scripts of your system for mounting squashed file systems
</P
></LI
></OL
><P
>&#13;<EM
>Floppy example</EM
>. Let's say you have your floppy system tree at
<TT
CLASS="filename"
>/home/user/floppylinux</TT
> and you want to place the root file system on one
floppy and <TT
CLASS="filename"
>/usr</TT
> on another. What you should do is:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /home/user
	bash# mksquashfs floppylinux root.sqsh -e usr
	bash# mksquashfs floppylinux/usr usr.sqsh
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;<EM
>Note 1</EM
>: you can see here how we use the <B
CLASS="command"
>-e</B
>
option to exclude the <TT
CLASS="filename"
>/usr</TT
> directory for root file system's image.
</P
><P
>&#13;<EM
>Note 2</EM
>: don't forget to specify <TT
CLASS="filename"
>squashfs</TT
> in your root disk's
<TT
CLASS="filename"
>/etc/fstab</TT
> or startup scripts when mounting the <TT
CLASS="filename"
>/usr</TT
> file system.
</P
><P
>&#13;Insert a root disk in your 3.5" floppy drive (I assume you have a lilo or grub on it, and, thus, a file system exists on this floppy,
and the root file system will reside under the <TT
CLASS="filename"
>/boot</TT
> directory of this file system):
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mount /mnt/floppy
	bash# cp root.sqsh /mnt/floppy/boot
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;When done, unmount the root floppy, change the floppy to a <TT
CLASS="filename"
>/usr</TT
> disk and use <B
CLASS="command"
>dd</B
> to
transfer the <TT
CLASS="filename"
>usr</TT
> file system:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# dd if=usr.sqsh of=/dev/fd0
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="sqfloppy"
></A
>4.3.2. Squashed file systems on CD-ROMs</H3
><P
>&#13;With SquashFS, you can compress large file systems that
will be used in live CDs (just as an example). For this purpose SquashFS is also used with UnionFS.

</P
><P
></P
><OL
TYPE="1"
><LI
><P
>&#13;Enable SquashFS in the linux kernel of the target system
</P
></LI
><LI
><P
>&#13;Create a squashed root file system
</P
></LI
><LI
><P
>&#13;Modify the <TT
CLASS="filename"
>/etc/fstab</TT
> or startup scripts of the target system
to mount the squashd file system when you need it
</P
></LI
></OL
><P
>&#13;
If you create a root file system out of a running Linux system,
use the <B
CLASS="command"
>-e</B
> option for <B
CLASS="command"
>mksquashfs</B
> to exclude
all pseudo-filesystems such as <TT
CLASS="filename"
>/proc</TT
>, <TT
CLASS="filename"
>/sys</TT
>
(on linux kernels after 2.5.x) and <TT
CLASS="filename"
>/dev</TT
> 
(when using DevFS). Also, don't forget to add the file system image itself that is
being created with <B
CLASS="command"
>mksquashfs</B
> (I think you know the reasons
for these exclusions).

</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="sqwrite"
></A
>4.4. Making it writeble</H2
><P
>&#13;As mentioned, another interesting use for <B
CLASS="command"
>SquashFS</B
> is with <B
CLASS="command"
>Unionfs</B
> filesystem, which 
provides <EM
>copy-on-write</EM
> semantics for the read-only file systems, enahancing the possibilities. (For unionfs you can 
look at <A
HREF="http://www.filesystems.org/project-unionfs.html"
TARGET="_top"
>http://www.filesystems.org/project-unionfs.html</A
>)
</P
><P
>&#13;Just to make an example, you may want to make your /home/user squashed, to compress and backup your files without losing the possibility to apply changes or writing new files.
</P
><P
>&#13;Create the <TT
CLASS="filename"
>ro.fs</TT
> squashed file system and the <TT
CLASS="filename"
>rw.fs</TT
> dir.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# mksquashfs /home/user1 ro.fs
bash# mkdir /home/rw.fs
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Mount the squashed ro.fs file system using the loopback device 
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# mount -t squashfs ro.fs /mnt -o loop
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;mount the unionfs file system, that makes <TT
CLASS="filename"
>/mnt</TT
> and <TT
CLASS="filename"
>/home/rw.fs</TT
> apparently merged under <TT
CLASS="filename"
>/home/user1</TT
> location.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# cd /home
bash# mount -t unionfs -o dirs=rw.fs=rw:/mnt=ro unionfs user1
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;As you can see, now you can create new files in /home/user1.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# cd /home/user1
bash# touch file1
bash# ls
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;umount the unionfs and the squashfs file systems and list the content of /home/user1 and /home/rw.fs dir
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# cd ..
bash# umount /home/user1
bash# umount /mnt

bash# ls /home/user1
bash# ls /home/rw.fs 

</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;You can see that the new <TT
CLASS="filename"
>file1</TT
> was created in <TT
CLASS="filename"
>/home/rw.fs</TT
> 
</P
><P
>&#13;When you want to add the new created files to the <EM
>stable</EM
> and <EM
>compressed</EM
> squashed file system, you have to add them to the exsisting one. 
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# mksquashfs /home/rw.fs /home/ro.fs
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Now, to mount your squashed user home directory at system startup, you
can do as follow:
</P
><P
>&#13;Make squashfs and unionfs modules loaded at boot time.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# echo squashfs &#62;&#62; /etc/modules
bash# echo unionfs &#62;&#62; /etc/modules
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Change the owner of the writeble branch to match user1.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;chown user1 /home/rw.fs
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Add these lines to /etc/fstab file to mount squashfs and unionfs 
at boot time.
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;...
/home/ro.fs  /mnt squashfs loop 0 0
unionfs /home/user1 unionfs dirs=/home/rw.fs=rw:/mnt=ro 0 0
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="acknowledgements"
></A
>5. Acknowledgements</H1
><P
>&#13;I would like to express my sincere thanks and immeasurable respect to:
</P
><P
></P
><UL
><LI
><P
>&#13;Phillip Lougher - for his brilliant work under squashfs, for creating an exculsive
patch for linux-2.4.18, for his help with polishing this howto and answers to my mails
</P
></LI
><LI
><P
>&#13;Tabatha Marshall at TLDP for helping me with bringing this HOWTO to the final 1.0 release
</P
></LI
><LI
><P
>&#13;Everybody at <A
HREF="http://www.tldp.org"
TARGET="_top"
>The Linux Documentation Project</A
> for
their great work under all the HOWTOs and guides that helped me a lot with exploring and 
hacking Linux
</P
></LI
><LI
><P
>&#13;All those at the TLDP mailing lists who helped me with getting started
</P
></LI
><LI
><P
>&#13;Endless thanks and respect to everybody who develops open-source software
</P
></LI
></UL
><P
>Artemiy I. Pavlov</P
><P
>&#13;I want to thank Artemiy for his patience answering my emails, allowing me to work to this howto. I would express also my thanks and respect to everybody who is involved in free software</P
><P
>Marco Cecchetti</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="license"
></A
>6. License</H1
><P
>&#13;This document may be used and distributed under the terms and conditions set forth in 
the Open Content licence. In short, this means that you can freely modify and re-distribute 
the HOWTO under the main condition that you keep the author and copyright the article along. 
The full text of the licence is available at <A
HREF="http://www.opencontent.org/opl.shtml"
TARGET="_top"
>http://www.opencontent.org/opl.shtml</A
>
</P
></DIV
></DIV
></BODY
></HTML
>