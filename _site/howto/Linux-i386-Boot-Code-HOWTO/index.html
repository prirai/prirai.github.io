<HTML
><HEAD
><TITLE
>Linux i386 Boot Code HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><link rel="stylesheet" href="../bookstyle.css"></HEAD
><BODY
CLASS="article"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
></A
>Linux i386 Boot Code HOWTO</H1
><H3
CLASS="author"
><A
NAME="AEN4"
>Feiyun Wang</A
></H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
><TT
CLASS="email"
>&#60;<A
HREF="mailto:feiyunw@yahoo.com"
>feiyunw@yahoo.com</A
>&#62;</TT
></P
></DIV
></DIV
><P
CLASS="pubdate"
>2004-01-23<BR></P
><DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0</TD
><TD
ALIGN="LEFT"
>2004-02-19</TD
><TD
ALIGN="LEFT"
>Revised by: FW</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial release, reviewed by LDP</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.3.3</TD
><TD
ALIGN="LEFT"
>2004-01-23</TD
><TD
ALIGN="LEFT"
>Revised by: fyw</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Add decompress_kernel() details;
            Fix bugs reported in TLDP final review.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.3</TD
><TD
ALIGN="LEFT"
>2003-12-07</TD
><TD
ALIGN="LEFT"
>Revised by: fyw</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Add contents on SMP, GRUB and LILO; Fix and enhance.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.2</TD
><TD
ALIGN="LEFT"
>2003-08-17</TD
><TD
ALIGN="LEFT"
>Revised by: fyw</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Adapt to Linux 2.4.20.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.1</TD
><TD
ALIGN="LEFT"
>2003-04-20</TD
><TD
ALIGN="LEFT"
>Revised by: fyw</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Change to DocBook XML format.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="abstract"
><A
NAME="AEN37"
></A
><P
></P
><P
>&#13;         This document describes Linux i386 boot code,
         serving as a study guide and source commentary.
         In addition to C-like pseudocode source commentary, it also presents
         keynotes of toolchains and specs related to kernel development.
         It is designed to help:
         <P
></P
><UL
><LI
><P
>kernel newbies to understand Linux i386 boot code, and</P
></LI
><LI
><P
>kernel veterans to recall Linux boot procedure.</P
></LI
></UL
>
        </P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#intro"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#copyright"
>Copyright and License</A
></DT
><DT
>1.2. <A
HREF="#disclaimer"
>Disclaimer</A
></DT
><DT
>1.3. <A
HREF="#credits"
>Credits / Contributors</A
></DT
><DT
>1.4. <A
HREF="#feedback"
>Feedback</A
></DT
><DT
>1.5. <A
HREF="#translations"
>Translations</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#makefiles"
>Linux Makefiles</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#linux_makefile"
>linux/Makefile</A
></DT
><DT
>2.2. <A
HREF="#vmlinux.lds"
>linux/arch/i386/vmlinux.lds</A
></DT
><DT
>2.3. <A
HREF="#i386_makefile"
>linux/arch/i386/Makefile</A
></DT
><DT
>2.4. <A
HREF="#i386_boot_makefile"
>linux/arch/i386/boot/Makefile</A
></DT
><DT
>2.5. <A
HREF="#i386_boot_compressed_makefile"
>linux/arch/i386/boot/compressed/Makefile</A
></DT
><DT
>2.6. <A
HREF="#i386_tools_build.c"
>linux/arch/i386/tools/build.c</A
></DT
><DT
>2.7. <A
HREF="#makefile_ref"
>Reference</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#bootsect"
>linux/arch/i386/boot/bootsect.S</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#move_bootsect"
>Move Bootsect</A
></DT
><DT
>3.2. <A
HREF="#get_disk_para"
>Get Disk Parameters</A
></DT
><DT
>3.3. <A
HREF="#load_setup"
>Load Setup Code</A
></DT
><DT
>3.4. <A
HREF="#load_compressed"
>Load Compressed Image</A
></DT
><DT
>3.5. <A
HREF="#go_setup"
>Go Setup</A
></DT
><DT
>3.6. <A
HREF="#read_disk"
>Read Disk</A
></DT
><DT
>3.7. <A
HREF="#bootsect_helper"
>Bootsect Helper</A
></DT
><DT
>3.8. <A
HREF="#bootsect_misc"
>Miscellaneous</A
></DT
><DT
>3.9. <A
HREF="#bootsect_ref"
>Reference</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#setup"
>linux/arch/i386/boot/setup.S</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#setup_header"
>Header</A
></DT
><DT
>4.2. <A
HREF="#check_code"
>Check Code Integrity</A
></DT
><DT
>4.3. <A
HREF="#check_loader"
>Check Loader Type</A
></DT
><DT
>4.4. <A
HREF="#get_mem_size"
>Get Memory Size</A
></DT
><DT
>4.5. <A
HREF="#hw_support"
>Hardware Support</A
></DT
><DT
>4.6. <A
HREF="#apm_support"
>APM Support</A
></DT
><DT
>4.7. <A
HREF="#prepare_protmode"
>Prepare for Protected Mode</A
></DT
><DT
>4.8. <A
HREF="#enable_a20"
>Enable A20</A
></DT
><DT
>4.9. <A
HREF="#switch_protmode"
>Switch to Protected Mode</A
></DT
><DT
>4.10. <A
HREF="#setup_misc"
>Miscellaneous</A
></DT
><DT
>4.11. <A
HREF="#setup_ref"
>Reference</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#compressed_head"
>linux/arch/i386/boot/compressed/head.S</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#decompress_kernel"
>Decompress Kernel</A
></DT
><DT
>5.2. <A
HREF="#gunzip"
>gunzip()</A
></DT
><DT
>5.3. <A
HREF="#inflate"
>inflate()</A
></DT
><DT
>5.4. <A
HREF="#chead_ref"
>Reference</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#kernel_head"
>linux/arch/i386/kernel/head.S</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#enable_paging"
>Enable Paging</A
></DT
><DT
>6.2. <A
HREF="#get_kernel_para"
>Get Kernel Parameters</A
></DT
><DT
>6.3. <A
HREF="#check_cpu_type"
>Check CPU Type</A
></DT
><DT
>6.4. <A
HREF="#go_start_kernel"
>Go Start Kernel</A
></DT
><DT
>6.5. <A
HREF="#khead_misc"
>Miscellaneous</A
></DT
><DT
>6.6. <A
HREF="#khead_ref"
>Reference</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#init_main"
>linux/init/main.c</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#start_kernel"
>start_kernel()</A
></DT
><DT
>7.2. <A
HREF="#init_proc"
>init()</A
></DT
><DT
>7.3. <A
HREF="#idle_proc"
>cpu_idle()</A
></DT
><DT
>7.4. <A
HREF="#main_ref"
>Reference</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#smpboot"
>SMP Boot</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#before_smpinit"
>Before smp_init()</A
></DT
><DT
>8.2. <A
HREF="#smp_init"
>smp_init()</A
></DT
><DT
>8.3. <A
HREF="#trampoline"
>linux/arch/i386/kernel/trampoline.S</A
></DT
><DT
>8.4. <A
HREF="#initialize_secondary"
>initialize_secondary()</A
></DT
><DT
>8.5. <A
HREF="#start_secondary"
>start_secondary()</A
></DT
><DT
>8.6. <A
HREF="#smpboot_ref"
>Reference</A
></DT
></DL
></DD
><DT
>A. <A
HREF="#kbuild"
>Kernel Build Example</A
></DT
><DT
>B. <A
HREF="#internel_lds"
>Internal Linker Script</A
></DT
><DT
>C. <A
HREF="#bootloader"
>GRUB and LILO</A
></DT
><DD
><DL
><DT
>C.1. <A
HREF="#grub"
>GNU GRUB</A
></DT
><DT
>C.2. <A
HREF="#lilo"
>LILO</A
></DT
><DT
>C.3. <A
HREF="#bootloader_ref"
>Reference</A
></DT
></DL
></DD
><DT
>D. <A
HREF="#faq"
>FAQ</A
></DT
></DL
></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="intro"
></A
>1. Introduction</H1
><P
>&#13;   This document serves as a study guide and source commentary for
   Linux i386 boot code.
   In addition to C-like pseudocode source commentary, it also presents
   keynotes of toolchains and specs related to kernel development.
   It is designed to help:
   <P
></P
><UL
><LI
><P
>kernel newbies to understand Linux i386 boot code, and</P
></LI
><LI
><P
>kernel veterans to recall Linux boot procedure.</P
></LI
></UL
>
  </P
><P
>&#13;   Current release is based on Linux 2.4.20.
  </P
><P
>&#13;   The project homepage for this document is hosted by
<A
HREF="http://sf.linuxforum.net/projects/i386bc"
TARGET="_top"
>China Linux Forum</A
>.
   Working documents may also be found at the author's personal webpage at
<A
HREF="http://www.geocities.com/feiyunw/linux/"
TARGET="_top"
>Yahoo! GeoCities</A
>.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="copyright"
></A
>1.1. Copyright and License</H2
><P
>&#13;     This document, <EM
>Linux i386 Boot Code HOWTO</EM
>,
     is copyrighted (c) 2003, 2004 by <EM
>Feiyun Wang</EM
>.
     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation
     License, Version 1.2 or any later version published
     by the Free Software Foundation; with no Invariant Sections,
     with no Front-Cover Texts, and with no Back-Cover Texts.
     A copy of the license is available at
     <A
HREF="http://www.gnu.org/copyleft/fdl.html"
TARGET="_top"
>&#13;     http://www.gnu.org/copyleft/fdl.html</A
>.
    </P
><P
>&#13;     Linux is a registered trademark of Linus Torvalds.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="disclaimer"
></A
>1.2. Disclaimer</H2
><P
>&#13;     No liability for the contents of this document can be accepted.
     Use the concepts, examples and information at your own risk.
     There may be errors and inaccuracies which could be damaging to
     your system.  Proceed with caution, and although this is highly
     unlikely, the author(s) do not take any responsibility.
    </P
><P
>&#13;     Owners hold all copyrights,
     unless specifically noted otherwise.  Use of a term in this
     document should not be regarded as affecting the validity of any
     trademark or service mark.  Naming of particular products or
     brands should not be seen as endorsements.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="credits"
></A
>1.3. Credits / Contributors</H2
><P
>&#13;     In this document, I have the pleasure of acknowledging:
    
    <P
></P
><UL
><LI
><P
>Jennifer Riley <TT
CLASS="email"
>&#60;<A
HREF="mailto:kevten@NOSPAM.email.com"
>kevten@NOSPAM.email.com</A
>&#62;</TT
></P
></LI
><LI
><P
>Tabatha Marshall <TT
CLASS="email"
>&#60;<A
HREF="mailto:tabatha@NOSPAM.merlinmonroe.com"
>tabatha@NOSPAM.merlinmonroe.com</A
>&#62;</TT
></P
></LI
><LI
><P
>Randy Dunlap <TT
CLASS="email"
>&#60;<A
HREF="mailto:rddunlap@NOSPAM.ieee.org"
>rddunlap@NOSPAM.ieee.org</A
>&#62;</TT
></P
></LI
></UL
>
     Names will remain on this list for a year.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="feedback"
></A
>1.4. Feedback</H2
><P
>&#13;     Feedback is most certainly welcome for this document. Send
     your additions, comments and criticisms to the following
     email address:
     <P
></P
><UL
><LI
><P
>Feiyun Wang <TT
CLASS="email"
>&#60;<A
HREF="mailto:feiyunw@yahoo.com"
>feiyunw@yahoo.com</A
>&#62;</TT
></P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="translations"
></A
>1.5. Translations</H2
><P
>&#13;     English is the only version available now.
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="makefiles"
></A
>2. Linux Makefiles</H1
><P
>&#13;   Before perusing Linux code, we should get some basic idea about
   how Linux is composed, compiled and linked.
   A straightforward way to achieve this goal is to understand Linux makefiles.
   Check <A
HREF="http://lxr.linux.no/source?v=2.4.20"
TARGET="_top"
>&#13;   Cross-Referencing Linux</A
> if you prefer online source browsing.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="linux_makefile"
></A
>2.1. linux/Makefile</H2
><P
>&#13;     Here are some well-known targets in this top-level makefile:
     <P
></P
><UL
><LI
><P
>&#13;          <EM
>xconfig, menuconfig, config, oldconfig</EM
>:
          generate kernel configuration file
          <TT
CLASS="filename"
>linux/.config</TT
>;
         </P
></LI
><LI
><P
>&#13;          <EM
>depend, dep</EM
>: generate dependency files, like
          <TT
CLASS="filename"
>linux/.depend</TT
>,
          <TT
CLASS="filename"
>linux/.hdepend</TT
> and
          <TT
CLASS="filename"
>.depend</TT
> in subdirectories;
         </P
></LI
><LI
><P
>&#13;          <EM
>vmlinux</EM
>: generate resident kernel image
          <TT
CLASS="filename"
>linux/vmlinux</TT
>, the most important target;
         </P
></LI
><LI
><P
>&#13;          <EM
>modules, modules_install</EM
>:
          generate and install modules in
          <TT
CLASS="filename"
>/lib/modules/$(KERNELRELEASE)</TT
>;
         </P
></LI
><LI
><P
>&#13;          <EM
>tags</EM
>: generate tag file
          <TT
CLASS="filename"
>linux/tags</TT
>, for source browsing with
          <A
HREF="http://vim.sourceforge.net"
TARGET="_top"
>vim</A
>.
         </P
></LI
></UL
>
    </P
><P
>&#13;     Overview of <TT
CLASS="filename"
>linux/Makefile</TT
> is outlined below:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>include .depend
include .config
include arch/i386/Makefile

vmlinux: generate linux/vmlinux
        /* entry point "stext" defined in arch/i386/kernel/head.S */
        $(LD) -T $(TOPDIR)/arch/i386/vmlinux.lds -e stext
        /* $(HEAD) */
        + from arch/i386/Makefile
                arch/i386/kernel/head.o
                arch/i386/kernel/init_task.o
        init/main.o
        init/version.o
        init/do_mounts.o
        --start-group
        /* $(CORE_FILES) */
        + from arch/i386/Makefile
                arch/i386/kernel/kernel.o
                arch/i386/mm/mm.o
        kernel/kernel.o
        mm/mm.o
        fs/fs.o
        ipc/ipc.o
        /* $(DRIVERS) */
        drivers/...
                char/char.o
                block/block.o
                misc/misc.o
                net/net.o
                media/media.o
                cdrom/driver.o
                and other static linked drivers
                + from arch/i386/Makefile
                        arch/i386/math-emu/math.o (ifdef CONFIG_MATH_EMULATION)
        /* $(NETWORKS) */
        net/network.o
        /* $(LIBS) */
        + from arch/i386/Makefile
                arch/i386/lib/lib.a
        lib/lib.a
        --end-group
        -o vmlinux
        $(NM) vmlinux | grep ... | sort &#62; System.map
tags: generate linux/tags for vim
modules: generate modules
modules_install: install modules
clean mrproper distclean: clean up build directory
psdocs pdfdocs htmldocs mandocs: generate kernel documents

include Rules.make

rpm: generate an rpm</PRE
></FONT
></TD
></TR
></TABLE
>
     "--start-group" and "--end-group" are <B
CLASS="command"
>ld</B
>
     command line options to resolve symbol reference problem. Refer to
<A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_2.html#SEC3"
TARGET="_top"
>&#13;     Using LD, the GNU linker: Command Line Options</A
> for details.
    </P
><P
>&#13;     <TT
CLASS="filename"
>Rules.make</TT
> contains rules which are shared
     between multiple Makefiles.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="vmlinux.lds"
></A
>2.2. linux/arch/i386/vmlinux.lds</H2
><P
>&#13;     After compilation, <B
CLASS="command"
>ld</B
> combines a number of
     object and archive files, relocates their data and
     ties up symbol references.
     <TT
CLASS="filename"
>linux/arch/i386/vmlinux.lds</TT
> is designated by
     <TT
CLASS="filename"
>linux/Makefile</TT
> as the linker script used
     in linking the resident kernel image <TT
CLASS="filename"
>linux/vmlinux</TT
>.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/* ld script to make i386 Linux kernel
 * Written by Martin Mares &#60;mj@atrey.karlin.mff.cuni.cz&#62;;
 */
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
/* "ENTRY" is overridden by command line option "-e stext" in linux/Makefile */
ENTRY(_start)
/* Output file (linux/vmlinux) layout.
 * Refer to <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC17"
TARGET="_top"
>Using LD, the GNU linker: Specifying Output Sections</A
> */
SECTIONS
{
/* Output section .text starts at address 3G+1M.
 * Refer to <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC10"
TARGET="_top"
>Using LD, the GNU linker: The Location Counter</A
> */
  . = 0xC0000000 + 0x100000;
  _text = .;                    /* Text and read-only data */
  .text : {
        *(.text)
        *(.fixup)
        *(.gnu.warning)
        } = 0x9090
/* Unallocated holes filled with 0x9090, i.e. opcode for "NOP NOP".
 * Refer to <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC21"
TARGET="_top"
>Using LD, the GNU linker: Optional Section Attributes</A
> */

  _etext = .;                   /* End of text section */

  .rodata : { *(.rodata) *(.rodata.*) }
  .kstrtab : { *(.kstrtab) }

/* Aligned to next 16-bytes boundary.
 * Refer to <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC14"
TARGET="_top"
>Using LD, the GNU linker: Arithmetic Functions</A
> */
  . = ALIGN(16);                /* Exception table */
  __start___ex_table = .;
  __ex_table : { *(__ex_table) }
  __stop___ex_table = .;

  __start___ksymtab = .;        /* Kernel symbol table */
  __ksymtab : { *(__ksymtab) }
  __stop___ksymtab = .;

  .data : {                     /* Data */
        *(.data)
        CONSTRUCTORS
        }
/* For "CONSTRUCTORS", refer to
 * <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC26"
TARGET="_top"
>Using LD, the GNU linker: Option Commands</A
> */

  _edata = .;                   /* End of data section */

  . = ALIGN(8192);              /* init_task */
  .data.init_task : { *(.data.init_task) }

  . = ALIGN(4096);              /* Init code and data */
  __init_begin = .;
  .text.init : { *(.text.init) }
  .data.init : { *(.data.init) }
  . = ALIGN(16);
  __setup_start = .;
  .setup.init : { *(.setup.init) }
  __setup_end = .;
  __initcall_start = .;
  .initcall.init : { *(.initcall.init) }
  __initcall_end = .;
  . = ALIGN(4096);
  __init_end = .;

  . = ALIGN(4096);
  .data.page_aligned : { *(.data.idt) }

  . = ALIGN(32);
  .data.cacheline_aligned : { *(.data.cacheline_aligned) }

  __bss_start = .;              /* BSS */
  .bss : {
        *(.bss)
        }
  _end = . ;

/* Output section /DISCARD/ will not be included in the final link output.
 * Refer to <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC18"
TARGET="_top"
>Using LD, the GNU linker: Section Definitions</A
> */
  /* Sections to be discarded */
  /DISCARD/ : {
        *(.text.exit)
        *(.data.exit)
        *(.exitcall.exit)
        }

/* The following output sections are addressed at memory location 0.
 * Refer to <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC21"
TARGET="_top"
>Using LD, the GNU linker: Optional Section Attributes</A
> */
  /* Stabs debugging sections.  */
  .stab 0 : { *(.stab) }
  .stabstr 0 : { *(.stabstr) }
  .stab.excl 0 : { *(.stab.excl) }
  .stab.exclstr 0 : { *(.stab.exclstr) }
  .stab.index 0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment 0 : { *(.comment) }
}</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="i386_makefile"
></A
>2.3. linux/arch/i386/Makefile</H2
><P
>&#13;     <TT
CLASS="filename"
>linux/arch/i386/Makefile</TT
> is included by
     <TT
CLASS="filename"
>linux/Makefile</TT
> to provide i386 specific
     items and terms.
    </P
><P
>&#13;     All the following targets depend on target <EM
>vmlinux</EM
>
     of <TT
CLASS="filename"
>linux/Makefile</TT
>.
     They are accomplished by making corresponding targets in
     <TT
CLASS="filename"
>linux/arch/i386/boot/Makefile</TT
> with some options.
    <DIV
CLASS="table"
><A
NAME="AEN153"
></A
><P
><B
>Table 1. Targets in linux/arch/i386/Makefile</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Target</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>zImage
              <A
NAME="AEN163"
HREF="#FTN.AEN163"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
            </TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>@$(MAKE) -C arch/i386/boot zImage</B
>
              
              <A
NAME="AEN169"
HREF="#FTN.AEN169"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bzImage</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>@$(MAKE) -C arch/i386/boot bzImage</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>zlilo</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>@$(MAKE) -C arch/i386/boot BOOTIMAGE=zImage zlilo</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bzlilo</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>@$(MAKE) -C arch/i386/boot BOOTIMAGE=bzImage zlilo</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>zdisk</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>@$(MAKE) -C arch/i386/boot BOOTIMAGE=zImage zdisk</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bzdisk</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>@$(MAKE) -C arch/i386/boot BOOTIMAGE=bzImage zdisk</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>install</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>@$(MAKE) -C arch/i386/boot BOOTIMAGE=bzImage install</B
>
            </TD
></TR
></TBODY
><TR
><TD
COLSPAN="2"
>Notes:<BR><A
NAME="FTN.AEN163"
>a. </A
>
                 <EM
>zImage</EM
> alias:
                 <EM
>compressed</EM
>;
                <BR><A
NAME="FTN.AEN169"
>b. </A
>
                 "-C" is a MAKE command line option
                 to change directory before reading makefiles;
                <BR>Refer to
<A
HREF="http://www.gnu.org/software/make/manual/html_chapter/make_9.html#SEC102"
TARGET="_top"
>&#13;                 GNU make: Summary of Options</A
> and
<A
HREF="http://www.gnu.org/software/make/manual/html_chapter/make_5.html#SEC58"
TARGET="_top"
>&#13;                 GNU make: Recursive Use of make</A
>.
                <BR></TD
></TR
></TABLE
></DIV
>
    </P
><P
>&#13;     It is worth noticing that this makefile redefines
     some environment variables which are exported by
     <TT
CLASS="filename"
>linux/Makefile</TT
>, specifically:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>OBJCOPY=$(CROSS_COMPILE)objcopy -O binary -R .note -R .comment -S</PRE
></FONT
></TD
></TR
></TABLE
>
     The effect will be passed to subdirectory makefiles and
     will change the tool's behavior. Refer to
<A
HREF="http://www.gnu.org/software/binutils/manual/html_chapter/binutils_3.html"
TARGET="_top"
>&#13;     GNU Binary Utilities: objcopy</A
>
     for <B
CLASS="command"
>objcopy</B
> command line option details.
    </P
><P
>&#13;     Not sure why <EM
>$(LIBS)</EM
> includes
     "$(TOPDIR)/arch/i386/lib/lib.a" twice:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>LIBS := $(TOPDIR)/arch/i386/lib/lib.a $(LIBS) $(TOPDIR)/arch/i386/lib/lib.a</PRE
></FONT
></TD
></TR
></TABLE
>
     It may be employed to work around linking problems with some toolchains.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="i386_boot_makefile"
></A
>2.4. linux/arch/i386/boot/Makefile</H2
><P
>&#13;     <TT
CLASS="filename"
>linux/arch/i386/boot/Makefile</TT
> is somehow
     independent as it is not included by either
     <TT
CLASS="filename"
>linux/arch/i386/Makefile</TT
>
     or <TT
CLASS="filename"
>linux/Makefile</TT
>.
    </P
><P
>&#13;     However, they do have some relationship:
     <P
></P
><UL
><LI
><P
>&#13;          <TT
CLASS="filename"
>linux/Makefile</TT
>: provides resident kernel image
          <TT
CLASS="filename"
>linux/vmlinux</TT
>;
         </P
></LI
><LI
><P
>&#13;          <TT
CLASS="filename"
>linux/arch/i386/boot/Makefile</TT
>:
          provides bootstrap;
         </P
></LI
><LI
><P
>&#13;          <TT
CLASS="filename"
>linux/arch/i386/Makefile</TT
>:
          makes sure <TT
CLASS="filename"
>linux/vmlinux</TT
> is ready
          before the bootstrap is constructed,
          and exports targets (like <EM
>bzImage</EM
>)
          to <TT
CLASS="filename"
>linux/Makefile</TT
>.
         </P
></LI
></UL
>
    </P
><P
>&#13;      $(BOOTIMAGE) value, which is for target <EM
>zdisk, zlilo</EM
>
      or <EM
>zdisk</EM
>, comes from
      <TT
CLASS="filename"
>linux/arch/i386/Makefile</TT
>.
    </P
><P
>&#13;    <DIV
CLASS="table"
><A
NAME="AEN232"
></A
><P
><B
>Table 2. Targets in linux/arch/i386/boot/Makefile</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Target</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>zImage</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>$(OBJCOPY) compressed/vmlinux compressed/vmlinux.out
tools/build bootsect setup compressed/vmlinux.out $(ROOT_DEV) &#62; zImage</PRE
></FONT
></TD
></TR
></TABLE
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bzImage</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>$(OBJCOPY) compressed/bvmlinux compressed/bvmlinux.out
tools/build -b bbootsect bsetup compressed/bvmlinux.out $(ROOT_DEV) \
        &#62; bzImage</PRE
></FONT
></TD
></TR
></TABLE
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>zdisk</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>dd bs=8192 if=$(BOOTIMAGE) of=/dev/fd0</PRE
></FONT
></TD
></TR
></TABLE
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>zlilo</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>if [ -f $(INSTALL_PATH)/vmlinuz ]; then mv $(INSTALL_PATH)/vmlinuz
        $(INSTALL_PATH)/vmlinuz.old; fi
if [ -f $(INSTALL_PATH)/System.map ]; then mv $(INSTALL_PATH)/System.map
        $(INSTALL_PATH)/System.old; fi
cat $(BOOTIMAGE) &#62; $(INSTALL_PATH)/vmlinuz
cp $(TOPDIR)/System.map $(INSTALL_PATH)/
if [ -x /sbin/lilo ]; then /sbin/lilo; else /etc/lilo/install; fi</PRE
></FONT
></TD
></TR
></TABLE
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>install</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>sh -x ./install.sh $(KERNELRELEASE) $(BOOTIMAGE) $(TOPDIR)/System.map
        "$(INSTALL_PATH)"</PRE
></FONT
></TD
></TR
></TABLE
>
            </TD
></TR
></TBODY
></TABLE
></DIV
>
     <B
CLASS="command"
>tools/build</B
> builds boot image
     <EM
>zImage</EM
> from
     {bootsect, setup, compressed/vmlinux.out}, or
     <EM
>bzImage</EM
> from
     {bbootsect, bsetup, compressed/bvmlinux,out}.
     <TT
CLASS="filename"
>linux/Makefile</TT
> "export ROOT_DEV = CURRENT".
     Note that $(OBJCOPY) has been redefined by
     <TT
CLASS="filename"
>linux/arch/i386/Makefile</TT
>
     in <A
HREF="#i386_makefile"
>Section 2.3</A
>.
    </P
><P
>&#13;    <DIV
CLASS="table"
><A
NAME="AEN267"
></A
><P
><B
>Table 3. Supporting targets in linux/arch/i386/boot/Makefile</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Target: Prerequisites</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>compressed/vmlinux: linux/vmlinux</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>@$(MAKE) -C compressed vmlinux</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>compressed/bvmlinux: linux/vmlinux</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>@$(MAKE) -C compressed bvmlinux</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>tools/build: tools/build.c</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(HOSTCC) $(HOSTCFLAGS) -o $@ $&#60; -I$(TOPDIR)/include</B
>
              <A
NAME="AEN287"
HREF="#FTN.AEN287"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bootsect: bootsect.o</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;              <B
CLASS="command"
>$(LD) -Ttext 0x0 -s --oformat binary bootsect.o</B
>
              <A
NAME="AEN294"
HREF="#FTN.AEN294"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bootsect.o: bootsect.s</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>$(AS) -o $@ $&#60;</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bootsect.s: bootsect.S ...</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(CPP) $(CPPFLAGS) -traditional $(SVGA_MODE) $(RAMDISK) $&#60; -o $@</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bbootsect: bbootsect.o</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(LD) -Ttext 0x0 -s --oformat binary $&#60; -o $@</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bbootsect.o: bbootsect.s</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>$(AS) -o $@ $&#60;</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bbootsect.s: bootsect.S ...</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(CPP) $(CPPFLAGS) -D__BIG_KERNEL__ -traditional $(SVGA_MODE) $(RAMDISK) $&#60; -o $@</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>setup: setup.o</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(LD) -Ttext 0x0 -s --oformat binary -e begtext -o $@ $&#60;</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>setup.o: setup.s</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>$(AS) -o $@ $&#60;</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>setup.s: setup.S video.S ...</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(CPP) $(CPPFLAGS) -D__ASSEMBLY__ -traditional $(SVGA_MODE) $(RAMDISK) $&#60; -o $@</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bsetup: bsetup.o</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(LD) -Ttext 0x0 -s --oformat binary -e begtext -o $@ $&#60;</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bsetup.o: bsetup.s</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
CLASS="command"
>$(AS) -o $@ $&#60;</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bsetup.s: setup.S video.S ...</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(CPP) $(CPPFLAGS) -D__BIG_KERNEL__ -D__ASSEMBLY__ -traditional $(SVGA_MODE) $(RAMDISK) $&#60; -o $@</B
>
            </TD
></TR
></TBODY
><TR
><TD
COLSPAN="2"
>Notes:<BR><A
NAME="FTN.AEN287"
>a. </A
>
                "$@" means target, "$&#60;" means first prerequisite; Refer to
<A
HREF="http://www.gnu.org/software/make/manual/html_chapter/make_10.html#SEC111"
TARGET="_top"
>&#13;                GNU make: Automatic Variables</A
>;
              <BR><A
NAME="FTN.AEN294"
>b. </A
>
                 "--oformat binary" asks for raw binary output,
                 which is identical to the memory dump of the executable;
                 Refer to <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_2.html#SEC3"
TARGET="_top"
>Using LD, the GNU linker: Command Line Options</A
>.
                <BR></TD
></TR
></TABLE
></DIV
>
     Note that it has "-D__BIG_KERNEL__" when compile
     <TT
CLASS="filename"
>bootsect.S</TT
> to <TT
CLASS="filename"
>bbootsect.s</TT
>, and
     <TT
CLASS="filename"
>setup.S</TT
> to <TT
CLASS="filename"
>bsetup.s</TT
>.
     They must be Place Independent Code (PIC), thus what "-Ttext" option is
     doesn't matter.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="i386_boot_compressed_makefile"
></A
>2.5. linux/arch/i386/boot/compressed/Makefile</H2
><P
>&#13;     This makefile handles image (de)compression mechanism.
    </P
><P
>&#13;     It is good to separate (de)compression from bootstrap.
     This divide-and-conquer solution allows us to easily improve
     (de)compression mechanism or to adopt a new bootstrap method.
    </P
><P
>&#13;     Directory
     <TT
CLASS="filename"
>linux/arch/i386/boot/compressed/</TT
>
     contains two source files:
     <TT
CLASS="filename"
>head.S</TT
> and <TT
CLASS="filename"
>misc.c</TT
>.
    </P
><P
>&#13;    <DIV
CLASS="table"
><A
NAME="AEN354"
></A
><P
><B
>Table 4. Targets in linux/arch/i386/boot/compressed/Makefile</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Target</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Command</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>vmlinux<A
NAME="AEN364"
HREF="#FTN.AEN364"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
            </TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(LD) -Ttext 0x1000 -e startup_32 -o vmlinux head.o misc.o piggy.o</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>bvmlinux</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(LD) -Ttext 0x100000 -e startup_32 -o bvmlinux head.o misc.o piggy.o</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>head.o</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<B
CLASS="command"
>$(CC) $(AFLAGS) -traditional -c head.S</B
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>misc.o</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>$(CC) $(CFLAGS) -DKBUILD_BASENAME=$(subst $(comma),_,$(subst -,_,$(*F)))
        -c misc.c<A
NAME="AEN382"
HREF="#FTN.AEN382"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
></PRE
></FONT
></TD
></TR
></TABLE
>
            </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>piggy.o</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>tmppiggy=_tmp_$$$$piggy; \
rm -f $$tmppiggy $$tmppiggy.gz $$tmppiggy.lnk; \
$(OBJCOPY) $(SYSTEM) $$tmppiggy; \
gzip -f -9 &#60; $$tmppiggy &#62; $$tmppiggy.gz; \
echo "SECTIONS { .data : { input_len = .; \
        LONG(input_data_end - input_data) input_data = .; \
        *(.data) input_data_end = .; }}" &#62; $$tmppiggy.lnk; \
$(LD) -r -o piggy.o -b binary $$tmppiggy.gz -b elf32-i386 \
        -T $$tmppiggy.lnk; \
rm -f $$tmppiggy $$tmppiggy.gz $$tmppiggy.lnk</PRE
></FONT
></TD
></TR
></TABLE
></TD
></TR
></TBODY
><TR
><TD
COLSPAN="2"
>Notes:<BR><A
NAME="FTN.AEN364"
>a. </A
>
              Target <EM
>vmlinux</EM
> here is different from
              that defined in <TT
CLASS="filename"
>linux/Makefile</TT
>;
              <BR><A
NAME="FTN.AEN382"
>b. </A
>"subst" is a MAKE function; Refer to
<A
HREF="http://www.gnu.org/software/make/manual/html_chapter/make_8.html#SEC85"
TARGET="_top"
>GNU make: Functions for String Substitution and Analysis</A
>.
              <BR></TD
></TR
></TABLE
></DIV
>
    </P
><P
>&#13;     <TT
CLASS="filename"
>piggy.o</TT
> contains
     variable <EM
>input_len</EM
>
     and gzipped <TT
CLASS="filename"
>linux/vmlinux</TT
>.
     <EM
>input_len</EM
> is at the beginning of
     <TT
CLASS="filename"
>piggy.o</TT
>, and it is equal to the size of
     <TT
CLASS="filename"
>piggy.o</TT
> excluding
     <EM
>input_len</EM
> itself. Refer to
<A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_3.html#SEC20"
TARGET="_top"
>&#13;     Using LD, the GNU linker: Section Data Expressions</A
>
     for "LONG(expression)" in <EM
>piggy.o</EM
> linker script.
    </P
><P
>&#13;     To be exact, it is not <TT
CLASS="filename"
>linux/vmlinux</TT
> itself
     (in ELF format) that is gzipped but its binary image,
     which is generated by <B
CLASS="command"
>objcopy</B
> command.
     Note that $(OBJCOPY) has been redefined by
     <TT
CLASS="filename"
>linux/arch/i386/Makefile</TT
> in
     <A
HREF="#i386_makefile"
>Section 2.3</A
> to output raw binary
     using "-O binary" option.
    </P
><P
>&#13;     When linking {<EM
>bootsect, setup</EM
>} or
     {<EM
>bbootsect, bsetup</EM
>}, $(LD) specifies
     "--oformat binary" option to output them in binary format.
     When making <EM
>zImage</EM
> (or <EM
>bzImage</EM
>),
     $(OBJCOPY) generates an intermediate binary output from
     <EM
>compressed/vmlinux</EM
>
     (or <EM
>compressed/bvmlinux</EM
>) too.
     It is vital that all components in <EM
>zImage</EM
> or
     <EM
>bzImage</EM
> are in raw binary format,
     so that the image can run by itself without asking a loader
     to load and relocate it.
    </P
><P
>&#13;     Both <EM
>vmlinux</EM
> and <EM
>bvmlinux</EM
>
     prepend <TT
CLASS="filename"
>head.o</TT
> and <TT
CLASS="filename"
>misc.o</TT
>
     before <TT
CLASS="filename"
>piggy.o</TT
>,
     but they are linked against different start addresses (0x1000 vs 0x100000).
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="i386_tools_build.c"
></A
>2.6. linux/arch/i386/tools/build.c</H2
><P
>&#13;     <TT
CLASS="filename"
>linux/arch/i386/tools/build.c</TT
> is a host utility to
     generate <EM
>zImage</EM
> or <EM
>bzImage</EM
>.
    </P
><P
>&#13;     In <TT
CLASS="filename"
>linux/arch/i386/boot/Makefile</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>tools/build bootsect setup compressed/vmlinux.out $(ROOT_DEV) &#62; zImage

tools/build -b bbootsect bsetup compressed/bvmlinux.out $(ROOT_DEV) &#62; bzImage</PRE
></FONT
></TD
></TR
></TABLE
>
     "-b" means is_big_kernel, used to check whether system image is too big.
    </P
><P
>&#13;     <B
CLASS="command"
>tools/build</B
> outputs the following components
     to stdout, which is redirected to <EM
>zImage</EM
>
     or <EM
>bzImage</EM
>:
     <P
></P
><OL
TYPE="1"
><LI
><P
>bootsect or bbootsect: from
          <TT
CLASS="filename"
>linux/arch/i386/boot/bootsect.S</TT
>, 512 bytes;
         </P
></LI
><LI
><P
>setup or bsetup: from
          <TT
CLASS="filename"
>linux/arch/i386/boot/setup.S</TT
>,
          4 sectors or more, sector aligned;
         </P
></LI
><LI
><P
>compressed/vmlinux.out or compressed/bvmlinux.out, including:
          <P
></P
><OL
TYPE="a"
><LI
><P
>head.o: from
               <TT
CLASS="filename"
>linux/arch/i386/boot/compressed/head.S</TT
>;
              </P
></LI
><LI
><P
>misc.o: from
               <TT
CLASS="filename"
>linux/arch/i386/boot/compressed/misc.c</TT
>;
              </P
></LI
><LI
><P
>piggy.o: from <EM
>input_len</EM
>
               and gzipped <TT
CLASS="filename"
>linux/vmlinux</TT
>.</P
></LI
></OL
>
         </P
></LI
></OL
>
    </P
><P
>&#13;     <B
CLASS="command"
>tools/build</B
> will change some contents
     of <EM
>bootsect</EM
> or <EM
>bbootsect</EM
>
     when outputting to stdout:
     <DIV
CLASS="table"
><A
NAME="AEN456"
></A
><P
><B
>Table 5. Modification made by tools/build</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Offset</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Byte</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Variable</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Comment</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1F1 (497)</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>setup_sectors</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>number of setup sectors, &#62;=4</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1F4 (500)</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>2</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>sys_size</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>system size in 16-bytes, little-endian</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1FC (508)</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>minor_root</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>root dev minor</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1FD (509)</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>major_root</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>root dev major</TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><P
>&#13;     In the following chapters, compressed/vmlinux will be referred as
     <EM
>vmlinux</EM
> and compressed/bvmlinux as
     <EM
>bvmlinux</EM
>, if not confusing.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="makefile_ref"
></A
>2.7. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
>Linux Kernel Makefiles:
        <TT
CLASS="filename"
>linux/Documentation/kbuild/makefiles.txt</TT
></P
></LI
><LI
><P
><A
HREF="http://tldp.org/HOWTO/Kernel-HOWTO/"
TARGET="_top"
>&#13;        The Linux Kernel HOWTO</A
></P
></LI
><LI
><P
><A
HREF="http://www.gnu.org/software/make/manual/"
TARGET="_top"
>&#13;        GNU make</A
></P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/"
TARGET="_top"
>&#13;         Using LD, the GNU linker</A
>
        </P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.gnu.org/software/binutils/manual/"
TARGET="_top"
>&#13;         GNU Binary Utilities</A
>
        </P
></LI
><LI
><P
><A
HREF="http://www.gnu.org/software/bash/manual/"
TARGET="_top"
>&#13;        GNU Bash</A
></P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="bootsect"
></A
>3. linux/arch/i386/boot/bootsect.S</H1
><P
>&#13;   Given that we are booting up <EM
>bzImage</EM
>, which is
   composed of <EM
>bbootsect</EM
>, <EM
>bsetup</EM
>
   and <EM
>bvmlinux (head.o, misc.o, piggy.o)</EM
>,
   the first floppy sector, <EM
>bbootsect</EM
> (512 bytes),
   which is compiled from <TT
CLASS="filename"
>linux/arch/i386/boot/bootsect.S</TT
>,
   is loaded by BIOS to 07C0:0.
   The reset of <EM
>bzImage</EM
> (<EM
>bsetup</EM
>
   and <EM
>bvmlinux</EM
>) has not been loaded yet.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="move_bootsect"
></A
>3.1. Move Bootsect</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>SETUPSECTS      = 4                     /* default nr of setup-sectors */
BOOTSEG         = 0x07C0                /* original address of boot-sector */
INITSEG         = DEF_INITSEG  (0x9000) /* we move boot here - out of the way */
SETUPSEG        = DEF_SETUPSEG (0x9020) /* setup starts here */
SYSSEG          = DEF_SYSSEG   (0x1000) /* system loaded at 0x10000 (65536) */
SYSSIZE         = DEF_SYSSIZE  (0x7F00) /* system size: # of 16-byte clicks */
                                        /* to be loaded */
ROOT_DEV        = 0                     /* ROOT_DEV is now written by "build" */
SWAP_DEV        = 0                     /* SWAP_DEV is now written by "build" */

.code16
.text

///////////////////////////////////////////////////////////////////////////////
_start:
{
        // move ourself from 0x7C00 to 0x90000 and jump there.
        move BOOTSEG:0 to INITSEG:0 (512 bytes);
        goto INITSEG:go;
}</PRE
></FONT
></TD
></TR
></TABLE
>
     <EM
>bbootsect</EM
> has been moved to INITSEG:0 (0x9000:0).
     Now we can forget BOOTSEG.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="get_disk_para"
></A
>3.2. Get Disk Parameters</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// prepare stack and disk parameter table
go:
{
        SS:SP = INITSEG:3FF4;   // put stack at INITSEG:0x4000-12
        /* 0x4000 is an arbitrary value &#62;=
         *   length of bootsect + length of setup + room for stack;
         * 12 is disk parm size. */
        copy disk parameter (pointer in 0:0078) to INITSEG:3FF4 (12 bytes);
        // <A
HREF="http://www.ctyme.com/intr/rb-2445.htm"
TARGET="_top"
>int1E: SYSTEM DATA - DISKETTE PARAMETERS</A
>
        patch sector count to 36 (offset 4 in parameter table, 1 byte);
        set disk parameter table pointer (0:0078, int1E) to INITSEG:3FF4;
}</PRE
></FONT
></TD
></TR
></TABLE
>
     Make sure SP is initialized immediately after SS register.
     The recommended method of modifying SS is to use "lss" instruction
     according to
<A
HREF="http://developer.intel.com/design/pentium4/manuals/"
TARGET="_top"
>&#13;     IA-32 Intel Architecture Software Developer's Manual</A
>
     (Vol.3. Ch.5.8.3. Masking Exceptions and Interrupts When Switching Stacks).
    </P
><P
>&#13;     Stack operations, such as push and pop, will be OK now.
     First 12 bytes of disk parameter have been copied to INITSEG:3FF4.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// get disk drive parameters, specifically number of sectors/track.
        char disksizes[] = {36, 18, 15, 9};
        int sectors;
{
        SI = disksizes;                         // i = 0;
        do {
probe_loop:
                sectors = DS:[SI++];            // sectors = disksizes[i++];
                if (SI&#62;=disksizes+4) break;     // if (i&#62;=4) break;
                int13/AH=02h(AL=1, ES:BX=INITSEG:0200, CX=sectors, DX=0);
                // <A
HREF="http://www.ctyme.com/intr/rb-0607.htm"
TARGET="_top"
>int13/AH=02h: DISK - READ SECTOR(S) INTO MEMORY</A
>
        } while (failed to read sectors);
}</PRE
></FONT
></TD
></TR
></TABLE
>
     "lodsb" loads a byte from DS:[SI] to AL and increases SI automatically.
    </P
><P
>&#13;     The number of sectors per track has been saved in variable
     <EM
>sectors</EM
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="load_setup"
></A
>3.3. Load Setup Code</H2
><P
>&#13;     <EM
>bsetup</EM
> (<EM
>setup_sects</EM
> sectors)
     will be loaded right after <EM
>bbootsect</EM
>, i.e. SETUPSEG:0.
     Note that INITSEG:0200==SETUPSEG:0 and
     <EM
>setup_sects</EM
> has been changed
     by <B
CLASS="command"
>tools/build</B
> to match
     <EM
>bsetup</EM
> size
     in <A
HREF="#i386_tools_build.c"
>Section 2.6</A
>.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
got_sectors:
        word sread;             // sectors read for current track
        char setup_sects;       // overwritten by tools/build
{
        print out "Loading";
        /* <A
HREF="http://www.ctyme.com/intr/rb-0088.htm"
TARGET="_top"
>int10/AH=03h(BH=0): VIDEO - GET CURSOR POSITION AND SIZE</A
>
         * <A
HREF="http://www.ctyme.com/intr/rb-0210.htm"
TARGET="_top"
>int10/AH=13h(AL=1, BH=0, BL=7, CX=9, DH=DL=0, ES:BP=INITSEG:$msg1):</A
>
         *   <A
HREF="http://www.ctyme.com/intr/rb-0210.htm"
TARGET="_top"
>VIDEO - WRITE STRING</A
> */

        // load setup-sectors directly after the moved bootblock (at 0x90200).
        SI = &#38;sread;            // using SI to index sread, head and track
        sread = 1;              // the boot sector has already been read

        int13/AH=00h(DL=0);     // <A
HREF="http://www.ctyme.com/intr/rb-0605.htm"
TARGET="_top"
>reset FDC</A
>

        BX = 0x0200;            // read bsetup right after bbootsect (512 bytes)
        do {
next_step:
                /* to prevent cylinder crossing reading,
                 *   calculate how many sectors to read this time */
                uint16 pushw_ax = AX = MIN(sectors-sread, setup_sects);
no_cyl_crossing:
                read_track(AL, ES:BX);          // AX is not modified
                // set ES:BX, sread, head and track for next read_track()
                set_next(AX);
                setup_sects -= pushw_ax;        // rest - for next step
        } while (setup_sects);
}</PRE
></FONT
></TD
></TR
></TABLE
>
     SI is set to the address of <EM
>sread</EM
> to index
     variables <EM
>sread</EM
>, <EM
>head</EM
> and
     <EM
>track</EM
>, as they are contiguous in memory.
     Check <A
HREF="#read_disk"
>Section 3.6</A
> for read_track() and set_next() details.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="load_compressed"
></A
>3.4. Load Compressed Image</H2
><P
>&#13;     <EM
>bvmlinux (head.o, misc.o, piggy.o)</EM
> will be loaded
     at 0x100000, <EM
>syssize</EM
>*16 bytes.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// load vmlinux/bvmlinux (head.o, misc.o, piggy.o)
{
        read_it(ES=SYSSEG);
        kill_motor();                           // turn off floppy drive motor
        print_nl();                             // print CR LF
}</PRE
></FONT
></TD
></TR
></TABLE
>
     Check <A
HREF="#read_disk"
>Section 3.6</A
> for read_it() details.
     If we are booting up <EM
>zImage</EM
>,
     <EM
>vmlinux</EM
> is loaded at 0x10000 (SYSSEG:0).
    </P
><P
>&#13;     <EM
>bzImage (bbootsect, bsetup, bvmlinux)</EM
> is
     in the memory as a whole now.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="go_setup"
></A
>3.5. Go Setup</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// check which root-device to use and jump to setup.S
        int root_dev;                           // overwritten by tools/build
{
        if (!root_dev) {
                switch (sectors) {
                case 15: root_dev = 0x0208;     // /dev/ps0 - 1.2Mb
                        break;
                case 18: root_dev = 0x021C;     // /dev/PS0 - 1.44Mb
                        break;
                case 36: root_dev = 0x0220;     // /dev/fd0H2880 - 2.88Mb
                        break;
                default: root_dev = 0x0200;     // /dev/fd0 - auto detect
                        break;
                }
        }

        // jump to the setup-routine loaded directly after the bootblock
        goto SETUPSEG:0;
}</PRE
></FONT
></TD
></TR
></TABLE
>
     It passes control to <EM
>bsetup</EM
>.
     See <EM
>linux/arch/i386/boot/setup.S:start</EM
> in
     <A
HREF="#setup"
>Section 4</A
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="read_disk"
></A
>3.6. Read Disk</H2
><P
>&#13;     The following functions are used to load <EM
>bsetup</EM
>
     and <EM
>bvmlinux</EM
> from disk.
     Note that <EM
>syssize</EM
> has been changed
     by <B
CLASS="command"
>tools/build</B
> in
     <A
HREF="#i386_tools_build.c"
>Section 2.6</A
> too.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>sread:  .word 0                         # sectors read of current track
head:   .word 0                         # current head
track:  .word 0                         # current track
///////////////////////////////////////////////////////////////////////////////
// load the system image at address SYSSEG:0
read_it(ES=SYSSEG)
        int syssize;                    /* system size in 16-bytes,
                                         *   overwritten by tools/build */
{
        if (ES &#38; 0x0fff) die;           // not 64KB aligned

        BX = 0;
        for (;;) {
rp_read:
#ifdef __BIG_KERNEL__
                bootsect_helper(ES:BX);
                /* INITSEG:0220==SETUPSEG:0020 is bootsect_kludge,
                 *   which contains pointer SETUPSEG:bootsect_helper().
                 * This function initializes some data structures
                 *   when it is called for the first time,
                 *   and moves SYSSEG:0 to 0x100000, 64KB each time,
                 *   in the following calls.
                 * See <A
HREF="#bootsect_helper"
>Section 3.7</A
>. */
#else
                AX = ES - SYSSEG + ( BX &#62;&#62; 4);  // how many 16-bytes read
#endif
                if (AX &#62; syssize) return;       // everything loaded
ok1_read:
                /* Get proper AL (sectors to read) for this time
                 *   to prevent cylinder crossing reading and BX overflow. */
                AX = sectors - sread;
                CX = BX + (AX &#60;&#60; 9);            // 1 sector = 2^9 bytes
                if (CX overflow &#38;&#38; CX!=0) {     // &#62; 64KB
                        AX = (-BX) &#62;&#62; 9;
                }
ok2_read:
                read_track(AL, ES:BX);
                set_next(AX);
        }
}

///////////////////////////////////////////////////////////////////////////////
// read disk with parameters (sread, track, head)
read_track(AL sectors, ES:BX destination)
{
        for (;;) {
                printf(".");
                // <A
HREF="http://www.ctyme.com/intr/rb-0106.htm"
TARGET="_top"
>int10/AH=0Eh: VIDEO - TELETYPE OUTPUT</A
>

                // set CX, DX according to (sread, track, head)
                DX = track;
                CX = sread + 1;
                CH = DL;

                DX = head;
                DH = DL;
                DX &#38;= 0x0100;

                int13/AH=02h(AL, ES:BX, CX, DX);
                // <A
HREF="http://www.ctyme.com/intr/rb-0607.htm"
TARGET="_top"
>int13/AH=02h: DISK - READ SECTOR(S) INTO MEMORY</A
>
                if (read disk success) return;
                // "addw $8, %sp" is to cancel previous 4 "pushw" operations.
bad_rt:
                print_all();            // print error code, AX, BX, CX and DX
                int13/AH=00h(DL=0);     // <A
HREF="http://www.ctyme.com/intr/rb-0605.htm"
TARGET="_top"
>reset FDC</A
>
        }
}

///////////////////////////////////////////////////////////////////////////////
// set ES:BX, sread, head and track for next read_track()
set_next(AX sectors_read)
{
        CX = AX;                        // sectors read
        AX += sread;
        if (AX==sectors) {
                head = 1 ^ head;        // flap head between 0 and 1
                if (head==0) track++;
ok4_set:
                AX = 0;
        }
ok3_set:
        sread = AX;
        BX += CX &#38;&#38; 9;
        if (BX overflow) {              // &#62; 64KB
                ES += 0x1000;
                BX = 0;
        }
set_next_fn:
}</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="bootsect_helper"
></A
>3.7. Bootsect Helper</H2
><P
>&#13;     <EM
>setup.S:bootsect_helper()</EM
> is only used by
     <EM
>bootsect.S:read_it()</EM
>.
    </P
><P
>&#13;     Because <EM
>bbootsect</EM
> and <EM
>bsetup</EM
>
     are linked separately, they use offsets relative to
     their own code/data segments.
     We have to "call far" (lcall) for <EM
>bootsect_helper()</EM
>
     in different segment, and it must "return far" (lret) then.
     This results in CS change in calling, which makes CS!=DS, and
     we have to use segment modifier to specify variables in
     <TT
CLASS="filename"
>setup.S</TT
>.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// called by bootsect loader when loading bzImage
bootsect_helper(ES:BX)
        bootsect_es = 0;                // defined in setup.S
        type_of_loader = 0;             // defined in setup.S
{
        if (!bootsect_es) {             // called for the first time
                type_of_loader = 0x20;  // bootsect-loader, version 0
                AX = ES &#62;&#62; 4;
                *(byte*)(&#38;bootsect_src_base+2) = AH;
                bootsect_es = ES;
                AX = ES - SYSSEG;
                return;
        }
bootsect_second:
        if (!BX) {                      // 64KB full
                // move from SYSSEG:0 to destination, 64KB each time
                int15/AH=87h(CX=0x8000, ES:SI=CS:bootsect_gdt);
                // <A
HREF="http://www.ctyme.com/intr/rb-1527.htm"
TARGET="_top"
>int15/AH=87h: SYSTEM - COPY EXTENDED MEMORY</A
>
                if (failed to copy) {
                        bootsect_panic() {
                                prtstr("INT15 refuses to access high mem, "
                                        "giving up.");
bootsect_panic_loop:            goto bootsect_panic_loop;   // never return
                        }
                }
                ES = bootsect_es;       // reset ES to always point to 0x10000
                *(byte*)(&#38;bootsect_dst_base+2)++;
        }
bootsect_ex:
        // have the number of moved frames (16-bytes) in AX
        AH = *(byte*)(&#38;bootsect_dst_base+2) &#60;&#60; 4;
        AL = 0;
}

///////////////////////////////////////////////////////////////////////////////
// data used by bootsect_helper()
bootsect_gdt:
        .word   0, 0, 0, 0
        .word   0, 0, 0, 0

bootsect_src:
        .word   0xffff

bootsect_src_base:
        .byte   0x00, 0x00, 0x01                # base = 0x010000
        .byte   0x93                            # typbyte
        .word   0                               # limit16,base24 =0

bootsect_dst:
        .word   0xffff

bootsect_dst_base:
        .byte   0x00, 0x00, 0x10                # base = 0x100000
        .byte   0x93                            # typbyte
        .word   0                               # limit16,base24 =0
        .word   0, 0, 0, 0                      # BIOS CS
        .word   0, 0, 0, 0                      # BIOS DS

bootsect_es:
        .word   0

bootsect_panic_mess:
        .string "INT15 refuses to access high mem, giving up."</PRE
></FONT
></TD
></TR
></TABLE
>
     Note that <EM
>type_of_loader</EM
> value is changed.
     It will be referenced in <A
HREF="#check_loader"
>Section 4.3</A
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="bootsect_misc"
></A
>3.8. Miscellaneous</H2
><P
>&#13;     The rest are supporting functions, variables
     and part of "real-mode kernel header".
     Note that data is in .text segment as code, thus it can be
     properly initialized when loaded.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// some small functions
print_all();  /* print error code, AX, BX, CX and DX */
print_nl();   /* print CR LF */
print_hex();  /* print the word pointed to by SS:BP in hexadecimal */
kill_motor()  /* turn off floppy drive motor */
{
#if 1
        int13/AH=00h(DL=0);     // <A
HREF="http://www.ctyme.com/intr/rb-0605.htm"
TARGET="_top"
>reset FDC</A
>
#else
        outb(0, 0x3F2);         // outb(val, port)
#endif
}

///////////////////////////////////////////////////////////////////////////////
sectors:        .word 0
disksizes:      .byte 36, 18, 15, 9
msg1:           .byte 13, 10
                .ascii "Loading"</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     Bootsect trailer, which is a part of "real-mode kernel header",
     begins at offset 497.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>.org 497
setup_sects:    .byte SETUPSECS         // overwritten by tools/build
root_flags:     .word ROOT_RDONLY
syssize:        .word SYSSIZE           // overwritten by tools/build
swap_dev:       .word SWAP_DEV
ram_size:       .word RAMDISK
vid_mode:       .word SVGA_MODE
root_dev:       .word ROOT_DEV          // overwritten by tools/build
boot_flag:      .word 0xAA55</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     This "header" must conform to the layout pattern in
     <TT
CLASS="filename"
>linux/Documentation/i386/boot.txt</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Offset  Proto   Name            Meaning
/Size
01F1/1  ALL     setup_sects     The size of the setup in sectors
01F2/2  ALL     root_flags      If set, the root is mounted readonly
01F4/2  ALL     syssize         DO NOT USE - for bootsect.S use only
01F6/2  ALL     swap_dev        DO NOT USE - obsolete
01F8/2  ALL     ram_size        DO NOT USE - for bootsect.S use only
01FA/2  ALL     vid_mode        Video mode control
01FC/2  ALL     root_dev        Default root device number
01FE/2  ALL     boot_flag       0xAA55 magic number</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="bootsect_ref"
></A
>3.9. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
>THE LINUX/I386 BOOT PROTOCOL:
        <TT
CLASS="filename"
>linux/Documentation/i386/boot.txt</TT
></P
></LI
><LI
><P
><A
HREF="http://developer.intel.com/design/pentium4/manuals/"
TARGET="_top"
>&#13;        IA-32 Intel Architecture Software Developer's Manual</A
></P
></LI
><LI
><P
><A
HREF="http://www.cs.cmu.edu/~ralf/files.html"
TARGET="_top"
>&#13;        Ralf Brown's Interrupt List</A
></P
></LI
></UL
>
    As &#60;IA-32 Intel Architecture Software Developer's Manual&#62;
    is widely referenced in this document, I will call it "IA-32 Manual"
    for short.
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="setup"
></A
>4. linux/arch/i386/boot/setup.S</H1
><P
>&#13;   <TT
CLASS="filename"
>setup.S</TT
> is responsible for getting the system data
   from the BIOS and putting them into appropriate places in system memory.
  </P
><P
>&#13;   Other boot loaders, like
   <A
HREF="http://www.gnu.org/software/grub"
TARGET="_top"
>GNU GRUB</A
> and
   <A
HREF="http://freshmeat.net/projects/lilo"
TARGET="_top"
>LILO</A
>,
   can load <EM
>bzImage</EM
> too.
   Such boot loaders should load <EM
>bzImage</EM
> into memory
   and setup "real-mode kernel header",
   esp. <EM
>type_of_loader</EM
>, then pass control
   to <EM
>bsetup</EM
> directly.
   <TT
CLASS="filename"
>setup.S</TT
> assumes:
   <P
></P
><UL
><LI
><P
>&#13;        <EM
>bsetup</EM
> or <EM
>setup</EM
> may not be
        loaded at SETUPSEG:0, i.e. CS may not be equal to SETUPSEG
        when control is passed to <TT
CLASS="filename"
>setup.S</TT
>;
       </P
></LI
><LI
><P
>&#13;        The first 4 sectors of <EM
>setup</EM
>
        are loaded right after <EM
>bootsect</EM
>.
        The reset may be loaded at SYSSEG:0, preceding
        <EM
>vmlinux</EM
>;
        This assumption does not apply to <EM
>bsetup</EM
>.
       </P
></LI
></UL
>
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="setup_header"
></A
>4.1. Header</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/* Signature words to ensure LILO loaded us right */
#define SIG1    0xAA55
#define SIG2    0x5A5A

INITSEG  = DEF_INITSEG          # 0x9000, we move boot here, out of the way
SYSSEG   = DEF_SYSSEG           # 0x1000, system loaded at 0x10000 (65536).
SETUPSEG = DEF_SETUPSEG         # 0x9020, this is the current segment
                                # ... and the former contents of CS

DELTA_INITSEG = SETUPSEG - INITSEG      # 0x0020

.code16
.text

///////////////////////////////////////////////////////////////////////////////
start:
{
        goto trampoline();              // skip the following header
}

# This is the setup header, and it must start at %cs:2 (old 0x9020:2)
                .ascii  "HdrS"          # header signature
                .word   0x0203          # header version number (&#62;= 0x0105)
                                        # or else old loadlin-1.5 will fail)
realmode_swtch: .word   0, 0            # default_switch, SETUPSEG
start_sys_seg:  .word   SYSSEG
                .word   kernel_version  # pointing to kernel version string
                                        # above section of header is compatible
                                        # with loadlin-1.5 (header v1.5). Don't
                                        # change it.
// kernel_version defined below
type_of_loader: .byte   0               # = 0, old one (LILO, Loadlin,
                                        #      Bootlin, SYSLX, bootsect...)
                                        # See Documentation/i386/boot.txt for
                                        # assigned ids
# flags, unused bits must be zero (RFU) bit within loadflags
loadflags:
LOADED_HIGH     = 1                     # If set, the kernel is loaded high
CAN_USE_HEAP    = 0x80                  # If set, the loader also has set
                                        # heap_end_ptr to tell how much
                                        # space behind setup.S can be used for
                                        # heap purposes.
                                        # Only the loader knows what is free
#ifndef __BIG_KERNEL__
                .byte   0
#else
                .byte   LOADED_HIGH
#endif
setup_move_size: .word  0x8000          # size to move, when setup is not
                                        # loaded at 0x90000. We will move setup
                                        # to 0x90000 then just before jumping
                                        # into the kernel. However, only the
                                        # loader knows how much data behind
                                        # us also needs to be loaded.
code32_start:                           # here loaders can put a different
                                        # start address for 32-bit code.
#ifndef __BIG_KERNEL__
                .long   0x1000          #   0x1000 = default for zImage
#else
                .long   0x100000        # 0x100000 = default for big kernel
#endif
ramdisk_image:  .long   0               # address of loaded ramdisk image
                                        # Here the loader puts the 32-bit
                                        # address where it loaded the image.
                                        # This only will be read by the kernel.
ramdisk_size:   .long   0               # its size in bytes
bootsect_kludge:
                .word  bootsect_helper, SETUPSEG
heap_end_ptr:   .word   modelist+1024   # (Header version 0x0201 or later)
                                        # space from here (exclusive) down to
                                        # end of setup code can be used by setup
                                        # for local heap purposes.
// modelist is at the end of .text section
pad1:           .word   0
cmd_line_ptr:   .long 0                 # (Header version 0x0202 or later)
                                        # If nonzero, a 32-bit pointer
                                        # to the kernel command line.
                                        # The command line should be
                                        # located between the start of
                                        # setup and the end of low
                                        # memory (0xa0000), or it may
                                        # get overwritten before it
                                        # gets read.  If this field is
                                        # used, there is no longer
                                        # anything magical about the
                                        # 0x90000 segment; the setup
                                        # can be located anywhere in
                                        # low memory 0x10000 or higher.
ramdisk_max:    .long __MAXMEM-1        # (Header version 0x0203 or later)
                                        # The highest safe address for
                                        # the contents of an initrd</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     The <EM
>__MAXMEM</EM
> definition in
     <TT
CLASS="filename"
>linux/asm-i386/page.h</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/*
 * A __PAGE_OFFSET of 0xC0000000 means that the kernel has
 * a virtual address space of one gigabyte, which limits the
 * amount of physical memory you can use to about 950MB.
 */
#define __PAGE_OFFSET           (0xC0000000)

/*
 * This much address space is reserved for vmalloc() and iomap()
 * as well as fixmap mappings.
 */
#define __VMALLOC_RESERVE       (128 &#60;&#60; 20)

#define __MAXMEM                (-__PAGE_OFFSET-__VMALLOC_RESERVE)</PRE
></FONT
></TD
></TR
></TABLE
>
     It gives <EM
>__MAXMEM</EM
> = 1G - 128M.
    </P
><P
>&#13;     The setup header must follow some layout pattern.
     Refer to <TT
CLASS="filename"
>linux/Documentation/i386/boot.txt</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Offset  Proto   Name            Meaning
/Size
0200/2  2.00+   jump            Jump instruction
0202/4  2.00+   header          Magic signature "HdrS"
0206/2  2.00+   version         Boot protocol version supported
0208/4  2.00+   realmode_swtch  Boot loader hook
020C/2  2.00+   start_sys       The load-low segment (0x1000) (obsolete)
020E/2  2.00+   kernel_version  Pointer to kernel version string
0210/1  2.00+   type_of_loader  Boot loader identifier
0211/1  2.00+   loadflags       Boot protocol option flags
0212/2  2.00+   setup_move_size Move to high memory size (used with hooks)
0214/4  2.00+   code32_start    Boot loader hook
0218/4  2.00+   ramdisk_image   initrd load address (set by boot loader)
021C/4  2.00+   ramdisk_size    initrd size (set by boot loader)
0220/4  2.00+   bootsect_kludge DO NOT USE - for bootsect.S use only
0224/2  2.01+   heap_end_ptr    Free memory after setup end
0226/2  N/A     pad1            Unused
0228/4  2.02+   cmd_line_ptr    32-bit pointer to the kernel command line
022C/4  2.03+   initrd_addr_max Highest legal initrd address</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="check_code"
></A
>4.2. Check Code Integrity</H2
><P
>&#13;     As <EM
>setup</EM
> code may not be contiguous, we should
     check code integrity first.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
trampoline()
{
        start_of_setup();       // never return
        .space 1024;
}

///////////////////////////////////////////////////////////////////////////////
// check signature to see if all code loaded
start_of_setup()
{
        // Bootlin depends on this being done early, check <A
HREF="http://ftp.us.xemacs.org/ftp/pub/linux/suse/suse/i386/7.3/dosutils/bootlin/technic.doc"
TARGET="_top"
>bootlin:technic.doc</A
>
        int13/AH=15h(AL=0, DL=0x81);
        // <A
HREF="http://www.ctyme.com/intr/rb-0639.htm"
TARGET="_top"
>int13/AH=15h: DISK - GET DISK TYPE</A
>

#ifdef SAFE_RESET_DISK_CONTROLLER
        int13/AH=0(AL=0, DL=0x80);
        // <A
HREF="http://www.ctyme.com/intr/rb-0605.htm"
TARGET="_top"
>int13/AH=00h: DISK - RESET DISK SYSTEM</A
>
#endif

        DS = CS;
        // check signature at end of setup
        if (setup_sig1!=SIG1 || setup_sig2!=SIG2) {
                goto bad_sig;
        }
        goto goodsig1;
}

///////////////////////////////////////////////////////////////////////////////
// some small functions
prtstr();  /* print asciiz string at DS:SI */
prtsp2();  /* print double space */
prtspc();  /* print single space */
prtchr();  /* print ascii in AL */
beep();    /* print CTRL-G, i.e. beep */</PRE
></FONT
></TD
></TR
></TABLE
>
     Signature is checked to verify code integrity.
    </P
><P
>&#13;     If signature is not found, the rest <EM
>setup</EM
> code
     may precede <EM
>vmlinux</EM
> at SYSSEG:0.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>no_sig_mess: .string "No setup signature found ..."

goodsig1:
        goto goodsig;                           // make near jump

///////////////////////////////////////////////////////////////////////////////
// move the rest setup code from SYSSEG:0 to CS:0800
bad_sig()
        DELTA_INITSEG = 0x0020 (= SETUPSEG - INITSEG)
        SYSSEG = 0x1000
        word start_sys_seg = SYSSEG;            // defined in setup header
{
        DS = CS - DELTA_INITSEG;                // aka INITSEG
        BX = (byte)(DS:[497]);                  // i.e. setup_sects

        // first 4 sectors already loaded
        CX = (BX - 4) &#60;&#60; 8;                     // rest code in word (2-bytes)
        start_sys_seg = (CX &#62;&#62; 3) + SYSSEG;     // real system code start
        move SYSSEG:0 to CS:0800 (CX*2 bytes);

        if (setup_sig1!=SIG1 || setup_sig2!=SIG2) {
no_sig:
                prtstr("No setup signature found ...");
no_sig_loop:
                hlt;
                goto no_sig_loop;
        }
}</PRE
></FONT
></TD
></TR
></TABLE
>
     "hlt" instruction stops instruction execution and places the processor
     in halt state.
     The processor generates a special bus cycle to indicate that
     halt mode has been entered.
     When an enabled interrupt (including NMI) is issued,
     the processor will resume execution after the "hlt" instruction,
     and the instruction pointer (CS:EIP), pointing to the instruction
     following the "hlt", will be saved to stack
     before the interrupt handler is called.
     Thus we need a "jmp" instruction after the "hlt" to put the processor
     back to halt state again.
    </P
><P
>&#13;     The <EM
>setup</EM
> code has been moved to correct place.
     Variable <EM
>start_sys_seg</EM
> points to
     where real system code starts.
     If "bad_sig" does not happen, <EM
>start_sys_seg</EM
>
     remains SYSSEG.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="check_loader"
></A
>4.3. Check Loader Type</H2
><P
>&#13;     Check if the loader is compatible with the image.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
good_sig()
        char loadflags;                 // in setup header
        char type_of_loader;            // in setup header
        LOADHIGH = 1
{
        DS = CS - DELTA_INITSEG;        // aka INITSEG
        if ( (loadflags &#38; LOADHIGH) &#38;&#38; !type_of_loader ) {
                // Nope, old loader tries to load big-kernel
                prtstr("Wrong loader, giving up...");
                goto no_sig_loop;       // defined above in bad_sig()
        }
}

loader_panic_mess: .string "Wrong loader, giving up..."</PRE
></FONT
></TD
></TR
></TABLE
>
     Note that <EM
>type_of_loader</EM
> has been changed to 0x20 by
     <EM
>bootsect_helper()</EM
> when it loads
     <EM
>bvmlinux</EM
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="get_mem_size"
></A
>4.4. Get Memory Size</H2
><P
>&#13;     Try three different memory detection schemes
     to get the extended memory size (above 1M) in KB.
    </P
><P
>&#13;     First, try e820h, which lets us assemble a memory map;
     then try e801h, which returns a 32-bit memory size;
     and finally 88h, which returns 0-64M.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// get memory size
loader_ok()
        E820NR  = 0x1E8
        E820MAP = 0x2D0
{
        // when entering this function, DS = CS-DELTA_INITSEG, aka INITSEG
        (long)DS:[0x1E0] = 0;

#ifndef STANDARD_MEMORY_BIOS_CALL
        (byte)DS:[0x1E8] = 0;                   // E820NR

        /* method E820H: see <A
HREF="http://www.acpi.info"
TARGET="_top"
>ACPI spec</A
>
         * the memory map from hell.  e820h returns memory classified into
         * a whole bunch of different types, and allows memory holes and
         * everything.  We scan through this memory map and build a list
         * of the first 32 memory areas, which we return at [E820MAP]. */
meme820:
        EBX = 0;
        DI = 0x02D0;                            // E820MAP
        do {
jmpe820:
                int15/EAX=E820h(EDX='SMAP', EBX, ECX=20, ES:DI=DS:DI);
                // <A
HREF="http://www.ctyme.com/intr/rb-1741.htm"
TARGET="_top"
>int15/AX=E820h: GET SYSTEM MEMORY MAP</A
>
                if (failed || 'SMAP'!=EAX) break;
                // if (1!=DS:[DI+16]) continue; // not usable
good820:
                if (DS:[1E8]&#62;=32) break;        // entry# &#62; E820MAX
                DS:[0x1E8]++;                   // entry# ++;
                DI += 20;                       // adjust buffer for next
again820:
        } while (!EBX)                          // not finished
bail820:

        /* method E801H:
         * memory size is in 1k chunksizes, to avoid confusing loadlin.
         * we store the 0xe801 memory size in a completely different place,
         * because it will most likely be longer than 16 bits.
         * (use 1e0 because that's what Larry Augustine uses in his
         * alternative new memory detection scheme, and it's sensible
         * to write everything into the same place.) */
meme801:
        stc;            // to work around buggy BIOSes
        CX = DX = 0;
        int15/AX=E801h;
        /* <A
HREF="http://www.ctyme.com/intr/rb-1739.htm"
TARGET="_top"
>int15/AX=E801h: GET MEMORY SIZE FOR &#62;64M CONFIGURATIONS</A
>
         *   AX = extended memory between 1M and 16M, in K (max 3C00 = 15MB)
         *   BX = extended memory above 16M, in 64K blocks
         *   CX = configured memory 1M to 16M, in K
         *   DX = configured memory above 16M, in 64K blocks */
        if (failed) goto mem88;
        if (!CX &#38;&#38; !DX) {
                CX = AX;
                DX = BX;
        }
e801usecxdx:
        (long)DS:[0x1E0] = ((EDX &#38; 0xFFFF) &#60;&#60; 6) + (ECX &#38; 0xFFFF);      // in K
#endif

mem88:  // old traditional method
        int15/AH=88h;
        /* <A
HREF="http://www.ctyme.com/intr/rb-1529.htm"
TARGET="_top"
>int15/AH=88h: SYSTEM - GET EXTENDED MEMORY SIZE</A
>
         *   AX = number of contiguous KB starting at absolute address 100000h */
        DS:[2] = AX;
}</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="hw_support"
></A
>4.5. Hardware Support</H2
><P
>&#13;     Check hardware support, like keyboard, video adapter, hard disk, MCA bus
     and pointing device.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>{
        // set the keyboard repeat rate to the max
        int16/AX=0305h(BX=0);
        // <A
HREF="http://www.ctyme.com/intr/rb-1757.htm"
TARGET="_top"
>int16/AH=03h: KEYBOARD - SET TYPEMATIC RATE AND DELAY</A
>

        /* Check for video adapter and its parameters and
         *   allow the user to browse video modes. */
        video();                        // see video.S

        // get hd0 and hd1 data
        copy hd0 data (*int41) to CS-DELTA_INITSEG:0080 (16 bytes);
        // <A
HREF="http://www.ctyme.com/intr/rb-6135.htm"
TARGET="_top"
>int41: SYSTEM DATA - HARD DISK 0 PARAMETER TABLE ADDRESS</A
>
        copy hd1 data (*int46) to CS-DELTA_INITSEG:0090 (16 bytes);
        // <A
HREF="http://www.ctyme.com/intr/rb-6184.htm"
TARGET="_top"
>int46: SYSTEM DATA - HARD DISK 1 PARAMETER TABLE ADDRESS</A
>
        // check if hd1 exists
        int13/AH=15h(AL=0, DL=0x81);
        // <A
HREF="http://www.ctyme.com/intr/rb-0639.htm"
TARGET="_top"
>int13/AH=15h: DISK - GET DISK TYPE</A
>
        if (failed || AH!=03h) {        // AH==03h if it is a hard disk
no_disk1:
                clear CS-DELTA_INITSEG:0090 (16 bytes);
        }
is_disk1:

        // check for Micro Channel (MCA) bus
        CS-DELTA_INITSEG:[0xA0] = 0;    // set table length to 0
        int15/AH=C0h;
        /* <A
HREF="http://www.ctyme.com/intr/rb-1594.htm"
TARGET="_top"
>int15/AH=C0h: SYSTEM - GET CONFIGURATION</A
>
         *   ES:BX = ROM configuration table */
        if (failed) goto no_mca;
        move ROM configuration table (ES:BX) to CS-DELTA_INITSEG:00A0;
        // CX = (table length&#60;14)? CX:16;    first 16 bytes only
no_mca:

        // check for PS/2 pointing device
        CS-DELTA_INITSEG:[0x1FF] = 0;   // default is no pointing device
        int11h();
        // <A
HREF="http://www.ctyme.com/intr/rb-0575.htm"
TARGET="_top"
>int11h: BIOS - GET EQUIPMENT LIST</A
>
        if (AL &#38; 0x04) {                // mouse installed
                DS:[0x1FF] = 0xAA;
        }
}</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="apm_support"
></A
>4.6. APM Support</H2
><P
>&#13;     Check BIOS APM support.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
{
        DS:[0x40] = 0;                  // version = 0 means no APM BIOS
        int15/AX=5300h(BX=0);
        // <A
HREF="http://www.ctyme.com/intr/rb-1394.htm"
TARGET="_top"
>int15/AX=5300h: Advanced Power Management v1.0+ - INSTALLATION CHECK</A
>
        if (failed || 'PM'!=BX || !(CX &#38; 0x02)) goto done_apm_bios;
        // (CX &#38; 0x02) means 32 bit is supported
        int15/AX=5304h(BX=0);
        // <A
HREF="http://www.ctyme.com/intr/rb-1398.htm"
TARGET="_top"
>int15/AX=5304h: Advanced Power Management v1.0+ - DISCONNECT INTERFACE</A
>
        EBX = CX = DX = ESI = DI = 0;
        int15/AX=5303h(BX=0);
        /* <A
HREF="http://www.ctyme.com/intr/rb-1397.htm"
TARGET="_top"
>int15/AX=5303h: Advanced Power Management v1.0+</A
>
         *   <A
HREF="http://www.ctyme.com/intr/rb-1397.htm"
TARGET="_top"
>- CONNECT 32-BIT PROTMODE INTERFACE</A
> */
        if (failed) {
no_32_apm_bios:                         // I moved label no_32_apm_bios here
                DS:[0x4C] &#38;= ~0x0002;   // remove 32 bit support bit
                goto done_apm_bios;
        }
        DS:[0x42] = AX, 32-bit code segment base address;
        DS:[0x44] = EBX, offset of entry point;
        DS:[0x48] = CX, 16-bit code segment base address;
        DS:[0x4A] = DX, 16-bit data segment base address;
        DS:[0x4E] = ESI, APM BIOS code segment length;
        DS:[0x52] = DI, APM BIOS data segment length;
        int15/AX=5300h(BX=0);           // check again
        // <A
HREF="http://www.ctyme.com/intr/rb-1394.htm"
TARGET="_top"
>int15/AX=5300h: Advanced Power Management v1.0+ - INSTALLATION CHECK</A
>
        if (success &#38;&#38;  'PM'==BX) {
                DS:[0x40] = AX, APM version;
                DS:[0x4C] = CX, APM flags;
        } else {
apm_disconnect:
                int15/AX=5304h(BX=0);
                /* <A
HREF="http://www.ctyme.com/intr/rb-1398.htm"
TARGET="_top"
>int15/AX=5304h: Advanced Power Management v1.0+</A
>
                 *   <A
HREF="http://www.ctyme.com/intr/rb-1398.htm"
TARGET="_top"
>- DISCONNECT INTERFACE</A
> */
        }
done_apm_bios:
}
#endif</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="prepare_protmode"
></A
>4.7. Prepare for Protected Mode</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>// call mode switch
{
        if (realmode_swtch) {
                realmode_swtch();               // mode switch hook
        } else {
rmodeswtch_normal:
                default_switch() {
                        cli;                    // no interrupts allowed
                        outb(0x80, 0x70);       // disable NMI
                }
        }
rmodeswtch_end:
}

// relocate code if necessary
{
        (long)code32 = code32_start;
        if (!(loadflags &#38; LOADED_HIGH)) {       // low loaded zImage
                // 0x0100 &#60;= start_sys_seg &#60; CS-DELTA_INITSEG
do_move0:
                AX = 0x100;
                BP = CS - DELTA_INITSEG;        // aka INITSEG
                BX = start_sys_seg;
do_move:
                move system image from (start_sys_seg:0 .. CS-DELTA_INITSEG:0)
                        to 0100:0;              // move 0x1000 bytes each time
        }
end_move:</PRE
></FONT
></TD
></TR
></TABLE
>
     Note that <EM
>code32_start</EM
> is initialized to
     0x1000 for <EM
>zImage</EM
>, or
     0x100000 for <EM
>bzImage</EM
>.
     The <EM
>code32</EM
> value will be used in passing control to
     <TT
CLASS="filename"
>linux/arch/i386/boot/compressed/head.S</TT
> in
     <A
HREF="#switch_protmode"
>Section 4.9</A
>.
     If we boot up <EM
>zImage</EM
>, it relocates
     <EM
>vmlinux</EM
> to 0100:0;
     If we boot up <EM
>bzImage</EM
>,
     <EM
>bvmlinux</EM
> remains at start_sys_seg:0.
     The relocation address must match the "-Ttext" option in
     <TT
CLASS="filename"
>linux/arch/i386/boot/compressed/Makefile</TT
>.
     See <A
HREF="#i386_boot_compressed_makefile"
>Section 2.5</A
>.
    </P
><P
>&#13;     Then it will relocate code from CS-DELTA_INITSEG:0
     (<EM
>bbootsect</EM
> and <EM
>bsetup</EM
>)
     to INITSEG:0, if necessary.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>        DS = CS;                // aka SETUPSEG
        // Check whether we need to be downward compatible with version &#60;=201
        if (!cmd_line_ptr &#38;&#38; 0x20!=type_of_loader &#38;&#38; SETUPSEG!=CS) {
                cli;            // as interrupt may use stack when we are moving
                // store new SS in DX
                AX = CS - DELTA_INITSEG;
                DX = SS;
                if (DX&#62;=AX) {   // stack frame will be moved together
                        DX = DX + INITSEG - AX; // i.e. SS-CS+SETUPSEG
                }
move_self_1:
                /* move CS-DELTA_INITSEG:0 to INITSEG:0 (setup_move_size bytes)
                 *   in two steps in order not to overwrite code on CS:IP
                 * move up (src &#60; dest) but downward ("std") */
                move CS-DELTA_INITSEG:move_self_here+0x200
                  to INITSEG:move_self_here+0x200,
                  setup_move_size-(move_self_here+0x200) bytes;
                // INITSEG:move_self_here+0x200 == SETUPSEG:move_self_here
                goto SETUPSEG:move_self_here;   // CS=SETUPSEG now
move_self_here:
                move CS-DELTA_INITSEG:0 to INITSEG:0,
                  move_self_here+0x200 bytes;   // I mean old CS before goto
                DS = SETUPSEG;
                SS = DX;
        }
end_move_self:
}</PRE
></FONT
></TD
></TR
></TABLE
>
     Note again, <EM
>type_of_loader</EM
> has been changed to 0x20
     by <EM
>bootsect_helper()</EM
> when it loads
     <EM
>bvmlinux</EM
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="enable_a20"
></A
>4.8. Enable A20</H2
><P
>&#13;     For A20 problem and solution, refer to
     <A
HREF="http://www.win.tue.nl/~aeb/linux/kbd/A20.html"
TARGET="_top"
>&#13;     A20 - a pain from the past</A
>.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>        A20_TEST_LOOPS          =  32   # Iterations per wait
        A20_ENABLE_LOOPS        = 255   # Total loops to try
{
#if defined(CONFIG_MELAN)
        // Enable A20. AMD Elan bug fix.
        outb(0x02, 0x92);               // outb(val, port)
a20_elan_wait:
        while (!a20_test());            // test not passed
        goto a20_done;
#endif

a20_try_loop:
        // First, see if we are on a system with no A20 gate.
a20_none:
        if (a20_test()) goto a20_done;  // test passed

        // Next, try the BIOS (INT 0x15, AX=0x2401)
a20_bios:
        int15/AX=2401h;
        // <A
HREF="http://www.ctyme.com/intr/rb-1336.htm"
TARGET="_top"
>Int15/AX=2401h: SYSTEM - later PS/2s - ENABLE A20 GATE</A
>
        if (a20_test()) goto a20_done;  // test passed

        // Try enabling A20 through the keyboard controller
a20_kbc:
        empty_8042();
        if (a20_test()) goto a20_done;  // test again in case BIOS delayed
        outb(0xD1, 0x64);               // command write
        empty_8042();
        outb(0xDF, 0x60);               // A20 on
        empty_8042();
        // wait until a20 really *is* enabled
a20_kbc_wait:
        CX = 0;
a20_kbc_wait_loop:
        do {
                if (a20_test()) goto a20_done;  // test passed
        } while (--CX)

        // Final attempt: use "configuration port A"
        outb((inb(0x92) | 0x02) &#38; 0xFE, 0x92);
        // wait for configuration port A to take effect
a20_fast_wait:
        CX = 0;
a20_fast_wait_loop:
        do {
                if (a20_test()) goto a20_done;  // test passed
        } while (--CX)

        // A20 is still not responding. Try frobbing it again.
        if (--a20_tries) goto a20_try_loop;
        prtstr("linux: fatal error: A20 gate not responding!");
a20_die:
        hlt;
        goto a20_die;
}

a20_tries:
        .byte   A20_ENABLE_LOOPS                // i.e. 255
a20_err_msg:
        .ascii  "linux: fatal error: A20 gate not responding!"
        .byte   13, 10, 0</PRE
></FONT
></TD
></TR
></TABLE
>
     For I/O port operations, take a look at related reference materials in
     <A
HREF="#setup_ref"
>Section 4.11</A
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="switch_protmode"
></A
>4.9. Switch to Protected Mode</H2
><P
>&#13;     To ensure code compatibility with all 32-bit IA-32 processors,
     perform the following steps to switch to protected mode:
     <P
></P
><OL
TYPE="1"
><LI
><P
>Prepare GDT with a null descriptor in the first GDT entry,
         one code segment descriptor and one data segment descriptor;</P
></LI
><LI
><P
>Disable interrupts, including maskable hardware interrupts
         and NMI;</P
></LI
><LI
><P
>&#13;          Load the base address and limit of the GDT to GDTR register,
          using "lgdt" instruction;
         </P
></LI
><LI
><P
>&#13;          Set PE flag in CR0 register, using "mov cr0" (Intel 386 and up)
          or "lmsw" instruction (for compatibility with Intel 286);
        </P
></LI
><LI
><P
>&#13;          Immediately execute a far "jmp" or a far "call" instruction.
         </P
></LI
></OL
>
     The stack can be placed in a normal read/write data segment,
     so no dedicated descriptor is required.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>a20_done:
{
        lidt    idt_48;         // load idt with 0, 0;

        // convert DS:gdt to a linear ptr
        *(long*)(gdt_48+2) = DS &#60;&#60; 4 + &#38;gdt;
        lgdt    gdt_48;

        // reset coprocessor
        outb(0, 0xF0);
        delay();
        outb(0, 0xF1);
        delay();

        // reprogram the interrupts
        outb(0xFF, 0xA1);       // mask all interrupts
        delay();
        outb(0xFB, 0x21);       // mask all irq's but irq2 which is cascaded

        // protected mode!
        AX = 1;
        lmsw ax;                // machine status word, bit 0 thru 15 of CR0
                                // only affects PE, MP, EM &#38; TS flags
        goto flush_instr;

flush_instr:
        BX = 0;                                 // flag to indicate a boot
        ESI = (CS - DELTA_INITSEG) &#60;&#60; 4;        // pointer to real-mode code
        /* NOTE: For high loaded big kernels we need a
         * jmpi    0x100000,__KERNEL_CS
         *
         * but we yet haven't reloaded the CS register, so the default size
         * of the target offset still is 16 bit.
         * However, using an operand prefix (0x66), the CPU will properly
         * take our 48 bit far pointer. (INTeL 80386 Programmer's Reference
         * Manual, Mixing 16-bit and 32-bit code, page 16-6) */

        // goto __KERNEL_CS:[(uint32*)code32]; */
        .byte   0x66, 0xea
code32: .long   0x1000          // overwritten in <A
HREF="#prepare_protmode"
>Section 4.7</A
>
        .word   __KERNEL_CS     // segment 0x10
        // see linux/arch/i386/boot/compressed/head.S:startup_32
}</PRE
></FONT
></TD
></TR
></TABLE
>
     The far "jmp" instruction (0xea) updates CS register.
     The contents of the remaining segment registers (DS, SS, ES, FS and GS)
     should be reloaded later.
     The operand-size prefix (0x66) is used to enforce "jmp" to be executed
     upon the 32-bit operand <EM
>code32</EM
>.
     For operand-size prefix details, check IA-32 Manual
     (Vol.1. Ch.3.6. Operand-size and Address-size Attributes, and
     Vol.3. Ch.17. Mixing 16-bit and 32-bit Code).
    </P
><P
>&#13;     Control is passed to
     <EM
>linux/arch/i386/boot/compressed/head.S:startup_32</EM
>.
     For <EM
>zImage</EM
>, it is at address 0x1000;
     For <EM
>bzImage</EM
>, it is at 0x100000.
     See <A
HREF="#compressed_head"
>Section 5</A
>.
    </P
><P
>&#13;     ESI points to the memory area of collected system data.
     It is used to pass parameters from the 16-bit real mode code of the kernel
     to the 32-bit part.
     See <TT
CLASS="filename"
>linux/Documentation/i386/zero-page.txt</TT
>
     for details.
    </P
><P
>&#13;     For mode switching details, refer to IA-32 Manual Vol.3.
     (Ch.9.8. Software Initialization for Protected-Mode Operation,
     Ch.9.9.1. Switching to Protected Mode, and
     Ch.17.4. Transferring Control Among Mixed-Size Code Segments).
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="setup_misc"
></A
>4.10. Miscellaneous</H2
><P
>&#13;     The rest are supporting functions and variables.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/* macros created by linux/Makefile targets:
 *   include/linux/compile.h and include/linux/version.h */
kernel_version: .ascii  UTS_RELEASE
                .ascii  " ("
                .ascii  LINUX_COMPILE_BY
                .ascii  "@"
                .ascii  LINUX_COMPILE_HOST
                .ascii  ") "
                .ascii  UTS_VERSION
                .byte   0

///////////////////////////////////////////////////////////////////////////////
default_switch() { cli; outb(0x80, 0x70); } /* disable interrupts and NMI */
bootsect_helper(ES:BX); /* see <A
HREF="#bootsect_helper"
>Section 3.7</A
> */

///////////////////////////////////////////////////////////////////////////////
a20_test()
{
        FS = 0;
        GS = 0xFFFF;
        CX = A20_TEST_LOOPS;                    // i.e. 32
        AX = FS:[0x200];
        do {
a20_test_wait:
                FS:[0x200] = ++AX;
                delay();
        } while (AX==GS:[0x210] &#38;&#38; --CX);
        return (AX!=GS[0x210]);
        // ZF==0 (i.e. NZ/NE, a20_test!=0) means test passed
}

///////////////////////////////////////////////////////////////////////////////
// check that the keyboard command queue is empty
empty_8042()
{
        int timeout = 100000;

        for (;;) {
empty_8042_loop:
                if (!--timeout) return;
                delay();
                inb(0x64, &#38;AL);                 // 8042 status port
                if (AL &#38; 1) {                   // has output
                        delay();
                        inb(0x60, &#38;AL);         // read it
no_output:      } else if (!(AL &#38; 2)) return;   // no input either
        }
}

///////////////////////////////////////////////////////////////////////////////
// read the CMOS clock, return the seconds in AL, used in video.S
gettime()
{
        int1A/AH=02h();
        /* <A
HREF="http://www.ctyme.com/intr/rb-2273.htm"
TARGET="_top"
>int1A/AH=02h: TIME - GET REAL-TIME CLOCK TIME</A
>
         * DH = seconds in BCD */
        AL = DH &#38; 0x0F;
        AH = DH &#62;&#62; 4;
        aad;
}

///////////////////////////////////////////////////////////////////////////////
delay() { outb(AL, 0x80); }                     // needed after doing I/O

// Descriptor table
gdt:
        .word   0, 0, 0, 0                      # dummy
        .word   0, 0, 0, 0                      # unused
        // segment 0x10, __KERNEL_CS
        .word   0xFFFF                          # 4Gb - (0x100000*0x1000 = 4Gb)
        .word   0                               # base address = 0
        .word   0x9A00                          # code read/exec
        .word   0x00CF                          # granularity = 4096, 386
                                                #  (+5th nibble of limit)
        // segment 0x18, __KERNEL_DS
        .word   0xFFFF                          # 4Gb - (0x100000*0x1000 = 4Gb)
        .word   0                               # base address = 0
        .word   0x9200                          # data read/write
        .word   0x00CF                          # granularity = 4096, 386
                                                #  (+5th nibble of limit)
idt_48:
        .word   0                               # idt limit = 0
        .word   0, 0                            # idt base = 0L
/* [gdt_48] should be 0x0800 (2048) to match the comment,
 *   like what Linux 2.2.22 does. */
gdt_48:
        .word   0x8000                          # gdt limit=2048,
                                                #  256 GDT entries
        .word   0, 0                            # gdt base (filled in later)

#include "video.S"

// signature at the end of setup.S:
{
setup_sig1:     .word   SIG1                    // 0xAA55
setup_sig2:     .word   SIG2                    // 0x5A5A
modelist:
}</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     Video setup and detection code in <TT
CLASS="filename"
>video.S</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>ASK_VGA = 0xFFFD  // defined in linux/include/asm-i386/boot.h
///////////////////////////////////////////////////////////////////////////////
video()
{
        pushw DS;               // use different segments
        FS = DS;
        DS = ES = CS;
        GS = 0;
        cld;
        basic_detect();         // basic adapter type testing (EGA/VGA/MDA/CGA)
#ifdef CONFIG_VIDEO_SELECT
        if (FS:[0x01FA]!=ASK_VGA) {     // user selected video mode
                mode_set();
                if (failed) {
                        prtstr("You passed an undefined mode number.\n");
                        mode_menu();
                }
        } else {
vid2:           mode_menu();
        }
vid1:
#ifdef CONFIG_VIDEO_RETAIN
        restore_screen();               // restore screen contents
#endif /* CONFIG_VIDEO_RETAIN */
#endif /* CONFIG_VIDEO_SELECT */
        mode_params();                  // store mode parameters
        popw ds;                        // restore original DS
}</PRE
></FONT
></TD
></TR
></TABLE
>
     /* TODO: video() details */
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="setup_ref"
></A
>4.11. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
><A
HREF="http://www.win.tue.nl/~aeb/linux/kbd/A20.html"
TARGET="_top"
>&#13;        A20 - a pain from the past</A
></P
></LI
><LI
><P
>&#13;<A
HREF="http://www.student.cs.uwaterloo.ca/~cs452/postscript/book.ps"
TARGET="_top"
>&#13;         Real-time Programming</A
> Appendix A: Complete I/O Port List
        </P
></LI
><LI
><P
><A
HREF="http://developer.intel.com/design/pentium4/manuals/"
TARGET="_top"
>&#13;        IA-32 Intel Architecture Software Developer's Manual</A
></P
></LI
><LI
><P
>Summary of empty_zero_page layout (kernel point of view):
        <TT
CLASS="filename"
>linux/Documentation/i386/zero-page.txt</TT
></P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="compressed_head"
></A
>5. linux/arch/i386/boot/compressed/head.S</H1
><P
>&#13;   We are in <EM
>bvmlinux</EM
> now!
   With the help of <EM
>misc.c:decompress_kernel()</EM
>,
   we are going to decompress <EM
>piggy.o</EM
>
   to get the resident kernel image <TT
CLASS="filename"
>linux/vmlinux</TT
>.
  </P
><P
>&#13;   This file is of pure 32-bit startup code.
   Unlike previous two files, it has no ".code16" statement in the source file.
   Refer to
<A
HREF="http://www.gnu.org/software/binutils/manual/gas-2.9.1/html_chapter/as_16.html#SEC205"
TARGET="_top"
>&#13;   Using as: Writing 16-bit Code</A
> for details.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="decompress_kernel"
></A
>5.1. Decompress Kernel</H2
><P
>&#13;     The segment base addresses in segment descriptors (which correspond to
     segment selector __KERNEL_CS and __KERNEL_DS) are equal to 0;
     therefore, the logical address offset (in segment:offset format) will
     be equal to its linear address if either of these segment selectors
     is used.
     For <EM
>zImage</EM
>, CS:EIP is at logical address 10:1000
     (linear address 0x1000) now;
     for <EM
>bzImage</EM
>, 10:100000 (linear address 0x100000).
    </P
><P
>&#13;     As paging is not enabled, linear address is identical to physical address.
     Check IA-32 Manual (Vol.1. Ch.3.3. Memory Organization, and
     Vol.3. Ch.3. Protected-Mode Memory Management) and
     <A
HREF="http://www.xml.com/ldd/chapter/book/ch13.html#t1"
TARGET="_top"
>&#13;     Linux Device Drivers: Memory Management in Linux</A
> for address issue.
    </P
><P
>&#13;     It comes from <TT
CLASS="filename"
>setup.S</TT
> that BX=0 and
     ESI=INITSEG&#60;&#60;4.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>.text
///////////////////////////////////////////////////////////////////////////////
startup_32()
{
        cld;
        cli;
        DS = ES = FS = GS = __KERNEL_DS;
        SS:ESP = *stack_start;  // end of user_stack[], defined in misc.c
        // all segment registers are reloaded after protected mode is enabled

        // check that A20 really IS enabled
        EAX = 0;
        do {
1:              DS:[0] = ++EAX;
        } while (DS:[0x100000]==EAX);

        EFLAGS = 0;
        clear BSS;                              // from _edata to _end

        struct moveparams mp;                   // subl $16,%esp
        if (!decompress_kernel(&#38;mp, ESI)) {     // return value in AX
                restore ESI from stack;
                EBX = 0;
                goto __KERNEL_CS:100000;
                // see linux/arch/i386/kernel/head.S:startup_32
        }

        /*
         * We come here, if we were loaded high.
         * We need to move the move-in-place routine down to 0x1000
         * and then start it with the buffer addresses in registers,
         * which we got from the stack.
         */
3:      move move_rountine_start..move_routine_end to 0x1000;
        // move_routine_start &#38; move_routine_end are defined below

        // prepare move_routine_start() parameters
        EBX = real mode pointer;        // ESI value passed from setup.S
        ESI = mp.low_buffer_start;
        ECX = mp.lcount;
        EDX = mp.high_buffer_star;
        EAX = mp.hcount;
        EDI = 0x100000;
        cli;                    // make sure we don't get interrupted
        goto __KERNEL_CS:1000;  // move_routine_start();
}

/* Routine (template) for moving the decompressed kernel in place,
 * if we were high loaded. This _must_ PIC-code ! */
///////////////////////////////////////////////////////////////////////////////
move_routine_start()
{
        move mp.low_buffer_start to 0x100000, mp.lcount bytes,
          in two steps: (lcount &#62;&#62; 2) words + (lcount &#38; 3) bytes;
        move/append mp.high_buffer_start, ((mp.hcount + 3) &#62;&#62; 2) words
        // 1 word == 4 bytes, as I mean 32-bit code/data.

        ESI = EBX;              // real mode pointer, as that from setup.S
        EBX = 0;
        goto __KERNEL_CS:100000;
        // see linux/arch/i386/kernel/head.S:startup_32()
move_routine_end:
}</PRE
></FONT
></TD
></TR
></TABLE
>
     For the meaning of "je 1b" and "jnz 3f", refer to
<A
HREF="http://www.gnu.org/software/binutils/manual/gas-2.9.1/html_chapter/as_5.html#SEC48"
TARGET="_top"
>&#13;     Using as: Local Symbol Names</A
>.
    </P
><P
>&#13;     Didn't find <EM
>_edata</EM
> and
     <EM
>_end</EM
> definitions?
     No problem, they are defined in the "internal linker script".
     Without -T (--script=) option specified, <B
CLASS="command"
>ld</B
> uses
     this builtin script to link <EM
>compressed/bvmlinux</EM
>.
     Use "<B
CLASS="command"
>ld --verbose</B
>" to display this script, or check
     Appendix B. <A
HREF="#internel_lds"
><I
>Internal Linker Script</I
></A
>.
    </P
><P
>&#13;     Refer to
<A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/html_chapter/ld_2.html#SEC3"
TARGET="_top"
>&#13;     Using LD, the GNU linker: Command Line Options</A
> for
     -T (--script=), -L (--library-path=) and --verbose
     option description.
     "<B
CLASS="command"
>man ld</B
>" and "<B
CLASS="command"
>info ld</B
>" may help too.
    </P
><P
>&#13;     <EM
>piggy.o</EM
> has been unzipped and control is passed to
     __KERNEL_CS:100000, i.e.
     <EM
>linux/arch/i386/kernel/head.S:startup_32()</EM
>.
     See <A
HREF="#kernel_head"
>Section 6</A
>.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#define LOW_BUFFER_START      0x2000
#define LOW_BUFFER_MAX       0x90000
#define HEAP_SIZE             0x3000
///////////////////////////////////////////////////////////////////////////////
asmlinkage int decompress_kernel(struct moveparams *mv, void *rmode)
|-- setup real_mode(=rmode), vidmem, vidport, lines and cols;
|-- if (is_zImage) setup_normal_output_buffer() {
|       output_data      = 0x100000;
|       free_mem_end_ptr = real_mode;
|   } else (is_bzImage) setup_output_buffer_if_we_run_high(mv) {
|       output_data      = LOW_BUFFER_START;
|       low_buffer_end   = MIN(real_mode, LOW_BUFFER_MAX) &#38; ~0xfff;
|       low_buffer_size  = low_buffer_end - LOW_BUFFER_START;
|       free_mem_end_ptr = &#38;end + HEAP_SIZE;
|       // get mv-&#62;low_buffer_start and mv-&#62;high_buffer_start
|       mv-&#62;low_buffer_start = LOW_BUFFER_START;
|       /* To make this program work, we must have
|        *   high_buffer_start &#62; &#38;end+HEAP_SIZE;
|        * As we will move low_buffer from LOW_BUFFER_START to 0x100000
|        *   (max low_buffer_size bytes) finally, we should have
|        *   high_buffer_start &#62; 0x100000+low_buffer_size; */
|       mv-&#62;high_buffer_start = high_buffer_start
|           = MAX(&#38;end+HEAP_SIZE, 0x100000+low_buffer_size);
|       mv-&#62;hcount =  0 if (0x100000+low_buffer_size &#62;  &#38;end+HEAP_SIZE);
|                  = -1 if (0x100000+low_buffer_size &#60;= &#38;end+HEAP_SIZE);
|       /* mv-&#62;hcount==0 : we need not move high_buffer later,
|        *   as it is already at 0x100000+low_buffer_size.
|        * Used by close_output_buffer_if_we_run_high() below. */
|   }
|-- makecrc();          // create crc_32_tab[]
|   puts("Uncompressing Linux... ");
|-- gunzip();
|   puts("Ok, booting the kernel.\n");
|-- if (is_bzImage) close_output_buffer_if_we_run_high(mv) {
|       // get mv-&#62;lcount and mv-&#62;hcount
|       if (bytes_out &#62; low_buffer_size) {
|           mv-&#62;lcount = low_buffer_size;
|           if (mv-&#62;hcount)
|               mv-&#62;hcount = bytes_out - low_buffer_size;
|       } else {
|           mv-&#62;lcount = bytes_out;
|           mv-&#62;hcount = 0;
|       }
|   }
`-- return is_bzImage;  // return value in AX</PRE
></FONT
></TD
></TR
></TABLE
>
     <EM
>end</EM
> is defined in the "internal linker script" too.
    </P
><P
>&#13;     <EM
>decompress_kernel()</EM
> has an "asmlinkage" modifer.
     In <TT
CLASS="filename"
>linux/include/linux/linkage.h</TT
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#ifdef __cplusplus
#define CPP_ASMLINKAGE extern "C"
#else
#define CPP_ASMLINKAGE
#endif

#if defined __i386__
#define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))
#elif defined __ia64__
#define asmlinkage CPP_ASMLINKAGE __attribute__((syscall_linkage))
#else
#define asmlinkage CPP_ASMLINKAGE
#endif</PRE
></FONT
></TD
></TR
></TABLE
>
     Macro "asmlinkage" will force the compiler to
     pass all function arguments on the stack, in case
     some optimization method may try to change this convention.
     Check
<A
HREF="http://gcc.gnu.org/onlinedocs/gcc-3.3.2/gcc/Function-Attributes.html#Function%20Attributes"
TARGET="_top"
>Using the GNU Compiler Collection (GCC): Declaring Attributes of Functions</A
> (regparm) and
<A
HREF="http://kernelnewbies.org/faq/index.php3#asmlinkage"
TARGET="_top"
>Kernelnewbies FAQ: What is asmlinkage</A
> for more details.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="gunzip"
></A
>5.2. gunzip()</H2
><P
>&#13;     <EM
>decompress_kernel()</EM
> calls
     <EM
>gunzip() -&#62; inflate()</EM
>, which are defined in
     <TT
CLASS="filename"
>linux/lib/inflate.c</TT
>,
     to decompress resident kernel image to
     low buffer (pointed by <EM
>output_data</EM
>) and
     high buffer (pointed by <EM
>high_buffer_start</EM
>, for
     <EM
>bzImage</EM
> only).
    </P
><P
>&#13;     The gzip file format is specified in
     <A
HREF="http://www.ietf.org/rfc/rfc1952.txt"
TARGET="_top"
>RFC 1952</A
>.
     <DIV
CLASS="table"
><A
NAME="AEN857"
></A
><P
><B
>Table 6. gzip file format</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Component</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Meaning</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Byte</TH
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
>Comment</TH
></TR
></THEAD
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>ID1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>IDentification 1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>31 (0x1f, \037)</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>ID2</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>IDentification 2</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>139 (0x8b, \213)
               <A
NAME="AEN877"
HREF="#FTN.AEN877"
><SPAN
CLASS="footnote"
>[a]</SPAN
></A
>
             </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>CM</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Compression Method</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>8 - denotes the "deflate" compression method</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>FLG</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>FLaGs</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>0 for most cases</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>MTIME</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Modification TIME</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>4</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>modification time of the original file</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>XFL</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>eXtra FLags</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>2 - compressor used maximum compression, slowest algorithm
               <A
NAME="AEN899"
HREF="#FTN.AEN899"
><SPAN
CLASS="footnote"
>[b]</SPAN
></A
>
             </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>OS</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Operating System</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>1</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>3 - Unix</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>extra fields</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>variable length, field indicated by FLG
               <A
NAME="AEN911"
HREF="#FTN.AEN911"
><SPAN
CLASS="footnote"
>[c]</SPAN
></A
>
             </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>compressed blocks</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>variable length</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>CRC32</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>-</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>4</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>CRC value of the uncompressed data</TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>ISIZE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>Input SIZE</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>4</TD
><TD
ALIGN="LEFT"
VALIGN="MIDDLE"
>the size of the uncompressed input data modulo 2^32</TD
></TR
></TBODY
><TR
><TD
COLSPAN="4"
>Notes:<BR><A
NAME="FTN.AEN877"
>a. </A
>
                 ID2 value can be 158 (0x9e, \236) for gzip 0.5;
               <BR><A
NAME="FTN.AEN899"
>b. </A
>
                 XFL value 4 - compressor used fastest algorithm;
               <BR><A
NAME="FTN.AEN911"
>c. </A
>
                 FLG bit 0, FTEXT, does not indicate any "extra field".
               <BR></TD
></TR
></TABLE
></DIV
>
    </P
><P
>&#13;     We can use this file format knowledge to find out
     the beginning of gzipped <TT
CLASS="filename"
>linux/vmlinux</TT
>.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
><B
CLASS="command"
>[root@localhost boot]# hexdump -C /boot/vmlinuz-2.4.20-28.9 | grep '1f 8b 08 00'</B
>
00004c50  1f 8b 08 00 01 f6 e1 3f  02 03 ec 5d 7d 74 14 55  |.......?...]}t.U|
<B
CLASS="command"
>[root@localhost boot]# hexdump -C /boot/vmlinuz-2.4.20-28.9 -s 0x4c40 -n 64</B
>
00004c40  00 80 0b 00 00 fc 21 00  68 00 00 00 1e 01 11 00  |......!.h.......|
00004c50  1f 8b 08 00 01 f6 e1 3f  02 03 ec 5d 7d 74 14 55  |.......?...]}t.U|
00004c60  96 7f d5 a9 d0 1d 4d ac  56 93 35 ac 01 3a 9c 6a  |......M.V.5..:.j|
00004c70  4d 46 5c d3 7b f8 48 36  c9 6c 84 f0 25 88 20 9f  |MF\.{.H6.l..%. .|
00004c80
<B
CLASS="command"
>[root@localhost boot]# hexdump -C /boot/vmlinuz-2.4.20-28.9 | tail -n 4</B
>
00114d40  bd 77 66 da ce 6f 3d d6  33 5c 14 a2 9f 7e fa e9  |.wf..o=.3\...~..|
00114d50  a7 9f 7e fa ff 57 3f 00  00 00 00 00 d8 bc ab ea  |..~..W?.........|
00114d60  44 5d 76 d1 fd 03 33 58  c2 f0 00 51 27 00        |D]v...3X...Q'.|
00114d6e</PRE
></FONT
></TD
></TR
></TABLE
>
     We can see that the gzipped file begins at 0x4c50 in the above example.
     The four bytes before "1f 8b 08 00" is <EM
>input_len</EM
>
     (0x0011011e, in little endian), and 0x4c50+0x0011011e=0x114d6e equals to
     the size of <EM
>bzImage</EM
>
     (<TT
CLASS="filename"
>/boot/vmlinuz-2.4.20-28.9</TT
>).
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>static uch *inbuf;           /* input buffer */
static unsigned insize = 0;  /* valid bytes in inbuf */
static unsigned inptr = 0;   /* index of next byte to be processed in inbuf */
///////////////////////////////////////////////////////////////////////////////
static int gunzip(void)
{
        Check input buffer for {ID1, ID2, CM}, must be
                {0x1f, 0x8b, 0x08} (normal case), or
                {0x1f, 0x9e, 0x08} (for gzip 0.5);
        Check FLG (flag byte), must not set bit 1, 5, 6 and 7;
        Ignore {MTIME, XFL, OS};
        Handle optional structures, which correspond to FLG bit 2, 3 and 4;
        inflate();              // handle compressed blocks
        Validate {CRC32, ISIZE};
}</PRE
></FONT
></TD
></TR
></TABLE
>
     When <EM
>get_byte()</EM
>, defined in
     <TT
CLASS="filename"
>linux/arch/i386/boot/compressed/misc.c</TT
>,
     is called for the first time,
     it calls <EM
>fill_inbuf()</EM
> to setup input buffer
     <EM
>inbuf=input_data</EM
> and
     <EM
>insize=input_len</EM
>.
     Symbol <EM
>input_data</EM
> and
     <EM
>input_len</EM
> are defined in
     <EM
>piggy.o</EM
> linker script.
     See <A
HREF="#i386_boot_compressed_makefile"
>Section 2.5</A
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="inflate"
></A
>5.3. inflate()</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>// some important definitions in misc.c
#define WSIZE 0x8000            /* Window size must be at least 32k,
                                 * and a power of two */
static uch window[WSIZE];       /* Sliding window buffer */
static unsigned outcnt = 0;     /* bytes in output buffer */

// linux/lib/inflate.c
#define wp outcnt
#define flush_output(w) (wp=(w),flush_window())
STATIC unsigned long bb;        /* bit buffer */
STATIC unsigned bk;             /* bits in bit buffer */
STATIC unsigned hufts;          /* track memory usage */
static long free_mem_ptr = (long)&#38;end;
///////////////////////////////////////////////////////////////////////////////
STATIC int inflate()
{
        int e;                  /* last block flag */
        int r;                  /* result code */
        unsigned h;             /* maximum struct huft's malloc'ed */
        void *ptr;

        wp = bb = bk = 0;

        // inflate compressed blocks one by one
        do {
                hufts = 0;
                gzip_mark() { ptr = free_mem_ptr; };
                if ((r = inflate_block(&#38;e)) != 0) {
                        gzip_release() { free_mem_ptr = ptr; };
                        return r;
                }
                gzip_release() { free_mem_ptr = ptr; };
                if (hufts &#62; h)
                h = hufts;
        } while (!e);

        /* Undo too much lookahead. The next read will be byte aligned so we
         * can discard unused bits in the last meaningful byte. */
        while (bk &#62;= 8) {
                bk -= 8;
                inptr--;
        }

        /* write the output window window[0..outcnt-1] to output_data,
         * update output_ptr/output_data, crc and bytes_out accordingly, and
         * reset outcnt to 0. */
        flush_output(wp);

        /* return success */
        return 0;
}</PRE
></FONT
></TD
></TR
></TABLE
>
     <EM
>free_mem_ptr</EM
> is used in
     <EM
>misc.c:malloc()</EM
> for dynamic memory allocation.
     Before inflating each compressed block, <EM
>gzip_mark()</EM
>
     saves the value of <EM
>free_mem_ptr</EM
>;
     After inflation, <EM
>gzip_release()</EM
> will
     restore this value.
     This is how it "<EM
>free()</EM
>" the memory allocated in
     <EM
>inflate_block()</EM
>.
    </P
><P
>&#13;     <A
HREF="http://www.gzip.org"
TARGET="_top"
>Gzip</A
> uses
     Lempel-Ziv coding (LZ77) to compress files.
     The compressed data format is specified in
     <A
HREF="http://www.ietf.org/rfc/rfc1951.txt"
TARGET="_top"
>RFC 1951</A
>.
     <EM
>inflate_block()</EM
> will inflate compressed blocks,
     which can be treated as a bit sequence.
    </P
><P
>&#13;     The data structure of each compressed block is outlined below:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>BFINAL (1 bit)
    0  - not the last block
    1  - the last block
BTYPE  (2 bits)
    00 - no compression
        remaining bits until the byte boundary;
        LEN      (2 bytes);
        NLEN     (2 bytes, the one's complement of LEN);
        data     (LEN bytes);
    01 - compressed with fixed Huffman codes
        {
        literal  (7-9 bits, represent code 0..287, excluding 256);
                     // See RFC 1951, table in Paragraph 3.2.6.
        length   (0-5 bits if literal &#62; 256, represent length 3..258);
                     // See RFC 1951, 1st alphabet table in Paragraph 3.2.5.
        data     (of literal bytes if literal &#60; 256);
        distance (5 plus 0-13 extra bits if literal == 257..285, represent
                         distance 1..32768);
                     /* See RFC 1951, 2nd alphabet table in Paragraph 3.2.5,
                      *   but statement in Paragraph 3.2.6. */
                     /* Move backward "distance" bytes in the output stream,
                      * and copy "length" bytes */
        }*           // can be of multiple instances
        literal  (7 bits, all 0, literal == 256, means end of block);
    10 - compressed with dynamic Huffman codes
        HLIT     (5 bits, # of Literal/Length codes - 257, 257-286);
        HDIST    (5 bits, # of Distance codes - 1,         1-32);
        HCLEN    (4 bits, # of Code Length codes - 4,      4 - 19);
        Code Length sequence    ((HCLEN+4)*3 bits)
        /* The following two alphabet tables will be decoded using
         *   the Huffman decoding table which is generated from
         *   the preceeding Code Length sequence. */
        Literal/Length alphabet (HLIT+257 codes)
        Distance alphabet       (HDIST+1 codes)
        // Decoding tables will be built from these alphpabet tables.
        /* The following is similar to that of fixed Huffman codes portion,
         *   except that they use different decoding tables. */
        {
        literal/length
                 (variable length, depending on Literal/Length alphabet);
        data     (of literal bytes if literal &#60; 256);
        distance (variable length if literal == 257..285, depending on
                         Distance alphabet);
        }*           // can be of multiple instances
        literal  (literal value 256, which means end of block);
    11 - reserved (error)</PRE
></FONT
></TD
></TR
></TABLE
>
     Note that data elements are packed into bytes starting from
     Least-Significant Bit (LSB) to Most-Significant Bit (MSB), while
     Huffman codes are packed starting with MSB.
     Also note that <EM
>literal</EM
> value 286-287 and
     <EM
>distance</EM
> codes 30-31 will never actually occur.
    </P
><P
>&#13;     With the above data structure in mind and RFC 1951 by hand,
     it is not too hard to understand <EM
>inflate_block()</EM
>.
     Refer to related paragraphs in RFC 1951 for Huffman coding and
     alphabet table generation.
    </P
><P
>&#13;     For more details, refer to <TT
CLASS="filename"
>linux/lib/inflate.c</TT
>,
     gzip source code (many in-line comments) and related reference materials.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="chead_ref"
></A
>5.4. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
>&#13;         <A
HREF="http://www.gnu.org/software/binutils/manual/gas-2.9.1/"
TARGET="_top"
>&#13;         Using as</A
>
        </P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.gnu.org/software/binutils/manual/ld-2.9.1/"
TARGET="_top"
>&#13;         Using LD, the GNU linker</A
>
        </P
></LI
><LI
><P
><A
HREF="http://developer.intel.com/design/pentium4/manuals/"
TARGET="_top"
>&#13;        IA-32 Intel Architecture Software Developer's Manual</A
></P
></LI
><LI
><P
><A
HREF="http://www.gzip.org"
TARGET="_top"
>&#13;        The gzip home page</A
></P
></LI
><LI
><P
><A
HREF="http://freshmeat.net/projects/gzip"
TARGET="_top"
>&#13;        gzip (freshmeat.net)</A
></P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.ietf.org/rfc/rfc1951.txt"
TARGET="_top"
>&#13;         RFC 1951: DEFLATE Compressed Data Format Specification version 1.3
         </A
>
        </P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.ietf.org/rfc/rfc1952.txt"
TARGET="_top"
>&#13;         RFC 1952: GZIP file format specification version 4.3
         </A
>
        </P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="kernel_head"
></A
>6. linux/arch/i386/kernel/head.S</H1
><P
>&#13;   Resident kernel image <TT
CLASS="filename"
>linux/vmlinux</TT
> is in place finally!
   It requires two inputs:
   <P
></P
><UL
><LI
><P
><EM
>ESI</EM
>, to indicate where
       the 16-bit real mode code is located, aka INITSEG&#60;&#60;4;</P
></LI
><LI
><P
><EM
>BX</EM
>, to indicate
       which CPU is running, 0 means BSP, other values for AP.</P
></LI
></UL
>
  </P
><P
>&#13;   ESI points to the parameter area from the 16-bit real mode code,
   which will be copied to <EM
>empty_zero_page</EM
> later.
   ESI is only valid for BSP.
  </P
><P
>&#13;   BSP (BootStrap Processor) and APs (Application Processors) are
   Intel terminologies.
   Check IA-32 Manual
   (Vol.3. Ch.7.5. Multiple-Processor (MP) Initialization) and
<A
HREF="http://www.intel.com/design/pentium/datashts/242016.htm"
TARGET="_top"
>&#13;   MultiProcessor Specification</A
> for MP intialization issue.
  </P
><P
>&#13;   From a software point of view, in a multiprocessor system, BSP and APs
   share the physical memory but use their own register sets.
   BSP runs the kernel code first, setups OS execution enviornment and
   triggers APs to run over it too.
   AP will be sleeping until BSP kicks it.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="enable_paging"
></A
>6.1. Enable Paging</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>.text
///////////////////////////////////////////////////////////////////////////////
startup_32()
{
        /* set segments to known values */
        cld;
        DS = ES = FS = GS = __KERNEL_DS;

#ifdef CONFIG_SMP
#define cr4_bits mmu_cr4_features-__PAGE_OFFSET
        /* long mmu_cr4_features defined in linux/arch/i386/kernel/setup.c
         * __PAGE_OFFSET = 0xC0000000, i.e. 3G */

        // AP with CR4 support (&#62; Intel 486) will copy CR4 from BSP
        if (BX &#38;&#38; cr4_bits) {
                // turn on paging options (PSE, PAE, ...)
                CR4 |= cr4_bits;
        } else
#endif
        {
                /* only BSP initializes page tables (pg0..empty_zero_page-1)
                 *   pg0 at .org 0x2000
                 *   empty_zero_page at .org 0x4000
                 *   total (0x4000-0x2000)/4 = 0x0800 entries */
                pg0 = {
                        0x00000007,             // 7 = PRESENT + RW + USER
                        0x00001007,             // 0x1000 = 4096 = 4K
                        0x00002007,
                        ...
                pg1:    0x00400007,
                        ...
                        0x007FF007              // total 8M
                empty_zero_page:
                };
        }</PRE
></FONT
></TD
></TR
></TABLE
>
     Why do we have to add "-__PAGE_OFFSET" when referring a kernel symbol,
     for example, like <EM
>pg0</EM
>?
    </P
><P
>&#13;     In <TT
CLASS="filename"
>linux/arch/i386/vmlinux.lds</TT
>, we have:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>  . = 0xC0000000 + 0x100000;
  _text = .;                    /* Text and read-only data */
  .text : {
        *(.text)
...</PRE
></FONT
></TD
></TR
></TABLE
>
   As <EM
>pg0</EM
> is at offset 0x2000 of section
   <EM
>.text</EM
> in
   <TT
CLASS="filename"
>linux/arch/i386/kernel/head.o</TT
>,
   which is the first file to be linked for <TT
CLASS="filename"
>linux/vmlinux</TT
>,
   it will be at offset 0x2000 in output section <EM
>.text</EM
>.
   Thus it will be located at address 0xC0000000+0x100000+0x2000 after linking.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>[root@localhost boot]# nm --defined /boot/vmlinux-2.4.20-28.9 | grep 'startup_32
\|mmu_cr4_features\|pg0\|\&#60;empty_zero_page\&#62;' | sort
c0100000 t startup_32
c0102000 T pg0
c0104000 T empty_zero_page
c0376404 B mmu_cr4_features</PRE
></FONT
></TD
></TR
></TABLE
>
     In protected mode without paging enabled, linear address will be
     mapped directly to physical address.
     "movl $pg0-__PAGE_OFFSET,%edi" will set EDI=0x102000,
     which is equal to the physical address of <EM
>pg0</EM
>
     (as <TT
CLASS="filename"
>linux/vmlinux</TT
> is relocated to 0x100000).
     Without this "-PAGE_OFFSET" scheme, it will access physical address
     0xC0102000, which will be wrong and probably beyond RAM space.
    </P
><P
>&#13;     <EM
>mmu_cr4_features</EM
> is in <EM
>.bss</EM
>
     section and is located at physical address 0x376404 in the above example.
    </P
><P
>&#13;     After page tables are initialized, paging can be enabled.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>        // set page directory base pointer, physical address
        CR3 = swapper_pg_dir - __PAGE_OFFSET;
        // paging enabled!
        CR0 |= 0x80000000;      // set PG bit
        goto 1f;                // flush prefetch-queue
1:
        EAX = &#38;1f;              // address following the next instruction
        goto *(EAX);            // relocate EIP
1:
        SS:ESP = *stack_start;</PRE
></FONT
></TD
></TR
></TABLE
>
     Page directory <EM
>swapper_pg_dir</EM
> (see definition in
     <A
HREF="#khead_misc"
>Section 6.5</A
>), together with
     page tables <EM
>pg0</EM
> and <EM
>pg1</EM
>,
     defines that both linear address 0..8M-1 and 3G..3G+8M-1 are mapped to
     physical address 0..8M-1.
     We can access kernel symbols without "-__PAGE_OFFSET" from now on,
     because kernel space (resides in linear address &#62;=3G) will
     be correctly mapped to its physical addresss after paging is enabled.
    </P
><P
>&#13;     "lss stack_start,%esp" (SS:ESP = *stack_start)
     is the first example to reference a symbol without "-PAGE_OFFSET",
     which sets up a new stack.
     For BSP, the stack is at the end of <EM
>init_task_union</EM
>.
     For AP, <EM
>stack_start.esp</EM
> has been redefined by
     <EM
>linux/arch/i386/kernel/smpboot.c:do_boot_cpu()</EM
> to be
     "(void *) (1024 + PAGE_SIZE + (char *)idle)" in
     <A
HREF="#smp_init"
>Section 8.2</A
>.
    </P
><P
>&#13;     For paging mechanism and data structures, refer to IA-32 Manual Vol.3.
     (Ch.3.7. Page Translation Using 32-Bit Physical Addressing,
     Ch.9.8.3. Initializing Paging,
     Ch.9.9.1. Switching to Protected Mode, and
     Ch.18.26.3. Enabling and Disabling Paging).
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="get_kernel_para"
></A
>6.2. Get Kernel Parameters</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#define OLD_CL_MAGIC_ADDR       0x90020
#define OLD_CL_MAGIC            0xA33F
#define OLD_CL_BASE_ADDR        0x90000
#define OLD_CL_OFFSET           0x90022
#define NEW_CL_POINTER          0x228   /* Relative to real mode data */

#ifdef CONFIG_SMP
        if (BX) {
                EFLAGS = 0;             // AP clears EFLAGS
        } else
#endif
        {
                // Initial CPU cleans BSS
                clear BSS;              // i.e. __bss_start .. _end
                setup_idt() {
                        /* idt_table[256] defined in arch/i386/kernel/traps.c
                         *   located in section .data.idt
                        EAX = __KERNEL_CS &#60;&#60; 16 + ignore_int;
                        DX = 0x8E00;    // interrupt gate, dpl = 0, present
                        idt_table[0..255] = {EAX, EDX};
                }
                EFLAGS = 0;
                /*
                 * Copy bootup parameters out of the way. First 2kB of
                 * _empty_zero_page is for boot parameters, second 2kB
                 * is for the command line.
                 */
                move *ESI (real-mode header) to empty_zero_page, 2KB;
                clear empty_zero_page+2K, 2KB;
                ESI = empty_zero_page[NEW_CL_POINTER];
                if (!ESI) {             // 32-bit command line pointer
                        if (OLD_CL_MAGIC==(uint16)[OLD_CL_MAGIC_ADDR]) {
                                ESI = [OLD_CL_BASE_ADDR]
                                      + (uint16)[OLD_CL_OFFSET];
                                move *ESI to empty_zero_page+2K, 2KB;
                        }
                } else {                // valid in 2.02+
                        move *ESI to empty_zero_page+2K, 2KB;
                }
        }
}</PRE
></FONT
></TD
></TR
></TABLE
>
     For BSP, kernel parameters are copied from memory pointed by
     <EM
>ESI</EM
> to <EM
>empty_zero_page</EM
>.
     Kernel command line will be copied to
     <EM
>empty_zero_page+2K</EM
> if applicable.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="check_cpu_type"
></A
>6.3. Check CPU Type</H2
><P
>&#13;     Refer to IA-32 Manual Vol.1.
     (Ch.13. Processor Identification and Feature Determination) on
     how to identify processor type and processor features.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>struct cpuinfo_x86;     // see include/asm-i386/processor.h
struct cpuinfo_x86 boot_cpu_data;       // see arch/i386/kernel/setup.c

#define CPU_PARAMS      SYMBOL_NAME(boot_cpu_data)
#define X86             CPU_PARAMS+0
#define X86_VENDOR      CPU_PARAMS+1
#define X86_MODEL       CPU_PARAMS+2
#define X86_MASK        CPU_PARAMS+3
#define X86_HARD_MATH   CPU_PARAMS+6
#define X86_CPUID       CPU_PARAMS+8
#define X86_CAPABILITY  CPU_PARAMS+12
#define X86_VENDOR_ID   CPU_PARAMS+28

checkCPUtype:
{
        X86_CPUID = -1;                 // no CPUID

        X86 = 3;                        // at least 386
        save original EFLAGS to ECX;
        flip AC bit (0x40000) in EFLAGS;
        if (AC bit not changed) goto is386;

        X86 = 4;                        // at least 486
        flip ID bit (0X200000) in EFLAGS;
        restore original EFLAGS;        // for AC &#38; ID flags
        if (ID bit can not be changed) goto is486;

        // get CPU info
        CPUID(EAX=0);
        X86_CPUID = EAX;
        X86_VENDOR_ID = {EBX, EDX, ECX};
        if (!EAX) goto is486;

        CPUID(EAX=1);
        CL = AL;
        X86 = AH &#38; 0x0f;                // family
        X86_MODEL = (AL &#38; 0xf0) &#62;&#62; 4;   // model
        X86_MASK = CL &#38; 0x0f;           // stepping id
        X86_CAPABILITY = EDX;           // feature</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;    Refer to IA-32 Manual Vol.3.
    (Ch.9.2. x87 FPU Initialization, and Ch.18.14. x87 FPU) on
    how to setup x87 FPU.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>is486:
        // save PG, PE, ET and set AM, WP, NE, MP
        EAX = (CR0 &#38; 0x80000011) | 0x50022;
        goto 2f;                        // skip "is386:" processing
is386:
        restore original EFLAGS from ECX;
        // save PG, PE, ET and set MP
        EAX = (CR0 &#38; 0x80000011) | 0x02;

        /* ET: Extension Type (bit 4 of CR0).
         * In the Intel 386 and Intel 486 processors, this flag indicates
         * support of Intel 387 DX math coprocessor instructions when set.
         * In the Pentium 4, Intel Xeon, and P6 family processors,
         * this flag is hardcoded to 1.
         *     -- IA-32 Manual Vol.3. Ch.2.5. Control Registers (p.2-14) */

2:      CR0 = EAX;
        check_x87() {
                /* We depend on ET to be correct.
                 * This checks for 287/387. */
                X86_HARD_MATH = 0;
                clts;                   // CR0.TS = 0;
                fninit;                 // Init FPU;
                fstsw AX;               // AX = ST(0);
                if (AL) {
                        CR0 ^= 0x04;    // no coprocessor, set EM
                } else {
                        ALIGN
1:                      X86_HARD_MATH = 1;
                        /* IA-32 Manual Vol.3. Ch.18.14.7.14. FSETPM Instruction
                         * inform 287 that processor is in protected mode
                         * 287 only, ignored by 387 */
                        fsetpm;
                }
        }
}</PRE
></FONT
></TD
></TR
></TABLE
>
     Macro ALIGN, defined in <TT
CLASS="filename"
>linux/include/linux/linkage.h</TT
>,
     specifies 16-bytes alignment and fill value 0x90 (opcode for NOP). See also
<A
HREF="http://www.gnu.org/software/binutils/manual/gas-2.9.1/html_chapter/as_7.html#SEC70"
TARGET="_top"
>&#13;     Using as: Assembler Directives</A
> for the meaning of
     directive <EM
>.align</EM
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="go_start_kernel"
></A
>6.4. Go Start Kernel</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>        ready:  .byte 0;        // global variable
{
        ready++;                // how many CPUs are ready
        lgdt gdt_descr;         // use new descriptor table in safe place
        lidt idt_descr;
        goto __KERNEL_CS:$1f;   // reload segment registers after "lgdt"
1:      DS = ES = FS = GS = __KERNEL_DS;
#ifdef CONFIG_SMP
        SS = __KERNEL_DS;       // reload segment only
#else
        SS:ESP = *stack_start;  /* end of init_task_union, defined
                                 *   in linux/arch/i386/kernel/init_task.c */
#endif
        EAX = 0;
        lldt AX;
        cld;

#ifdef CONFIG_SMP
        if (1!=ready) {         // not first CPU
                initialize_secondary();
                // see linux/arch/i386/kernel/smpboot.c
        } else
#endif
        {
                start_kernel(); // see linux/init/main.c
        }
L6:     goto L6;
}</PRE
></FONT
></TD
></TR
></TABLE
>
     The first CPU (BSP) will call
     <EM
>linux/init/main.c:start_kernel()</EM
> and
     the others (AP) will call
<EM
>linux/arch/i386/kernel/smpboot.c:initialize_secondary()</EM
>.
     See <EM
>start_kernel()</EM
> in <A
HREF="#init_main"
>Section 7</A
>
     and <EM
>initialize_secondary()</EM
> in
     <A
HREF="#initialize_secondary"
>Section 8.4</A
>.
    </P
><P
>&#13;     <EM
>init_task_union</EM
> happens to be the task struct
     for the first process, "idle" process (pid=0), whose stack grows
     from the tail of <EM
>init_task_union</EM
>.
     The following is the code related to <EM
>init_task_union</EM
>:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>ENTRY(stack_start)
        .long init_task_union+8192;
        .long __KERNEL_DS;

#ifndef INIT_TASK_SIZE
# define INIT_TASK_SIZE 2048*sizeof(long)
#endif

union task_union {
        struct task_struct task;
        unsigned long stack[INIT_TASK_SIZE/sizeof(long)];
};

/* INIT_TASK is used to set up the first task table, touch at
 * your own risk! Base=0, limit=0x1fffff (=2MB) */
union task_union init_task_union
        __attribute__((__section__(".data.init_task"))) =
                { INIT_TASK(init_task_union.task) };</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     <EM
>init_task_union</EM
> is for BSP "idle" process.
     Don't confuse it with "init" process, which will be mentioned in
     <A
HREF="#init_proc"
>Section 7.2</A
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="khead_misc"
></A
>6.5. Miscellaneous</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
// default interrupt "handler"
ignore_int() { printk("Unknown interrupt\n"); iret; }

/*
 * The interrupt descriptor table has room for 256 idt's,
 * the global descriptor table is dependent on the number
 * of tasks we can have..
 */
#define IDT_ENTRIES     256
#define GDT_ENTRIES     (__TSS(NR_CPUS))

.globl SYMBOL_NAME(idt)
.globl SYMBOL_NAME(gdt)

        ALIGN
        .word 0
idt_descr:
        .word IDT_ENTRIES*8-1           # idt contains 256 entries
SYMBOL_NAME(idt):
        .long SYMBOL_NAME(idt_table)

        .word 0
gdt_descr:
        .word GDT_ENTRIES*8-1
SYMBOL_NAME(gdt):
        .long SYMBOL_NAME(gdt_table)

/*
 * This is initialized to create an identity-mapping at 0-8M (for bootup
 * purposes) and another mapping of the 0-8M area at virtual address
 * PAGE_OFFSET.
 */
.org 0x1000
ENTRY(swapper_pg_dir)   // "ENTRY" defined in linux/include/linux/linkage.h
        .long 0x00102007
        .long 0x00103007
        .fill BOOT_USER_PGD_PTRS-2,4,0
        /* default: 766 entries */
        .long 0x00102007
        .long 0x00103007
        /* default: 254 entries */
        .fill BOOT_KERNEL_PGD_PTRS-2,4,0

/*
 * The page tables are initialized to only 8MB here - the final page
 * tables are set up later depending on memory size.
 */
.org 0x2000
ENTRY(pg0)

.org 0x3000
ENTRY(pg1)

/*
 * empty_zero_page must immediately follow the page tables ! (The
 * initialization loop counts until empty_zero_page)
 */
.org 0x4000
ENTRY(empty_zero_page)

/*
 * Real beginning of normal "text" segment
 */
.org 0x5000
ENTRY(stext)
ENTRY(_stext)

///////////////////////////////////////////////////////////////////////////////
/*
 * This starts the data section. Note that the above is all
 * in the text section because it has alignment requirements
 * that we cannot fulfill any other way.
 */
.data

ALIGN
/*
 * This contains typically 140 quadwords, depending on NR_CPUS.
 *
 * NOTE! Make sure the gdt descriptor in head.S matches this if you
 * change anything.
 */
ENTRY(gdt_table)
        .quad 0x0000000000000000        /* NULL descriptor */
        .quad 0x0000000000000000        /* not used */
        .quad 0x00cf9a000000ffff        /* 0x10 kernel 4GB code at 0x00000000 */
        .quad 0x00cf92000000ffff        /* 0x18 kernel 4GB data at 0x00000000 */
        .quad 0x00cffa000000ffff        /* 0x23 user   4GB code at 0x00000000 */
        .quad 0x00cff2000000ffff        /* 0x2b user   4GB data at 0x00000000 */
        .quad 0x0000000000000000        /* not used */
        .quad 0x0000000000000000        /* not used */
        /*
         * The APM segments have byte granularity and their bases
         * and limits are set at run time.
         */
        .quad 0x0040920000000000        /* 0x40 APM set up for bad BIOS's */
        .quad 0x00409a0000000000        /* 0x48 APM CS    code */
        .quad 0x00009a0000000000        /* 0x50 APM CS 16 code (16 bit) */
        .quad 0x0040920000000000        /* 0x58 APM DS    data */
        .fill NR_CPUS*4,8,0             /* space for TSS's and LDT's */</PRE
></FONT
></TD
></TR
></TABLE
>
     Macro ALIGN, before <EM
>idt_descr</EM
> and
     <EM
>gdt_table</EM
>, is for performance consideration.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="khead_ref"
></A
>6.6. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
><A
HREF="http://developer.intel.com/design/pentium4/manuals/"
TARGET="_top"
>&#13;        IA-32 Intel Architecture Software Developer's Manual</A
></P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.intel.com/design/pentium/datashts/242016.htm"
TARGET="_top"
>&#13;         MultiProcessor Specification</A
>
        </P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.gnu.org/software/binutils/manual/gas-2.9.1/"
TARGET="_top"
>&#13;         Using as</A
>
        </P
></LI
><LI
><P
>&#13;         <A
HREF="http://www.gnu.org/software/binutils/manual/"
TARGET="_top"
>&#13;         GNU Binary Utilities</A
>
        </P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="init_main"
></A
>7. linux/init/main.c</H1
><P
>&#13;   I felt guilty writing this chapter as there are too many documents
   about it, if not more than enough.
   <EM
>start_kernel()</EM
> supporting functions
   are changed from version to version, as they depend on
   OS component internals, which are being improved all the time.
   I may not have the time for frequent document updates,
   so I decided to keep this chapter as simple as possible.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="start_kernel"
></A
>7.1. start_kernel()</H2
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
<A
HREF="http://kernelnewbies.org/faq/index.php3#asmlinkage"
TARGET="_top"
>asmlinkage</A
> void <A
HREF="http://www.tldp.org/LDP/lki/lki-1.html#ss1.8"
TARGET="_top"
>__init</A
> start_kernel(void)
{
        char * command_line;
        extern char saved_command_line[];
/*
 * Interrupts are still disabled. Do necessary setups, then enable them
 */
        lock_kernel();
        printk(linux_banner);

        /* <A
HREF="http://www.symonds.net/~abhi/files/mm/mm.html"
TARGET="_top"
>Memory Management in Linux</A
>, esp. for setup_arch()
         * <A
HREF="http://linux-mm.org/docs/initialization.html"
TARGET="_top"
>Linux-2.4.4 MM Initialization</A
> */
        setup_arch(&#38;command_line);
        printk("Kernel command line: %s\n", saved_command_line);

        /* <TT
CLASS="filename"
>linux/Documentation/kernel-parameters.txt</TT
>
         * <A
HREF="http://www.tldp.org/HOWTO/BootPrompt-HOWTO.html"
TARGET="_top"
>The Linux BootPrompt-HowTo</A
> */
        parse_options(command_line);

        trap_init() {
#ifdef CONFIG_EISA
                if (isa_readl(0x0FFFD9) == 'E'+('I'&#60;&#60;8)+('S'&#60;&#60;16)+('A'&#60;&#60;24))
                        EISA_bus = 1;
#endif
#ifdef CONFIG_X86_LOCAL_APIC
                init_apic_mappings();
#endif
                set_xxxx_gate(x, &#38;func);    // setup gates
                cpu_init();
        }
        init_IRQ();
        sched_init();
        softirq_init() {
                for (int i=0; i&#60;32: i++)
                        tasklet_init(bh_task_vec+i, bh_action, i);
                open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL);
                open_softirq(HI_SOFTIRQ, tasklet_hi_action, NULL);
        }
        time_init();

        /*
         * HACK ALERT! This is early. We're enabling the console before
         * we've done PCI setups etc, and console_init() must be aware of
         * this. But we do want output early, in case something goes wrong.
         */
        console_init();
#ifdef CONFIG_MODULES
        init_modules();
#endif
        if (prof_shift) {
                unsigned int size;
                /* only text is profiled */
                prof_len = (unsigned long) &#38;_etext - (unsigned long) &#38;_stext;
                prof_len &#62;&#62;= prof_shift;
                size = prof_len * sizeof(unsigned int) + PAGE_SIZE-1;
                prof_buffer = (unsigned int *) alloc_bootmem(size);
        }

        kmem_cache_init();
        sti();

        // <A
HREF="http://www.tldp.org/HOWTO/BogoMips.html"
TARGET="_top"
>BogoMips mini-Howto</A
>
        calibrate_delay();

        // <TT
CLASS="filename"
>linux/Documentation/initrd.txt</TT
>
#ifdef CONFIG_BLK_DEV_INITRD
        if (initrd_start &#38;&#38; !initrd_below_start_ok &#38;&#38;
                        initrd_start &#60; min_low_pfn &#60;&#60; PAGE_SHIFT) {
                printk(KERN_CRIT "initrd overwritten (0x%08lx &#60; 0x%08lx) - "
                    "disabling it.\n",initrd_start,min_low_pfn &#60;&#60; PAGE_SHIFT);
                initrd_start = 0;
        }
#endif

        mem_init();
        kmem_cache_sizes_init();
        pgtable_cache_init();

        /*
         * For architectures that have highmem, num_mappedpages represents
         * the amount of memory the kernel can use.  For other architectures
         * it's the same as the total pages.  We need both numbers because
         * some subsystems need to initialize based on how much memory the
         * kernel can use.
         */
        if (num_mappedpages == 0)
                num_mappedpages =  num_physpages;

        fork_init(num_mempages);
        proc_caches_init();
        vfs_caches_init(num_physpages);
        buffer_init(num_physpages);
        page_cache_init(num_physpages);
#if defined(CONFIG_ARCH_S390)
        ccwcache_init();
#endif
        signals_init();
#ifdef CONFIG_PROC_FS
        proc_root_init();
#endif
#if defined(CONFIG_SYSVIPC)
        ipc_init();
#endif
        check_bugs();
        printk("POSIX conformance testing by UNIFIX\n");

        /*
         *      We count on the initial thread going ok
         *      Like idlers init is an unlocked kernel thread, which will
         *      make syscalls (and thus be locked).
         */
        smp_init() {
#ifndef CONFIG_SMP
#     ifdef CONFIG_X86_LOCAL_APIC
                APIC_init_uniprocessor();
#     else
                do { } while (0);
#     endif
#else
                /* Check <A
HREF="#smp_init"
>Section 8.2</A
>. */
#endif
        }

        rest_init() {
                // init process, pid = 1
                kernel_thread(init, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
                unlock_kernel();
                current-&#62;need_resched = 1;
                // idle process, pid = 0
                cpu_idle();     // never return
        }
}</PRE
></FONT
></TD
></TR
></TABLE
>
     <EM
>start_kernel()</EM
> calls <EM
>rest_init()</EM
>
     to spawn an "init" process and become "idle" process itself.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="init_proc"
></A
>7.2. init()</H2
><P
>&#13;     "Init" process:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
static int init(void * unused)
{
        lock_kernel();
        do_basic_setup();

        prepare_namespace();

        /*
         * Ok, we have completed the initial bootup, and
         * we're essentially up and running. Get rid of the
         * initmem segments and start the user-mode stuff..
         */
        free_initmem();
        unlock_kernel();

        if (open("/dev/console", O_RDWR, 0) &#60; 0)        // stdin
                printk("Warning: unable to open an initial console.\n");

        (void) dup(0);                                  // stdout
        (void) dup(0);                                  // stderr

        /*
         * We try each of these until one succeeds.
         *
         * The Bourne shell can be used instead of init if we are
         * trying to recover a really broken machine.
         */

        if (execute_command)
                execve(execute_command,argv_init,envp_init);
        execve("/sbin/init",argv_init,envp_init);
        execve("/etc/init",argv_init,envp_init);
        execve("/bin/init",argv_init,envp_init);
        execve("/bin/sh",argv_init,envp_init);
        panic("No init found.  Try passing init= option to kernel.");
}</PRE
></FONT
></TD
></TR
></TABLE
>
     Refer to "<B
CLASS="command"
>man init</B
>" or
     <A
HREF="http://freshmeat.net/projects/sysvinit"
TARGET="_top"
>SysVinit</A
>
     for further information on user-mode "init" process.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="idle_proc"
></A
>7.3. cpu_idle()</H2
><P
>&#13;     "Idle" process:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/*
 * The idle thread. There's no useful work to be
 * done, so just try to conserve power and have a
 * low exit latency (ie sit in a loop waiting for
 * somebody to say that they'd like to reschedule)
 */
void cpu_idle (void)
{
        /* endless idle loop with no priority at all */
        init_idle();
        current-&#62;nice = 20;
        current-&#62;counter = -100;

        while (1) {
                void (*idle)(void) = pm_idle;
                if (!idle)
                        idle = default_idle;
                while (!current-&#62;need_resched)
                        idle();
                schedule();
                check_pgt_cache();
        }
}

///////////////////////////////////////////////////////////////////////////////
void __init init_idle(void)
{
        struct schedule_data * sched_data;
        sched_data = &#38;aligned_data[smp_processor_id()].schedule_data;

        if (current != &#38;init_task &#38;&#38; task_on_runqueue(current)) {
                printk("UGH! (%d:%d) was on the runqueue, removing.\n",
                        smp_processor_id(), current-&#62;pid);
                del_from_runqueue(current);
        }
        sched_data-&#62;curr = current;
        sched_data-&#62;last_schedule = get_cycles();
        clear_bit(current-&#62;processor, &#38;wait_init_idle);
}

///////////////////////////////////////////////////////////////////////////////
void default_idle(void)
{
        if (current_cpu_data.hlt_works_ok &#38;&#38; !hlt_counter) {
                __cli();
                if (!current-&#62;need_resched)
                        safe_halt();
                else
                        __sti();
        }
}

/* defined in linux/include/asm-i386/system.h */
#define __cli()                 __asm__ __volatile__("cli": : :"memory")
#define __sti()                 __asm__ __volatile__("sti": : :"memory")

/* used in the idle loop; sti takes one instruction cycle to complete */
#define safe_halt()             __asm__ __volatile__("sti; hlt": : :"memory")</PRE
></FONT
></TD
></TR
></TABLE
>
     CPU will resume code execution with the instruction following "hlt"
     on the return from an interrupt handler.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="main_ref"
></A
>7.4. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
><A
HREF="http://www.tldp.org/LDP/lki/index.html"
TARGET="_top"
>&#13;        Linux Kernel 2.4 Internals</A
></P
></LI
><LI
><P
><A
HREF="http://kernelnewbies.org/documents/"
TARGET="_top"
>&#13;        Kerneldoc</A
></P
></LI
><LI
><P
><A
HREF="http://www.tldp.org/HOWTO/HOWTO-INDEX/index.html"
TARGET="_top"
>&#13;        LDP HOWTO-INDEX</A
></P
></LI
><LI
><P
><A
HREF="http://www.xml.com/ldd/chapter/book"
TARGET="_top"
>&#13;        Linux Device Drivers, 2nd Edition</A
></P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="smpboot"
></A
>8. SMP Boot</H1
><P
>&#13;   There are a few SMP related macros, like <EM
>CONFIG_SMP,
   CONFIG_X86_LOCAL_APIC, CONFIG_X86_IO_APIC, CONFIG_MULTIQUAD</EM
>
   and <EM
>CONFIG_VISWS</EM
>.
   I will ignore code that requires <EM
>CONFIG_MULTIQUAD</EM
>
   or <EM
>CONFIG_VISWS</EM
>,
   which most people don't care (if not using IBM high-end multiprocessor
   server or SGI Visual Workstation).
  </P
><P
>&#13;   BSP executes <EM
>start_kernel() -&#62; smp_init() -&#62; smp_boot_cpus()
   -&#62; do_boot_cpu() -&#62; wakeup_secondary_via_INIT()</EM
> to trigger APs.
   Check <A
HREF="http://www.intel.com/design/pentium/datashts/242016.htm"
TARGET="_top"
>&#13;   MultiProcessor Specification</A
> and IA-32 Manual Vol.3
   (Ch.7. Multile-Processor Management, and
   Ch.8. Advanced Programmable Interrupt Controller) for technical details.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="before_smpinit"
></A
>8.1. Before smp_init()</H2
><P
>&#13;     Before calling <EM
>smp_init()</EM
>,
     <EM
>start_kernel()</EM
> did something to setup SMP environment:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>start_kernel()
|-- setup_arch()
|   |-- parse_cmdline_early();  // SMP looks for "noht" and "acpismp=force"
|   |   `-- /* "noht" disables HyperThreading (2 logical cpus per Xeon) */
|   |       if (!memcmp(from, "noht", 4)) {
|   |           disable_x86_ht = 1;
|   |           set_bit(X86_FEATURE_HT, disabled_x86_caps);
|   |       }
|   |       /* "acpismp=force" forces parsing and use of the ACPI SMP table */
|   |       else if (!memcmp(from, "acpismp=force", 13))
|   |           enable_acpi_smp_table = 1;
|   |-- setup_memory();         // reserve memory for MP configuration table
|   |   |-- reserve_bootmem(PAGE_SIZE, PAGE_SIZE);
|   |   `-- find_smp_config();
|   |       `-- find_intel_smp();
|   |           `-- smp_scan_config();
|   |               |-- set flag <EM
>smp_found_config</EM
>
|   |               |-- set MP floating pointer <EM
>mpf_found</EM
>
|   |               `-- reserve_bootmem(mpf_found, PAGE_SIZE);
|   |-- if (disable_x86_ht) {   // if HyperThreading feature disabled
|   |       clear_bit(X86_FEATURE_HT, &#38;boot_cpu_data.x86_capability[0]);
|   |       set_bit(X86_FEATURE_HT, disabled_x86_caps);
|   |       enable_acpi_smp_table = 0;
|   |   }
|   |-- if (test_bit(X86_FEATURE_HT, &#38;boot_cpu_data.x86_capability[0]))
|   |       enable_acpi_smp_table = 1;
|   |-- smp_alloc_memory();
|   |   `-- /* reserve AP processor's real-mode code space in low memory */
|   |       trampoline_base = (void *) alloc_bootmem_low_pages(PAGE_SIZE);
|   `-- get_smp_config();     /* get boot-time MP configuration */
|       |-- config_acpi_tables();
|       |   |-- memset(&#38;acpi_boot_ops, 0, sizeof(acpi_boot_ops));
|       |   |-- acpi_boot_ops[ACPI_APIC] = acpi_parse_madt;
|       |   `-- /* Set <EM
>have_acpi_tables</EM
> to indicate using
|       |        * MADT in the ACPI tables; Use MPS tables if failed. */
|       |       if (enable_acpi_smp_table &#38;&#38; !acpi_tables_init())
|       |           have_acpi_tables = 1;
|       |-- set <EM
>pic_mode</EM
>
|       |   /* =1, if the IMCR is present and PIC Mode is implemented;
|       |    * =0, otherwise Virtual Wire Mode is implemented. */
|       |-- save local APIC address in <EM
>mp_lapic_addr</EM
>
|       `-- scan for MP configuration table entries, like
|             MP_PROCESSOR, MP_BUS, MP_IOAPIC, MP_INTSRC and MP_LINTSRC.
|-- trap_init();
|   `-- init_apic_mappings();   // setup PTE for APIC
|       |-- /* If no local APIC can be found then set up a fake all
|       |    * zeroes page to simulate the local APIC and another
|       |    * one for the IO-APIC. */
|       |   if (!smp_found_config &#38;&#38; detect_init_APIC()) {
|       |       apic_phys = (unsigned long) alloc_bootmem_pages(PAGE_SIZE);
|       |       apic_phys = __pa(apic_phys);
|       |   } else
|       |       apic_phys = mp_lapic_addr;
|       |-- /* map local APIC address,
|       |    *   <EM
>mp_lapic_addr</EM
> (0xfee00000) in most case,
|       |    *   to linear address FIXADDR_TOP (0xffffe000) */
|       |   set_fixmap_nocache(FIX_APIC_BASE, apic_phys);
|       |-- /* Fetch the APIC ID of the BSP in case we have a
|       |    * default configuration (or the MP table is broken). */
|       |   if (boot_cpu_physical_apicid == -1U)
|       |       boot_cpu_physical_apicid = GET_APIC_ID(apic_read(APIC_ID));
|       `-- // map IOAPIC address to uncacheable linear address
|           set_fixmap_nocache(idx, ioapic_phys);
|       // Now we can use linear address to access APIC space.
|-- init_IRQ();
|   |-- init_ISA_irqs();
|   |   |-- /* An initial setup of the virtual wire mode. */
|   |   |   init_bsp_APIC();
|   |   `-- init_8259A(auto_eoi=0);
|   `-- setup SMP/APIC interrupt handlers, esp. IPI.
`-- mem_init();
    `-- /* delay zapping low mapping entries for SMP: zap_low_mappings() */</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     IPI (InterProcessor Interrupt), CPU-to-CPU interrupt through local APIC,
     is the mechanism used by BSP to trigger APs.
    </P
><P
>&#13;     Be aware that "one local APIC per CPU is required" in an
     MP-compliant system.
     Processors do not share APIC local units address space (physical address
     0xFEE00000 - 0xFEEFFFFF), but will share APIC I/O units
     (0xFEC00000 - 0xFECFFFFF).
     Both address spaces are uncacheable.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="smp_init"
></A
>8.2. smp_init()</H2
><P
>&#13;     BSP calls
     <EM
>start_kernel() -&#62; smp_init() -&#62; smp_boot_cpus()</EM
>
     to setup data structures for each CPU and activate the rest APs.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
static void __init smp_init(void)
{
        /* Get other processors into their bootup holding patterns. */
        smp_boot_cpus();
        wait_init_idle = cpu_online_map;
        clear_bit(current-&#62;processor, &#38;wait_init_idle); /* Don't wait on me! */

        smp_threads_ready=1;
        smp_commence() {
                /* Lets the callins below out of their loop. */
                Dprintk("Setting commenced=1, go go go\n");
                wmb();
                atomic_set(&#38;smp_commenced,1);
        }

        /* Wait for the other cpus to set up their idle processes */
        printk("Waiting on wait_init_idle (map = 0x%lx)\n", wait_init_idle);
        while (wait_init_idle) {
                cpu_relax();    // i.e. "rep;nop"
                barrier();
        }
        printk("All processors have done init_idle\n");
}

///////////////////////////////////////////////////////////////////////////////
void __init smp_boot_cpus(void)
{
        // ... something not very interesting :-)

        /* Initialize the logical to physical CPU number mapping
         * and the per-CPU profiling router/multiplier */
        prof_counter[0..NR_CPUS-1] = 0;
        prof_old_multiplier[0..NR_CPUS-1] = 0;
        prof_multiplier[0..NR_CPUS-1] = 0;

        init_cpu_to_apicid() {
                physical_apicid_2_cpu[0..MAX_APICID-1] = -1;
                logical_apicid_2_cpu[0..MAX_APICID-1] = -1;
                cpu_2_physical_apicid[0..NR_CPUS-1] = 0;
                cpu_2_logical_apicid[0..NR_CPUS-1] = 0;
        }

        /* Setup boot CPU information */
        smp_store_cpu_info(0); /* Final full version of the data */
        printk("CPU%d: ", 0);
        print_cpu_info(&#38;cpu_data[0]);

        /* We have the boot CPU online for sure. */
        set_bit(0, &#38;cpu_online_map);
        boot_cpu_logical_apicid = logical_smp_processor_id() {
                GET_APIC_LOGICAL_ID(*(unsigned long *)(APIC_BASE+APIC_LDR));
        }
        map_cpu_to_boot_apicid(0, boot_cpu_apicid) {
               physical_apicid_2_cpu[boot_cpu_apicid] = 0;
               cpu_2_physical_apicid[0] = boot_cpu_apicid;
        }

        global_irq_holder = 0;
        current-&#62;processor = 0;
        init_idle();    // will clear corresponding bit in <EM
>wait_init_idle</EM
>
        smp_tune_scheduling();

        // ... some conditions checked

        connect_bsp_APIC();     // enable APIC mode if used to be PIC mode
        setup_local_APIC();

        if (GET_APIC_ID(apic_read(APIC_ID)) != boot_cpu_physical_apicid)
                BUG();

        /* Scan the CPU present map and fire up the other CPUs
         *   via do_boot_cpu() */
        Dprintk("CPU present map: %lx\n", phys_cpu_present_map);
        for (bit = 0; bit &#60; NR_CPUS; bit++) {
                apicid = cpu_present_to_apicid(bit);
                /* Don't even attempt to start the boot CPU! */
                if (apicid == boot_cpu_apicid)
                        continue;
                if (!(phys_cpu_present_map &#38; (1 &#60;&#60; bit)))
                        continue;
                if ((max_cpus &#62;= 0) &#38;&#38; (max_cpus &#60;= cpucount+1))
                        continue;
                do_boot_cpu(apicid);
                /* Make sure we unmap all failed CPUs */
                if ((boot_apicid_to_cpu(apicid) == -1) &#38;&#38;
                                (phys_cpu_present_map &#38; (1 &#60;&#60; bit)))
                        printk("CPU #%d not responding - cannot use it.\n",
                                                                apicid);
        }

        // ... SMP BogoMIPS
        // ... B stepping processor warning
        // ... HyperThreading handling

        /* Set up all local APIC timers in the system */
        setup_APIC_clocks();

        /* Synchronize the TSC with the AP */
        if (cpu_has_tsc &#38;&#38; cpucount)
                synchronize_tsc_bp();

smp_done:
        zap_low_mappings();
}

///////////////////////////////////////////////////////////////////////////////
static void __init do_boot_cpu (int apicid)
{
        cpu = ++cpucount;

        // 1. prepare "idle process" task struct for next AP

        /* We can't use kernel_thread since we must avoid to
         * reschedule the child. */
        if (fork_by_hand() &#60; 0)
                panic("failed fork for CPU %d", cpu);
        /* We remove it from the pidhash and the runqueue
         * once we got the process: */
        idle = init_task.prev_task;
        if (!idle)
                panic("No idle process for CPU %d", cpu);

        /* we schedule the first task manually */
        idle-&#62;processor = cpu;
        idle-&#62;cpus_runnable = 1 &#60;&#60; cpu; // only on this AP!

        map_cpu_to_boot_apicid(cpu, apicid) {
                physical_apicid_2_cpu[apicid] = cpu;
                cpu_2_physical_apicid[cpu] = apicid;
        }

        idle-&#62;thread.eip = (unsigned long) start_secondary;

        del_from_runqueue(idle);
        unhash_process(idle);
        init_tasks[cpu] = idle;

        // 2. prepare stack and code (CS:IP) for next AP

        /* start_eip had better be page-aligned! */
        start_eip = setup_trampoline() {
                memcpy(trampoline_base, trampoline_data,
                        trampoline_end - trampoline_data);
                /* <EM
>trampoline_base</EM
> was reserved in
                 * <EM
>start_kernel() -&#62; setup_arch() -&#62; smp_alloc_memory()</EM
>,
                 * and will be shared by all APs (one by one) */
                return virt_to_phys(trampoline_base);
        }

        /* So we see what's up */
        printk("Booting processor %d/%d eip %lx\n", cpu, apicid, start_eip);
        stack_start.esp = (void *) (1024 + PAGE_SIZE + (char *)idle);
        /* this value is used by next AP when it executes
         *   "lss stack_start,%esp" in
         *   linux/arch/i386/kernel/head.S:startup_32(). */

        /* This grunge runs the startup process for
         * the targeted processor. */
        atomic_set(&#38;init_deasserted, 0);
        Dprintk("Setting warm reset code and vector.\n");

        CMOS_WRITE(0xa, 0xf);
        local_flush_tlb();
        Dprintk("1.\n");
        *((volatile unsigned short *) TRAMPOLINE_HIGH) = start_eip &#62;&#62; 4;
        Dprintk("2.\n");
        *((volatile unsigned short *) TRAMPOLINE_LOW) = start_eip &#38; 0xf;
        Dprintk("3.\n");
        // we have setup 0:467 to <EM
>start_eip (trampoline_base)</EM
>

        // 3. kick AP to run (AP gets CS:IP from 0:467)

        // Starting actual IPI sequence...
        boot_error = wakeup_secondary_via_INIT(apicid, start_eip);
        if (!boot_error) {      // looks OK
                /* allow APs to start initializing. */
                set_bit(cpu, &#38;cpu_callout_map);

                /* ... Wait 5s total for a response */

                // bit cpu in cpu_callin_map is set by AP in smp_callin()
                if (test_bit(cpu, &#38;cpu_callin_map)) {
                        print_cpu_info(&#38;cpu_data[cpu]);
                } else {
                        boot_error= 1;
                        // marker 0xA5 set by AP in trampoline_data()
                        if (*((volatile unsigned char *)phys_to_virt(8192))
                                        == 0xA5)
                                /* trampoline started but... */
                                printk("Stuck ??\n");
                        else
                                /* trampoline code not run */
                                printk("Not responding.\n");
                }
        }
        if (boot_error) {
                /* Try to put things back the way they were before ... */
                unmap_cpu_to_boot_apicid(cpu, apicid);
                clear_bit(cpu, &#38;cpu_callout_map); /* set in do_boot_cpu() */
                clear_bit(cpu, &#38;cpu_initialized); /* set in cpu_init() */
                clear_bit(cpu, &#38;cpu_online_map);  /* set in smp_callin() */
                cpucount--;
        }

        /* mark "stuck" area as not stuck */
        *((volatile unsigned long *)phys_to_virt(8192)) = 0;
}</PRE
></FONT
></TD
></TR
></TABLE
>
     Don't confuse <EM
>start_secondary()</EM
> with
     <EM
>trampoline_data()</EM
>.
    The former is AP "idle" process task struct EIP value, and the latter is
    the real-mode code that AP runs after BSP kicks it
    (using <EM
>wakeup_secondary_via_INIT()</EM
>).
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="trampoline"
></A
>8.3. linux/arch/i386/kernel/trampoline.S</H2
><P
>&#13;     This file contains the 16-bit real-mode AP startup code.
     BSP reserved memory space <EM
>trampoline_base</EM
> in
     <EM
>start_kernel() -&#62; setup_arch() -&#62; smp_alloc_memory()</EM
>.
     Before BSP triggers AP, it copies the trampoline code, between
     <EM
>trampoline_data</EM
> and
     <EM
>trampoline_end</EM
>,
     to <EM
>trampoline_base</EM
>
     (in <EM
>do_boot_cpu() -&#62; setup_trampoline()</EM
>).
     BSP sets up 0:467 to point to <EM
>trampoline_base</EM
>,
     so that AP will run from here.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
trampoline_data()
{
r_base:
        wbinvd;         // Needed for NUMA-Q should be harmless for other
        DS = CS;
        BX = 1;         // Flag an SMP trampoline
        cli;

        // write marker for master knows we're running
        trampoline_base = 0xA5A5A5A5;

        lidt idt_48;
        lgdt gdt_48;

        AX = 1;
        lmsw AX;        // protected mode!
        goto flush_instr;
flush_instr:
        goto CS:100000; // see linux/arch/i386/kernel/head.S:startup_32()
}

idt_48:
        .word   0                       # idt limit = 0
        .word   0, 0                    # idt base = 0L

gdt_48:
        .word   0x0800                  # gdt limit = 2048, 256 GDT entries
        .long   gdt_table-__PAGE_OFFSET # gdt base = gdt (first SMP CPU)

.globl SYMBOL_NAME(trampoline_end)
SYMBOL_NAME_LABEL(trampoline_end)</PRE
></FONT
></TD
></TR
></TABLE
>
     Note that BX=1 when AP jumps to
     <TT
CLASS="filename"
>linux/arch/i386/kernel/head.S:startup_32()</TT
>,
     which is different from that of BSP (BX=0).
     See <A
HREF="#kernel_head"
>Section 6</A
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="initialize_secondary"
></A
>8.4. initialize_secondary()</H2
><P
>&#13;     Unlike BSP, at the end of
     <EM
>linux/arch/i386/kernel/head.S:startup_32()</EM
>
     in <A
HREF="#go_start_kernel"
>Section 6.4</A
>,
     AP will call <EM
>initialize_secondary()</EM
> instead of
     <EM
>start_kernel()</EM
>.
    </P
><P
>&#13;<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>/* Everything has been set up for the secondary
 * CPUs - they just need to reload everything
 * from the task structure
 * This function must not return. */
void __init initialize_secondary(void)
{
        /* We don't actually need to load the full TSS,
         * basically just the stack pointer and the eip. */
        asm volatile(
                "movl %0,%%esp\n\t"
                "jmp *%1"
                :
                :"r" (current-&#62;thread.esp),"r" (current-&#62;thread.eip));
}</PRE
></FONT
></TD
></TR
></TABLE
>
     As BSP called <EM
>do_boot_cpu()</EM
> to set
     <EM
>thread.eip</EM
> to <EM
>start_secondary()</EM
>,
     control of AP is passed to this function.
     AP uses a new stack frame, which was set up by BSP in
     <EM
>do_boot_cpu() -&#62; fork_by_hand() -&#62; do_fork()</EM
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="start_secondary"
></A
>8.5. start_secondary()</H2
><P
>&#13;     All APs wait for signal <EM
>smp_commenced</EM
> from BSP,
     triggered in <A
HREF="#smp_init"
>Section 8.2</A
>
     <EM
>smp_init() -&#62; smp_commence()</EM
>.
     After getting this signal, they will run "idle" processes.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>///////////////////////////////////////////////////////////////////////////////
int __init start_secondary(void *unused)
{
        /* Dont put anything before smp_callin(), SMP
         * booting is too fragile that we want to limit the
         * things done here to the most necessary things. */
        cpu_init();
        smp_callin();
        while (!atomic_read(&#38;smp_commenced))
                rep_nop();
        /* low-memory mappings have been cleared, flush them from
         * the local TLBs too. */
        local_flush_tlb();
        return cpu_idle();      // never return, see <A
HREF="#idle_proc"
>Section 7.3</A
>
}</PRE
></FONT
></TD
></TR
></TABLE
>
     <EM
>cpu_idle() -&#62; init_idle()</EM
> will
     clear corresponding bit in <EM
>wait_init_idle</EM
>, and
     finally make BSP finish <EM
>smp_init()</EM
> and continue with
     the following function in <EM
>start_kernel()</EM
>
     (i.e. <EM
>rest_init()</EM
>).
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="smpboot_ref"
></A
>8.6. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
>&#13;         <A
HREF="http://www.intel.com/design/pentium/datashts/242016.htm"
TARGET="_top"
>&#13;         MultiProcessor Specification</A
>
        </P
></LI
><LI
><P
><A
HREF="http://developer.intel.com/design/pentium4/manuals/"
TARGET="_top"
>&#13;        IA-32 Intel Architecture Software Developer's Manual</A
></P
></LI
><LI
><P
><A
HREF="http://www.tldp.org/LDP/lki/lki-1.html#ss1.7"
TARGET="_top"
>&#13;        Linux Kernel 2.4 Internals: Ch.1.7. SMP Bootup on x86</A
></P
></LI
><LI
><P
><A
HREF="http://www.tldp.org/HOWTO/SMP-HOWTO.html"
TARGET="_top"
>&#13;        Linux SMP HOWTO</A
></P
></LI
><LI
><P
><A
HREF="http://www.acpi.info"
TARGET="_top"
>ACPI spec</A
></P
></LI
><LI
><P
>An Implementation Of Multiprocessor Linux:
        <TT
CLASS="filename"
>linux/Documentation/smp.tex</TT
></P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="kbuild"
></A
>A. Kernel Build Example</H1
><P
>&#13;   Here is a kernel build example
   (in <A
HREF="http://www.redhat.com"
TARGET="_top"
>Redhat</A
> 9.0).
   Statements between "/*" and "*/" are in-line comments, not console output.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
><B
CLASS="command"
>[root@localhost root]# ln -s /usr/src/linux-2.4.20 /usr/src/linux</B
>
<B
CLASS="command"
>[root@localhost root]# cd /usr/src/linux</B
>
<B
CLASS="command"
>[root@localhost linux]# make xconfig</B
>
        <EM
>/* Create .config
         *   1. "Load Configuration from File" -&#62;
         *        /boot/config-2.4.20-28.9, or whatever you like
         *   2. Modify kernel configuration parameters
         *   3. "Save and Exit" */</EM
>
<B
CLASS="command"
>[root@localhost linux]# make oldconfig</B
>
        <EM
>/* Re-check .config, optional */</EM
>
<B
CLASS="command"
>[root@localhost linux]# vi Makefile</B
>
        <EM
>/* Modify EXTRAVERSION in linux/Makefile, optional */</EM
>
<B
CLASS="command"
>[root@localhost linux]# make dep</B
>
        <EM
>/* Create .depend and more */</EM
>
<B
CLASS="command"
>[root@localhost linux]# make bzImage</B
>
        <EM
>/* ... Some output omitted */</EM
>
ld -m elf_i386 -T /usr/src/linux-2.4.20/arch/i386/vmlinux.lds -e stext arch/i386
/kernel/head.o arch/i386/kernel/init_task.o init/main.o init/version.o init/do_m
ounts.o \
        --start-group \
        arch/i386/kernel/kernel.o arch/i386/mm/mm.o kernel/kernel.o mm/mm.o fs/f
s.o ipc/ipc.o \
         drivers/char/char.o drivers/block/block.o drivers/misc/misc.o drivers/n
et/net.o drivers/media/media.o drivers/char/drm/drm.o drivers/net/fc/fc.o driver
s/net/appletalk/appletalk.o drivers/net/tokenring/tr.o drivers/net/wan/wan.o dri
vers/atm/atm.o drivers/ide/idedriver.o drivers/cdrom/driver.o drivers/pci/driver
.o drivers/net/pcmcia/pcmcia_net.o drivers/net/wireless/wireless_net.o drivers/p
np/pnp.o drivers/video/video.o drivers/net/hamradio/hamradio.o drivers/md/mddev.
o drivers/isdn/vmlinux-obj.o \
        net/network.o \
        /usr/src/linux-2.4.20/arch/i386/lib/lib.a /usr/src/linux-2.4.20/lib/lib.
a /usr/src/linux-2.4.20/arch/i386/lib/lib.a \
        --end-group \
        -o vmlinux
nm vmlinux | grep -v '\(compiled\)\|\(\.o$\)\|\( [aUw] \)\|\(\.\.ng$\)\|\(LASH[R
L]DI\)' | sort &#62; System.map
make[1]: Entering directory `/usr/src/linux-2.4.20/arch/i386/boot'
gcc -E -D__KERNEL__ -I/usr/src/linux-2.4.20/include -D__BIG_KERNEL__ -traditiona
l -DSVGA_MODE=NORMAL_VGA  bootsect.S -o bbootsect.s
as -o bbootsect.o bbootsect.s
bootsect.S: Assembler messages:
bootsect.S:239: Warning: indirect lcall without `*'
ld -m elf_i386 -Ttext 0x0 -s --oformat binary bbootsect.o -o bbootsect
gcc -E -D__KERNEL__ -I/usr/src/linux-2.4.20/include -D__BIG_KERNEL__ -D__ASSEMBL
Y__ -traditional -DSVGA_MODE=NORMAL_VGA  setup.S -o bsetup.s
as -o bsetup.o bsetup.s
setup.S: Assembler messages:
setup.S:230: Warning: indirect lcall without `*'
ld -m elf_i386 -Ttext 0x0 -s --oformat binary -e begtext -o bsetup bsetup.o
make[2]: Entering directory `/usr/src/linux-2.4.20/arch/i386/boot/compressed'
tmppiggy=_tmp_$$piggy; \
rm -f $tmppiggy $tmppiggy.gz $tmppiggy.lnk; \
objcopy -O binary -R .note -R .comment -S /usr/src/linux-2.4.20/vmlinux $tmppigg
y; \
gzip -f -9 &#60; $tmppiggy &#62; $tmppiggy.gz; \
echo "SECTIONS { .data : { input_len = .; LONG(input_data_end - input_data) inpu
t_data = .; *(.data) input_data_end = .; }}" &#62; $tmppiggy.lnk; \
ld -m elf_i386 -r -o piggy.o -b binary $tmppiggy.gz -b elf32-i386 -T $tmppiggy.l
nk; \
rm -f $tmppiggy $tmppiggy.gz $tmppiggy.lnk
gcc -D__ASSEMBLY__ -D__KERNEL__ -I/usr/src/linux-2.4.20/include -traditional -c
head.S
gcc -D__KERNEL__ -I/usr/src/linux-2.4.20/include -Wall -Wstrict-prototypes -Wno-
trigraphs -O2 -fno-strict-aliasing -fno-common -fomit-frame-pointer -pipe -mpref
erred-stack-boundary=2 -march=i686 -DKBUILD_BASENAME=misc -c misc.c
ld -m elf_i386 -Ttext 0x100000 -e startup_32 -o bvmlinux head.o misc.o piggy.o
make[2]: Leaving directory `/usr/src/linux-2.4.20/arch/i386/boot/compressed'
gcc -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -o tools/build tools/buil
d.c -I/usr/src/linux-2.4.20/include
objcopy -O binary -R .note -R .comment -S compressed/bvmlinux compressed/bvmlinu
x.out
tools/build -b bbootsect bsetup compressed/bvmlinux.out CURRENT &#62; bzImage
Root device is (3, 67)
Boot sector 512 bytes.
Setup is 4780 bytes.
System is 852 kB
make[1]: Leaving directory `/usr/src/linux-2.4.20/arch/i386/boot'
<B
CLASS="command"
>[root@localhost linux]# make modules modules_install</B
>
        <EM
>/* ... Some output omitted */</EM
>
cd /lib/modules/2.4.20; \
mkdir -p pcmcia; \
find kernel -path '*/pcmcia/*' -name '*.o' | xargs -i -r ln -sf ../{} pcmcia
if [ -r System.map ]; then /sbin/depmod -ae -F System.map  2.4.20; fi
<B
CLASS="command"
>[root@localhost linux]# cp arch/i386/boot/bzImage /boot/vmlinuz-2.4.20</B
>
<B
CLASS="command"
>[root@localhost linux]# cp vmlinux /boot/vmlinux-2.4.20</B
>
<B
CLASS="command"
>[root@localhost linux]# cp System.map /boot/System.map-2.4.20</B
>
<B
CLASS="command"
>[root@localhost linux]# cp .config /boot/config-2.4.20</B
>
<B
CLASS="command"
>[root@localhost linux]# mkinitrd /boot/initrd-2.4.20.img 2.4.20</B
>
<B
CLASS="command"
>[root@localhost linux]# vi /boot/grub/grub.conf</B
>
        <EM
>/* Add the following lines to grub.conf:
title Linux (2.4.20)
        kernel /vmlinuz-2.4.20 ro root=LABEL=/
        initrd /initrd-2.4.20.img
         */</EM
></PRE
></FONT
></TD
></TR
></TABLE
>
  </P
><P
>&#13;   Refer to <A
HREF="http://kernelnewbies.org/faq/index.php3#compile"
TARGET="_top"
>&#13;   Kernelnewbies FAQ: How do I compile a kernel</A
> and
   <A
HREF="http://www.digitalhermit.com/linux/kernel.html"
TARGET="_top"
>&#13;   Kernel Rebuild Procedure</A
> for more details.
  </P
><P
>&#13;   To build the kernel in <A
HREF="http://www.debian.org"
TARGET="_top"
>Debian</A
>,
   also refer to
<A
HREF="http://www.debian.org/releases/stable/i386/ch-post-install.en.html#s-kernel-baking"
TARGET="_top"
>Debian Installation Manual: Compiling a New Kernel</A
>,
<A
HREF="http://www.debian.org/doc/manuals/debian-faq/ch-kernel.en.html"
TARGET="_top"
>The Debian GNU/Linux FAQ: Debian and the kernel</A
> and
<A
HREF="http://www.debian.org/doc/manuals/reference/ch-kernel.en.html"
TARGET="_top"
>Debian Reference: The Linux kernel under Debian</A
>.
   Check "<B
CLASS="command"
>zless /usr/share/doc/kernel-package/Problems.gz</B
>"
   if you encounter problems.
  </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="internel_lds"
></A
>B. Internal Linker Script</H1
><P
>&#13;   Without -T (--script=) option specified, <B
CLASS="command"
>ld</B
> will
   use this builtin script to link targets:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
><B
CLASS="command"
>[root@localhost linux]# ld --verbose</B
>
GNU ld version 2.13.90.0.18 20030206
  Supported emulations:
   elf_i386
   i386linux
using internal linker script:
==================================================
/* Script for -z combreloc: combine and sort reloc sections */
OUTPUT_FORMAT("elf32-i386", "elf32-i386",
              "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(_start)
SEARCH_DIR("/usr/i386-redhat-linux/lib"); SEARCH_DIR("/usr/lib"); SEARCH_DIR("/u
sr/local/lib"); SEARCH_DIR("/lib");
/* Do we need any of these for elf?
   __DYNAMIC = 0;    */
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0x08048000 + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .hash           : { *(.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rel.dyn        :
    {
      *(.rel.init)
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)
      *(.rel.fini)
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)
      *(.rel.ctors)
      *(.rel.dtors)
      *(.rel.got)
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)
    }
  .rela.dyn       :
    {
      *(.rela.init)
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
      *(.rela.fini)
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)
      *(.rela.ctors)
      *(.rela.dtors)
      *(.rela.got)
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
    }
  .rel.plt        : { *(.rel.plt) }
  .rela.plt       : { *(.rela.plt) }
  .init           :
  {
    KEEP (*(.init))
  } =0x90909090
  .plt            : { *(.plt) }
  .text           :
  {
    *(.text .stub .text.* .gnu.linkonce.t.*)
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
  } =0x90909090
  .fini           :
  {
    KEEP (*(.fini))
  } =0x90909090
  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
  .rodata1        : { *(.rodata1) }
  .eh_frame_hdr : { *(.eh_frame_hdr) }
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table) }
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = ALIGN (0x1000) - ((0x1000 - .) &#38; (0x1000 - 1)); . = DATA_SEGMENT_ALIGN (0x
1000, 0x1000);
  /* For backward-compatibility with tools that don't support the
     *_array_* sections below, our glibc's crt files contain weak
     definitions of symbols that they reference.  We don't want to use
     them, though, unless they're strictly necessary, because they'd
     bring us empty sections, unlike PROVIDE below, so we drop the
     sections from the crt files here.  */
  /DISCARD/ : {
      */crti.o(.init_array .fini_array .preinit_array)
      */crtn.o(.init_array .fini_array .preinit_array)
  }
  /* Ensure the __preinit_array_start label is properly aligned.  We
     could instead move the label definition inside the section, but
     the linker would then create the section even if it turns out to
     be empty, which isn't pretty.  */
  . = ALIGN(32 / 8);
  PROVIDE (__preinit_array_start = .);
  .preinit_array     : { *(.preinit_array) }
  PROVIDE (__preinit_array_end = .);
  PROVIDE (__init_array_start = .);
  .init_array     : { *(.init_array) }
  PROVIDE (__init_array_end = .);
  PROVIDE (__fini_array_start = .);
  .fini_array     : { *(.fini_array) }
  PROVIDE (__fini_array_end = .);
  .data           :
  {
    *(.data .data.* .gnu.linkonce.d.*)
    SORT(CONSTRUCTORS)
  }
  .data1          : { *(.data1) }
  .tdata          : { *(.tdata .tdata.* .gnu.linkonce.td.*) }
  .tbss           : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table) }
  .dynamic        : { *(.dynamic) }
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP (*crtbegin.o(.ctors))
    /* We don't want to include the .ctor section from
       from the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP (*(EXCLUDE_FILE (*crtend.o ) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*(.ctors))
  }
  .dtors          :
  {
    KEEP (*crtbegin.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o ) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*(.dtors))
  }
  .jcr            : { KEEP (*(.jcr)) }
  .got            : { *(.got.plt) *(.got) }
  _edata = .;
  PROVIDE (edata = .);
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.*)
   *(COMMON)
   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.  */
   . = ALIGN(32 / 8);
  }
  . = ALIGN(32 / 8);
  _end = .;
  PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
}


==================================================
<B
CLASS="command"
>[root@localhost linux]# </B
></PRE
></FONT
></TD
></TR
></TABLE
>
  </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="bootloader"
></A
>C. GRUB and LILO</H1
><P
>&#13;   Both <A
HREF="http://www.gnu.org/software/grub"
TARGET="_top"
>GNU GRUB</A
> and
   <A
HREF="http://freshmeat.net/projects/lilo"
TARGET="_top"
>LILO</A
>
   understand the real-mode kernel header format and will load
   the bootsect (one sector), setup code
   (<EM
>setup_sects</EM
> sectors) and
   compressed kernel image (<EM
>syssize</EM
>*16 bytes) into memory.
   They fill out the loader identifier (<EM
>type_of_loader</EM
>)
   and try to pass appropriate parameters and options to the kernel.
   After they finish their jobs, control is passed to setup code.
  </P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="grub"
></A
>C.1. GNU GRUB</H2
><P
>&#13;     The following GNU GRUB program outline is based on grub-0.93.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>stage2/stage2.c:cmain()
`-- run_menu()
    `-- run_script();
        |-- builtin = find_command(heap);
        |-- kernel_func();              // builtin-&#62;func() for command "kernel"
        |   `-- load_image();           // search BOOTSEC_SIGNATURE in boot.c
        |   /* memory from 0x100000 is populated by and in the order of
        |    *   (bvmlinux, bbootsect, bsetup) or (vmlinux, bootsect, setup) */
        |-- initrd_func();              // for command "initrd"
        |   `-- load_initrd();
        `-- boot_func();                // for implicit command "boot"
            `-- linux_boot();           // defined in stage2/asm.S
                or big_linux_boot();    //   not in grub/asmstub.c!

// In stage2/asm.S
linux_boot:
        /* copy kernel */
        move system code from 0x100000 to 0x10000 (linux_text_len bytes);
big_linux_boot:
        /* copy the real mode part */
        EBX = linux_data_real_addr;
        move setup code from linux_data_tmp_addr (0x100000+text_len)
            to linux_data_real_addr (0x9100 bytes);
        /* change %ebx to the segment address */
        linux_setup_seg = (EBX &#62;&#62; 4) + 0x20;
        /* XXX new stack pointer in safe area for calling functions */
        ESP = 0x4000;
        stop_floppy();
        /* final setup for linux boot */
        prot_to_real();
        cli;
        SS:ESP = BX:9000;
        DS = ES = FS = GS = BX;
        /* jump to start, i.e. ljmp linux_setup_seg:0
         * Note that linux_setup_seg is just changed to BX. */
        .byte   0xea
        .word   0
linux_setup_seg:
        .word   0
</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     Refer to "<B
CLASS="command"
>info grub</B
>" for GRUB manual.
    </P
><P
>&#13;     One
<A
HREF="http://mail.gnu.org/archive/html/bug-grub/2003-03/msg00030.html"
TARGET="_top"
>&#13;     reported GNU GRUB bug</A
> should be noted if you are
     porting grub-0.93 and making changes to <EM
>bsetup</EM
>.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="lilo"
></A
>C.2. LILO</H2
><P
>&#13;     Unlike GRUB, LILO does not check the configuration file
     when booting system.
     Tricks happen when <B
CLASS="command"
>lilo</B
> is invoked from terminal.
    </P
><P
>&#13;     The following LILO program outline is based on lilo-22.5.8.
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>lilo.c:main()
|-- cfg_open(config_file);
|-- cfg_parse(cf_options);
|-- bsect_open(boot_dev, map_file, install, delay, timeout);
|   |-- open_bsect(boot_dev);
|   `-- map_create(map_file);
|-- cfg_parse(cf_top)
|   `-- cfg_do_set();
|       `-- do_image();             // walk-&#62;action for "image=" section
|           |-- cfg_parse(cf_image) -&#62; cfg_do_set();
|           |-- bsect_common(&#38;descr, 1);
|           |   |-- map_begin_section();
|           |   |-- map_add_sector(fallback_buf);
|           |   `-- map_add_sector(options);
|           |-- boot_image(name, &#38;descr) or boot_device(name, range, &#38;descr);
|           |   |-- int fd = geo_open(&#38;descr, name, O_RDONLY);
|           |   |   read(fd, &#38;buff, SECTOR_SIZE);
|           |   |   map_add(&#38;geo, 0, image_sectors);
|           |   |   map_end_section(&#38;descr-&#62;start, setup_sects+2+1);
|           |   |       /* two sectors created in bsect_common(),
|           |   |        *   another one sector for bootsect */
|           |   |   geo_close(&#38;geo);
|           |   `-- fd = geo_open(&#38;descr, initrd, O_RDONLY);
|           |       map_begin_section();
|           |       map_add(&#38;geo, 0, initrd_sectors);
|           |       map_end_section(&#38;descr-&#62;initrd,0);
|           |       geo_close(&#38;geo);
|           `-- bsect_done(name, &#38;descr);
`-- bsect_update(backup_file, force_backup, 0); // update boot sector
    |-- make_backup();
    |-- map_begin_section();
    |   map_add_sector(table);
    |   map_write(&#38;param2, keytab, 0, 0);
    |   map_close(&#38;param2, here2);
    |-- // ... perform the relocation of the boot sector
    |-- // ... setup bsect_wr to correct place
    |-- write(fd, bsect_wr, SECTOR_SIZE);
    `-- close(fd);</PRE
></FONT
></TD
></TR
></TABLE
>
     <EM
>map_add(), map_add_sector()</EM
> and
     <EM
>map_add_zero()</EM
> may call
     <EM
>map_register()</EM
> to complete their jobs,
     while <EM
>map_register()</EM
> will keep a list for
     all (CX, DX, AL) triplets (data structure SECTOR_ADDR) used to
     identify all registered sectors.
    </P
><P
>&#13;     LILO runs <TT
CLASS="filename"
>first.S</TT
> and <TT
CLASS="filename"
>second.S</TT
>
     to boot a system.
     It calls <EM
>second.S:doboot()</EM
> to load map file,
     bootsect and setup code.
     Then it calls <EM
>lfile()</EM
> to load the system code,
     calls <EM
>launch2() -&#62; launch() -&#62; cl_wait() -&#62; start_setup()
     -&#62; start_setup2()</EM
> and finnaly executes
     "jmpi 0,SETUPSEG" instruction to run setup code.
    </P
><P
>&#13;     Refer to "<B
CLASS="command"
>man lilo</B
>" and
     "<B
CLASS="command"
>man lilo.conf</B
>" for LILO details.
    </P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="bootloader_ref"
></A
>C.3. Reference</H2
><P
>&#13;    <P
></P
><UL
><LI
><P
>&#13;<A
HREF="http://www.gnu.org/software/grub/"
TARGET="_top"
>GNU GRUB</A
>
        </P
></LI
><LI
><P
>&#13;<A
HREF="http://www.openbg.net/sto/os/xml/grub.html"
TARGET="_top"
>GRUB Tutorial</A
>
        </P
></LI
><LI
><P
>&#13;<A
HREF="http://freshmeat.net/projects/lilo"
TARGET="_top"
>LILO (freshmeat.net)</A
>
        </P
></LI
><LI
><P
>&#13;<A
HREF="http://www.tldp.org/HOWTO/HOWTO-INDEX/os.html#OSBOOT"
TARGET="_top"
>&#13;         LDP HOWTO-INDEX: Boot Loaders and Booting the OS</A
>
        </P
></LI
></UL
>
    </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="faq"
></A
>D. FAQ</H1
><P
>&#13;   For things that are to be in appropriate chapters, or should be here.
   /* TODO: */
  </P
></DIV
></DIV
></BODY
></HTML
>