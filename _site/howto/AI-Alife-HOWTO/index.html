<HTML>
<HEAD>

<TITLE>
GNU/Linux AI &amp; Alife HOWTO
</TITLE>
<link rel="stylesheet" href="../bookstyle.css"></HEAD>
<BODY BGCOLOR=white>

<HR>
<H1>GNU/Linux AI &amp; Alife HOWTO</H1>

<H2>by 
<A HREF="mailto:jae@zhar.net">John Eikenberry</A></H2>v3.0, 15 Dec 2012
<HR>
<EM>This howto mainly contains information about, and links to,
various AI related software libraries, applications, etc.
that work on the GNU/Linux platform. All of it is (at least)
free for personal use.
The new master page for this document is 
<A HREF="http://zhar.net/howto/">http://zhar.net/howto/</A></EM>
<HR>
<P>
<H2><A NAME="toc1">1.</A> <A HREF="#s1">Introduction</A></H2>

<UL>
<LI><A NAME="toc1.1">1.1</A> <A HREF="#ss1.1">Purpose</A>
<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">What's New</A>
<LI><A NAME="toc1.3">1.3</A> <A HREF="#ss1.3">Where to find this software</A>
<LI><A NAME="toc1.4">1.4</A> <A HREF="#ss1.4">Updates and comments</A>
<LI><A NAME="toc1.5">1.5</A> <A HREF="#ss1.5">Copyright/License</A>
</UL>
<P>
<H2><A NAME="toc2">2.</A> <A HREF="#s2">Symbolic Systems (GOFAI)</A></H2>

<UL>
<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">AI class/code libraries</A>
<LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">AI software kits, applications, etc.</A>
</UL>
<P>
<H2><A NAME="toc3">3.</A> <A HREF="#s3">Connectionism</A></H2>

<UL>
<LI><A NAME="toc3.1">3.1</A> <A HREF="#ss3.1">Connectionist class/code libraries</A>
<LI><A NAME="toc3.2">3.2</A> <A HREF="#ss3.2">Connectionist software kits/applications</A>
</UL>
<P>
<H2><A NAME="toc4">4.</A> <A HREF="#s4">Evolutionary Computing</A></H2>

<UL>
<LI><A NAME="toc4.1">4.1</A> <A HREF="#ss4.1">EC class/code libraries</A>
<LI><A NAME="toc4.2">4.2</A> <A HREF="#ss4.2">EC software kits/applications</A>
</UL>
<P>
<H2><A NAME="toc5">5.</A> <A HREF="#s5">Alife &amp; Complex Systems</A></H2>

<UL>
<LI><A NAME="toc5.1">5.1</A> <A HREF="#ss5.1">Alife &amp; CS class/code libraries</A>
<LI><A NAME="toc5.2">5.2</A> <A HREF="#ss5.2">Alife &amp; CS software kits, applications, etc.</A>
</UL>
<P>
<H2><A NAME="toc6">6.</A> <A HREF="#s6">Agents &amp; Robotics</A></H2>

<UL>
<LI><A NAME="toc6.1">6.1</A> <A HREF="#ss6.1">Software Agents</A>
<LI><A NAME="toc6.2">6.2</A> <A HREF="#ss6.2">Robotics and Simulators</A>
</UL>
<P>
<H2><A NAME="toc7">7.</A> <A HREF="#s7">Statistical &amp; Machine Learning</A></H2>

<UL>
<LI><A NAME="toc7.1">7.1</A> <A HREF="#ss7.1">Libraries</A>
<LI><A NAME="toc7.2">7.2</A> <A HREF="#ss7.2">Applications</A>
</UL>
<P>
<H2><A NAME="toc8">8.</A> <A HREF="#s8">Programming languages</A></H2>

<P>
<H2><A NAME="toc9">9.</A> <A HREF="#s9">Missing &amp; Dead</A></H2>

<UL>
<LI><A NAME="toc9.1">9.1</A> <A HREF="#ss9.1">MIA - Projects missing linkage.</A>
<LI><A NAME="toc9.2">9.2</A> <A HREF="#ss9.2">Dead projects.</A>
</UL>
<HR>
<H2><A NAME="Introduction"></A> <A NAME="s1">1.</A> <A HREF="AI-Alife-HOWTO.html#toc1">Introduction</A></H2>



<H2><A NAME="ss1.1">1.1</A> <A HREF="AI-Alife-HOWTO.html#toc1.1">Purpose</A>
</H2>


<P>The GNU/Linux OS has evolved from its origins in hackerdom to a full
blown UNIX, capable of rivaling any commercial UNIX.  It now provides
an inexpensive base to build a great workstation.  It has shed its
hardware dependencies, having been ported to DEC Alphas, Sparcs,
PowerPCs, and many others.  This potential speed boost along with its
networking support will make it great for workstation clusters.  As a
workstation it allows for all sorts of research and development,
including artificial intelligence and artificial life.</P>

<P>The purpose of this Howto is to provide a source to find out
about various software packages, code libraries, and anything else
that will help someone get started working with (and find resources
for) artificial intelligence, artificial life, etc.  All done with
GNU/Linux specifically in mind.</P>

<H2><A NAME="ss1.2">1.2</A> <A HREF="AI-Alife-HOWTO.html#toc1.2">What's New</A>
</H2>


<P>
<UL>
<LI>v3.0 -

<P>New entries: 
<A HREF="#ORTS">ORTS</A>
, 
<A HREF="#FANN">FANN</A>
, 
<A HREF="#OpenCV">OpenCV</A>
,
<A HREF="#CBR Microprograms">CBR Microprograms</A>
, 
<A HREF="#ConceptNet">ConceptNet</A>
, 
<A HREF="#FreeHAL">FreeHAL</A>
,
<A HREF="#2APL">2APL</A>
, 
<A HREF="#Alchemy">Alchemy</A>
, 
<A HREF="#plop">plop</A>
, 
<A HREF="#evolver">evolver</A>
,
<A HREF="#PyIE">PyIE</A>
, 
<A HREF="#Pyevolve">Pyevolve</A>
, 
<A HREF="#txevolver">txevolver</A>
,
<A HREF="#python-dlp">python-dlp</A>
, 
<A HREF="#CompLearn">CompLearn</A>
, 
<A HREF="#dbacl">dbacl</A>
,
<A HREF="#Maximum Entropy Toolkit">Maximum Entropy Toolkit</A>
, 
<A HREF="#pebl">pebl</A>
, 
<A HREF="#FLiP">FLiP</A>
,
<A HREF="#Carmen">Carmen</A>
, 
<A HREF="#Orca">Orca</A>
, 
<A HREF="#ROS">ROS</A>
, 
<A HREF="#YARP">YARP</A>
,
<A HREF="#Neuroph">Neuroph</A>
, 
<A HREF="#MLAP book samples">MLAP book samples</A>
, 
<A HREF="#Elefant">Elefant</A>
,
<A HREF="#Evocosm">Evocosm</A>
, 
<A HREF="#Critterding">Critterding</A>
, 
<A HREF="#MRPT">MRPT</A>
,
<A HREF="#PyBrain">PyBrain</A>
, 
<A HREF="#peach">peach</A>
, 
<A HREF="#brain">brain</A>
, 
<A HREF="#FREVO">FREVO</A>
,
<A HREF="#Vowpal Wabbit">Vowpal Wabbit</A>
, 
<A HREF="#ERESYE">ERESYE</A>
, 
<A HREF="#Recast">Recast</A>
,
<A HREF="#EAP">EAP</A>
, 
<A HREF="#GenePool">GenePool</A>
, 
<A HREF="#Milk">Milk</A>
, 
<A HREF="#OpenCog">OpenCog</A>
,
<A HREF="#Pattern">Pattern</A>
, 
<A HREF="#CognitiveFoundry">CognitiveFoundry</A>
, 
<A HREF="#clasp">clasp</A>
,
<A HREF="#timbl">timbl</A>
, 
<A HREF="#MBT">MBT</A>
, 
<A HREF="#scikits.learn">scikits.learn</A>
,
<A HREF="#NeuroLab">NeuroLab</A>
, 
<A HREF="#Biogenesis">Biogenesis</A>
, 
<A HREF="#brain-simulator">brain-simulator</A>
.
<A HREF="#Torch5">Torch5</A>
, 
<A HREF="#Encog">Encog</A>
, 
<A HREF="#Nengo">Nengo</A>
,
<A HREF="#DEAP">DEAP</A>
 and 
<A HREF="#Emergent">Emergent</A>
.</P>

<P>Changed the name of the "Traditional" section to
<A HREF="#Symbolic Systems (GOFAI)">Symbolic Systems (GOFAI)</A>
. Added new section,
<A HREF="#Statistical &amp; Machine Learning">Statistical &amp; Machine Learning</A>
.</P>

<P>Seems someone has resuscitated 
<A HREF="#EMA-XPS">EMA-XPS</A>
. Not very active, but
enough to pull out of the dead projects area and place back amounst the
living. I also fixed many links and moved quite a few dead projects to
<A HREF="#Missing &amp; Dead">Missing &amp; Dead</A>
.</P>


</LI>
<LI>v2.4 -

<P>New entries: 
<A HREF="#Eprover">Eprover</A>
, 
<A HREF="#Player">Player</A>
, 
<A HREF="#Logfun">Logfun</A>
,
<A HREF="#Livingstone2">Livingstone2</A>
, 
<A HREF="#Quackle">Quackle</A>
, 
<A HREF="#LingPipe">LingPipe</A>
,
<A HREF="#GATE">GATE</A>
, 
<A HREF="#Infon Battle Arena">Infon Battle Arena</A>
, 
<A HREF="#CLARAty">CLARAty</A>
,
<A HREF="#Reverend">Reverend</A>
, 
<A HREF="#Shogun">Shogun</A>
, 
<A HREF="#Nanopond">Nanopond</A>
,
<A HREF="#Polyworld">Polyworld</A>
, 
<A HREF="#Fluidiom">Fluidiom</A>
, 
<A HREF="#NEAT">NEAT</A>
,
<A HREF="#Framsticks">Framsticks</A>
, 
<A HREF="#URBI">URBI</A>
, 
<A HREF="#RobotFlow">RobotFlow</A>
,
<A HREF="#Nero">Nero</A>
, 
<A HREF="#ffnet">ffnet</A>
, 
<A HREF="#Alloy">Alloy</A>
,
<A HREF="#Pyke">Pyke</A>
, 
<A HREF="#NuPIC">NuPIC</A>
, 
<A HREF="#Simbad">Simbad</A>
, 
<A HREF="#Robodeb">Robodeb</A>
,
<A HREF="#Loom">Loom</A>
, 
<A HREF="#PowerLoom">PowerLoom</A>
, 
<A HREF="#tinygp">tinygp</A>
,
<A HREF="#Curry">Curry</A>
, 
<A HREF="#JGAP">JGAP</A>
, 
<A HREF="#PyCLIPS">PyCLIPS</A>
,
and 
<A HREF="#STELLA">STELLA</A>
.</P>

<P>I chopped the Agents section into two sub-sections, one for 
<A HREF="#Software Agents">Software Agents</A>
 and one for 
<A HREF="#Robotics and Simulators">Robotics and Simulators</A>
. I
play it a bit fast and loose in my deciding what goes into each category,
but it is an improvement.</P>

<P>MIA found! 
<A HREF="#Cellular">Cellular</A>
 the cellular automata programming system.
Fixed many bad links and cleaned out missing projects.</P>

</LI>
<LI>v2.3 -

<P>New entries: 
<A HREF="#Yampa">Yampa</A>
, 
<A HREF="#pygene">pygene</A>
, 
<A HREF="#Push">Push</A>
,
<A HREF="#ANNEvolve">ANNEvolve</A>
, 
<A HREF="#dgpf">dgpf</A>
, 
<A HREF="#Golly">Golly</A>
,
<A HREF="#IBAL">IBAL</A>
, 
<A HREF="#3APL">3APL</A>
, 
<A HREF="#OSCAR">OSCAR</A>
,
and 
<A HREF="#RobocodeNG">RobocodeNG</A>
.</P>

<P>Updated information for some entries including 
<A HREF="#Yale">Yale</A>
,
<A HREF="#Joone">Joone</A>
, 
<A HREF="#Drone">Drone</A>
, 
<A HREF="#Biome">Biome</A>
, 
<A HREF="#ECLiPSe">ECLiPSe</A>
,
<A HREF="#Xtoys">Xtoys</A>
, 
<A HREF="#GECO">GECO</A>
,
<A HREF="#Creatures Docking Station">Creatures Docking Station</A>
 and others.</P>

<P>I also changed the MIA section to 
<A HREF="#Missing &amp; Dead">Missing &amp; Dead</A>
 which now
groups into subsections entries with bad links that I can't find
replacements for and long dead projects.</P>

</LI>
<LI>v2.2 -

<P>Fixed a some bad links and was forced to move a few entries into
the MIA (missing) section. I also removed one duplicate entry.</P>

<P>New entries: 
<A HREF="#MASON">MASON</A>
, 
<A HREF="#spyse">spyse</A>
, 
<A HREF="#AntWars">AntWars</A>
,
<A HREF="#OpenSteer">OpenSteer</A>
, 
<A HREF="#Pyro">Pyro</A>
, 
<A HREF="#Robocode">Robocode</A>
,
<A HREF="#Trend">Trend</A>
 and 
<A HREF="#Open BEAGLE">Open BEAGLE</A>
.</P>

</LI>
<LI>v2.1 - 

<P>New entries: 
<A HREF="#NLTK">NLTK</A>
, 
<A HREF="#NEURObjects">NEURObjects</A>
, 
<A HREF="#KANREN">KANREN</A>
,
<A HREF="#Neural Networks at your Fingertips">Neural Networks at your Fingertips</A>
, 
<A HREF="#SimWorld">SimWorld</A>
,
<A HREF="#SimAgent">SimAgent</A>
, 
<A HREF="#Fuzzy sets for Ada">Fuzzy sets for Ada</A>
, 
<A HREF="#maxent">maxent</A>
,
<A HREF="#Evo">Evo</A>
, 
<A HREF="#breve">breve</A>
 and 
<A HREF="#AJA">AJA</A>
</P>


</LI>
<LI>v2.0 - Ran linkchecker and for any bad links I either found a new
link or removed the item. See the new section MIA for a list of the removed
entries (please let me know if you know of a new home for them).

<P>New entries: 
<A HREF="#Yale">Yale</A>
, 
<A HREF="#DIET Agents">DIET Agents</A>
, 
<A HREF="#JASA">JASA</A>
,
<A HREF="#Jason">Jason</A>
, 
<A HREF="#Noble Ape">Noble Ape</A>
, 
<A HREF="#Maude">Maude</A>
,
<A HREF="#ECLiPSe">ECLiPSe</A>
, 
<A HREF="#lush">lush</A>
, and 
<A HREF="#pygp">pygp</A>
</P>

</LI>
<LI>v1.9 - One new entry (
<A HREF="#Bond">Bond</A>
) and fixed the link below
to the dynamic list (now defunct). 
</LI>
<LI>v1.8 - Cleaned up bad links, finding new ones where possible and
eliminating those that seem to have disappeared. Quite a few new entries as
well.

<P>New entries: 
<A HREF="#Torch">Torch</A>
, 
<A HREF="#Aleph">Aleph</A>
, 
<A HREF="#AI Kernel">AI Kernel</A>
,
<A HREF="#OpenCyc">OpenCyc</A>
, 
<A HREF="#HTK">HTK</A>
, 
<A HREF="#FFLL">FFLL</A>
, 
<A HREF="#JCK">JCK</A>
, 
<A HREF="#Joone">Joone</A>
, 
<A HREF="#scnANNlib">scnANNlib</A>
, 
<A HREF="#GAUL">GAUL</A>
, 
<A HREF="#Cougaar">Cougaar</A>
, and 
<A HREF="#RoboTournament">RoboTournament</A>
</P>

</LI>
<LI>v1.7 - Another 9 new entries, a bunch of links fixed, and a few items
removed that have vanished from the net.

<P>New entries: 
<A HREF="#SPASS">SPASS</A>
, 
<A HREF="#CNNs">CNNs</A>
, 
<A HREF="#JCASim">JCASim</A>
,
<A HREF="#Genetic">Genetic</A>
, 
<A HREF="#CAGE">CAGE</A>
, 
<A HREF="#AgentFarms">AgentFarms</A>
,
<A HREF="#MATREM">MATREM</A>
, 
<A HREF="#OAA">OAA</A>
, and
<A HREF="#UTCS">UTCS Neural Nets Research Group Software</A></P>

</LI>
<LI>v1.6 - 9 new entries, a couple link fixes and one duplicate item
removed.</LI>
<LI>v1.5 - 26 new entries plus a couple link fixes.</LI>
<LI>v1.4 - 10 new updates and fixed some lisp-related links.</LI>
<LI>v1.3 - Putting a dent in the backlog, I added 30+ new entries today
and submitted it to the LDP.</LI>
<LI>Previous records were in a mixed format with site updates. See the
<A HREF="http://zhar.net/howto/oldnotes/">old notes</A>
section of the master site for them.</LI>
</UL>
</P>

<H2><A NAME="ss1.3">1.3</A> <A HREF="AI-Alife-HOWTO.html#toc1.3">Where to find this software</A>
</H2>


<P>All this software should be available via the net (ftp || http).  The
links to where to find it will be provided in the description of each
package.  There will also be plenty of software not covered on these
pages (which is usually platform independent) located on one of the
resources listed on the 
<A HREF="http://zhar.net/howto/ai_links/">links section</A> of the Master Site (given above).</P>


<H2><A NAME="ss1.4">1.4</A> <A HREF="AI-Alife-HOWTO.html#toc1.4">Updates and comments</A>
</H2>


<P>If you find any mistakes, know of updates to one of the items below,
or have problems compiling any of the applications, please mail me at:
<A HREF="mailto:jae@zhar.net">jae@zhar.net</A>
and I'll see what I can do.</P>

<P>If you know of any AI/Alife applications, class libraries,
etc. <B>Please</B> 
<A HREF="mailto:jae@zhar.net"> email me</A>
about them. Include your name, ftp and/or http sites where they can be
found, plus a brief overview/commentary on the software (this info
would make things a lot easier on me... but don't feel obligated ;).</P>

<P>I know that keeping this list up to date and expanding it will take quite
a bit of work. So please be patient (I do have other projects). I hope you
will find this document helpful.</P>

<H2><A NAME="ss1.5">1.5</A> <A HREF="AI-Alife-HOWTO.html#toc1.5">Copyright/License</A>
</H2>

<P>Copyright (c) 1996-2009 John A. Eikenberry</P>
<P>LICENSE</P>
<P>This document may be reproduced and distributed in whole or in part, in
any medium physical or electronic, provided that this license notice is
displayed in the reproduction. Commercial redistribution is permitted and
encouraged. Thirty days advance notice, via email to the author, of
redistribution is appreciated, to give the authors time to provide updated
documents.</P>
<P>A. REQUIREMENTS OF MODIFIED WORKS</P>
<P>All modified documents, including translations, anthologies, and partial
documents, must meet the following requirements:</P>

<P>
<UL>
<LI>The modified version must be labeled as such.</LI>
<LI>The person making the modifications must be identified.</LI>
<LI>Acknowledgement of the original author must be retained.</LI>
<LI>The location of the original unmodified document be identified.</LI>
<LI>The original author's name(s) may not be used to assert or imply
endorsement of the resulting document without the original author's
permission.</LI>
</UL>
</P>
<P>In addition it is requested (not required) that:</P>
<P>
<UL>
<LI>The modifications (including deletions) be noted.</LI>
<LI>The author be notified by email of the modification in advance of
redistribution, if an email address is provided in the document.</LI>
</UL>
</P>
<P>As a special exception, anthologies of LDP documents may include a single
copy of these license terms in a conspicuous location within the anthology
and replace other copies of this license with a reference to the single
copy of the license without the document being considered "modified" for
the purposes of this section.</P>
<P>Mere aggregation of LDP documents with other documents or programs on the
same media shall not cause this license to apply to those other works.</P>
<P>All translations, derivative documents, or modified documents that
incorporate this document may not have more restrictive license terms
than these, except that you may require distributors to make the resulting
document available in source format.</P>

<HR>
<H2><A NAME="Symbolic Systems (GOFAI)"></A> <A NAME="s2">2.</A> <A HREF="AI-Alife-HOWTO.html#toc2">Symbolic Systems (GOFAI)</A>    </H2>


<P>Traditionally AI was based around the ideas of logic, rule systems,
linguistics, and the concept of rationality. At its roots are programming
languages such as Lisp and Prolog though newer systems tend to use more
popular procedural languages. Expert systems are the largest successful
example of this paradigm.  An expert system consists of a detailed
knowledge base and a complex rule system to utilize it. Such systems have
been used for such things as medical diagnosis support and credit checking
systems.</P>


<H2><A NAME="ss2.1">2.1</A> <A HREF="AI-Alife-HOWTO.html#toc2.1">AI class/code libraries</A>
    </H2>


<P>These are libraries of code or classes for use in programming within
the artificial intelligence field.  They are not meant as stand alone
applications, but rather as tools for building your own applications.</P>
<P>
<DL>
<P>
<A NAME="ACL2"></A> </P>
<DT><B>ACL2</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cliki.net/ACL2">www.cliki.net/ACL2</A></LI>
</UL>
</P>
<P>ACL2 (A Computational Logic for Applicative Common Lisp) is a theorem
prover for industrial applications. It is both a mathematical logic and
a system of tools for constructing proofs in the logic.  ACL2 works
with GCL (GNU Common Lisp).</P>

<P>
<A NAME="AI Kernel"></A> </P>
<DT><B>AI Kernel</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://aikernel.sourceforge.net/">aikernel.sourceforge.net</A></LI>
<LI>Sourceforge site: 
<A HREF="http://sourceforge.net/projects/aikernel/">sourceforge.net/projects/aikernel/</A></LI>
</UL>
</P>
<P>The AI Kernel is a re-usable artificial intelligence engine that uses
natural language processing and an Activator / Context model to allow
multi tasking between installed cells.</P>

<P>
<A NAME="AI Search II"></A>  </P>
<DT><B>AI Search II</B><DD><P>
<UL>
<LI>WEB site: 
<A HREF="http://www.neiu.edu/~kwtracy/ooai-book/">http://www.neiu.edu/~kwtracy/ooai-book/</A></LI>
</UL>
</P>
<P>Basically, the library offers the programmer a set of search
algorithms that may be used to solve all kind of different
problems. The idea is that when developing problem solving software
the programmer should be able to concentrate on the representation of
the problem to be solved and should not need to bother with the
implementation of the search algorithm that will be used to actually
conduct the search. This idea has been realized by the implementation
of a set of search classes that may be incorporated in other software
through <B>C++</B>'s features of derivation and inheritance.  The
following search algorithms have been implemented:</P>

<P>
<UL>
<LI>depth-first tree and graph search.</LI>
<LI>breadth-first tree and graph search.</LI>
<LI>uniform-cost tree and graph search.</LI>
<LI>best-first search.</LI>
<LI>bidirectional depth-first tree and graph search.</LI>
<LI>bidirectional breadth-first tree and graph search.</LI>
<LI>AND/OR depth tree search.</LI>
<LI>AND/OR breadth tree search.</LI>
</UL>
</P>

<P>This library has a corresponding book, "
<A HREF="http://www.neiu.edu/~kwtracy/ooai-book/">Object-Oriented Artificial Intelligence, Using C++</A>".</P>

<P>
<A NAME="Alchemy"></A> </P>
<DT><B>Alchemy</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://alchemy.cs.washington.edu/">http://alchemy.cs.washington.edu/</A></LI>
</UL>
</P>
<P>Alchemy is a software package providing a series of algorithms for
statistical relational learning and probabilistic logic inference,
based on the Markov logic representation. Alchemy allows you to easily
develop a wide range of AI applications, including:</P>
<P>
<UL>
<LI>Collective classification</LI>
<LI>Link prediction</LI>
<LI>Entity resolution</LI>
<LI>Social network modeling</LI>
<LI>Information extraction</LI>
</UL>
</P>

<P>
<A NAME="Aleph"></A> </P>
<DT><B>Aleph</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.ox.ac.uk/activities/machlearn/Aleph/">http://www.cs.ox.ac.uk/activities/machlearn/Aleph/</A></LI>
</UL>
</P>
<P>This document provides reference information on A Learning Engine for
Proposing Hypotheses (Aleph). Aleph is an Inductive Logic Programming
(ILP) system. Aleph is intended to be a prototype for exploring ideas.
Aleph is an ILP algorithm implemented in Prolog by Dr Ashwin
Srinivasan at the Oxford University Computing Laboratory, and is
written specifically for compilation with the YAP Prolog compiler</P>

<P>
<A NAME="CBR Microprograms"></A> </P>
<DT><B>Microprograms</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.indiana.edu/~leake/cbr/code/">http://www.cs.indiana.edu/~leake/cbr/code/</A></LI>
</UL>
</P>
<P>A collection of case-based reasoning "micro" versions of dissertation
programs that were developed for pedagogical purposes. These programs
are meant to distill key aspects of the original programs into a form
that can be easily understood, modified, and extended.</P>

<P>
<A NAME="Chess In List"></A> </P>
<DT><B>Chess In Lisp (CIL)</B><DD><P>
<UL>
<LI>Web site: *found as part of the CLOCC archive at: 
<A HREF="http://clocc.sourceforge.net/">clocc.sourceforge.net</A></LI>
</UL>
</P>
<P>The CIL (Chess In Lisp) foundation is a Common Lisp
implementaion of all the core functions needed for development
of chess applications.  The main purpose of the CIL project is
to get AI researchers interested in using Lisp to work in the
chess domain.</P>

<P>
<A NAME="clasp"></A> </P>
<DT><B>clasp</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.uni-potsdam.de/clasp/">http://www.cs.uni-potsdam.de/clasp/</A></LI>
</UL>
</P>
<P>clasp is an answer set solver for (extended) normal logic programs. It
combines the high-level modeling capacities of answer set programming
(ASP) with state-of-the-art techniques from the area of Boolean
constraint solving. The primary clasp algorithm relies on
conflict-driven nogood learning, a technique that proved very
successful for satisfiability checking (SAT). Unlike other learning ASP
solvers, clasp does not rely on legacy software, such as a SAT solver
or any other existing ASP solver.  Rather, clasp has been genuinely
developed for answer set solving based on conflict-driven nogood
learning. clasp can be applied as an ASP solver (on LPARSE output
format), as a SAT solver (on simplified DIMACS/CNF format), or as a PB
solver (on OPB format).</P>

<P>
<A NAME="ConceptNet"></A> </P>
<DT><B>ConceptNet</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://conceptnet.media.mit.edu/">http://conceptnet.media.mit.edu/</A></LI>
<LI>Old Web site: 
<A HREF="http://web.media.mit.edu/~hugo/conceptnet/">http://web.media.mit.edu/~hugo/conceptnet/</A></LI>
</UL>
</P>
<P>ConceptNet aims to give computers access to common-sense knowledge, the
kind of information that ordinary people know but usually leave
unstated. The data in ConceptNet was collected from ordinary people who
contributed it over the Web. ConceptNet represents this data in the
form of a semantic network, and makes it available to be used in
natural language processing and intelligent user interfaces.</P>
<P>This API provides Python code with access to both ConceptNet 3 and the
development database that will become ConceptNet 4, and the natural
language tools necessary to work with it. It uses Django for
interacting with the database.</P>

<P>
<A NAME="ERESYE"></A> </P>
<DT><B>ERESYE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/eresye/">http://sourceforge.net/projects/eresye/</A></LI>
<LI>Tutorial: 
<A HREF="http://www.trapexit.org/Artificial_Intelligence_with_Erlang:_the_Domain_of_Relatives">http://www.trapexit.org/Artificial_Intelligence_with_Erlang:_the_Domain_of_Relatives</A></LI>
</UL>
</P>
<P>ERESYE means ERlang Expert SYstem Engine. It is a library to write
expert systems and rule processing engines using the Erlang programming
language. It allows to create multiple engines, each one with its own
facts and rules to be processed.</P>

<P>
<A NAME="FFLL"></A> </P>
<DT><B>FFLL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ffll.sourceforge.net/">ffll.sourceforge.net</A></LI>
</UL>
</P>
<P>The Free Fuzzy Logic Library (FFLL) is an open source fuzzy logic class
library and API that is optimized for speed critical applications, such
as video games. FFLL is able to load files that adhere to the  IEC
61131-7 standard.</P>

<P>
<A NAME="FLiP"></A> </P>
<DT><B>FLiP</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://staff.washington.edu/jon/flip/www/">http://staff.washington.edu/jon/flip/www/</A></LI>
</UL>
</P>
<P>Flip is a logical framework written in Python. A logical framework is a
library for defining logics and writing applications such as theorem
provers. The checker can use different logics; Flip comes with several.
You can add another logic, or add axioms and derived rules, by writing
a module in Python. Python is both the object language and the
metalanguage. Formulas, inference rules, and entire proofs are Python
expressions. Prover commands are Python functions.</P>

<P>
<A NAME="Fuzzy sets for Ada"></A> </P>
<DT><B>Fuzzy sets for Ada</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.dmitry-kazakov.de/ada/fuzzy.htm">http://www.dmitry-kazakov.de/ada/fuzzy.htm</A></LI>
<LI>Freshmeat: 
<A HREF="http://freshmeat.net/projects/fuzzy/">http://freshmeat.net/projects/fuzzy/</A></LI>
</UL>
</P>
<P>Fuzzy sets for Ada is a library providing implementations of confidence
factors with the operations not, and, or, xor, +, and *, classical
fuzzy sets with the set-theoretic operations and the operations of the
possibility theory, intuitionistic fuzzy sets with the operations on
them, fuzzy logic based on the intuitionistic fuzzy sets and the
possibility theory; fuzzy numbers, both integer and floating-point with
conventional arithmetical operations, and linguistic variables and sets
of linguistic variables with operations on them.  String-oriented I/O
is supported.</P>

<P>
<A NAME="HTK"></A> </P>
<DT><B>HTK</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://htk.eng.cam.ac.uk/">htk.eng.cam.ac.uk</A></LI>
</UL>
</P>
<P>The Hidden Markov Model Toolkit (HTK) is a portable toolkit for
building and manipulating hidden Markov models.  HTK consists of a set
of library modules and tools available in C source form. The tools
provide sophisticated facilities for speech analysis, HMM training,
testing and results analysis. The software supports HMMs using both
continuous density mixture Gaussians and discrete distributions and can
be used to build complex HMM systems.  The HTK release contains
extensive documentation and examples.</P>

<P>
<A NAME="JCK"></A> </P>
<DT><B>JCK</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.pms.informatik.uni-muenchen.de/software/jack/">www.pms.informatik.uni-muenchen.de/software/jack/</A></LI>
</UL>
</P>
<P>JCK is a new library providing constraint programming and search for
Java.
<UL>
<LI>JCK consists of three components:</LI>
<LI>- JCHR: Java Constraint Handling Rules.
A high-level language to write constraint solvers.</LI>
<LI>- JASE: Java Abstract Search Engine.
A generic search engine for JCHR to solve constraint 
problems.</LI>
<LI>- VisualCHR:
An interactive tool to visualize JCHR computations.</LI>
</UL>

Source and documentation available from link above.</P>

<P>
<A NAME="KANREN"></A> </P>
<DT><B>KANREN</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://kanren.sourceforge.net/">kanren.sourceforge.net</A></LI>
</UL>
</P>
<P>KANREN is a declarative logic programming system with first-class
relations, embedded in a pure functional subset of Scheme. The system
has a set-theoretical semantics, true unions, fair scheduling,
first-class relations, lexically-scoped logical variables, depth-first
and iterative deepening strategies. The system achieves high
performance and expressivity without cuts.</P>

<P>
<A NAME="LK"></A> </P>
<DT><B>LK</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.utoronto.ca/~neto/research/lk/">www.cs.utoronto.ca/~neto/research/lk/</A></LI>
</UL>
</P>
<P>LK is an implementation of the Lin-Kernighan heuristic for the
Traveling Salesman Problem and for the minimum weight perfect matching
problem. It is tuned for 2-d geometric instances, and has been applied
to certain instances with up to a million cities. Also included are
instance generators and Perl scripts for munging TSPLIB instances. </P>
<P>This implementation introduces ``efficient cluster compensation'', an
experimental algorithmic technique intended to make the Lin-Kernighan
heuristic more robust in the face of clustered data.</P>

<P>
<A NAME="LingPipe"></A> </P>
<DT><B>LingPipe</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://alias-i.com/lingpipe/">http://alias-i.com/lingpipe/</A></LI>
</UL>
</P>
<P>LingPipe is a state-of-the-art suite of natural language processing
tools written in Java that performs tokenization, sentence detection,
named entity detection, coreference resolution, classification,
clustering, part-of-speech tagging, general chunking, fuzzy dictionary
matching.</P>

<P>
<A NAME="Logfun"></A> </P>
<DT><B>Logfun</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.irisa.fr/lande/ferre/logfun/">http://www.irisa.fr/lande/ferre/logfun/</A></LI>
</UL>
</P>
<P>Logfun is a library of logic functors. A logic functor is a
function that can be applied to zero, one or several logics so as
to produce a new logic as a combination of argument logics. Each
argument logic can itself be built by combination of logic
functors. The signature of a logic is made of a parser and a
printer of formulas, logical operations such as a theorem prover
for entailment between formulas, and more specific operations
required by Logical Information Systems (LIS). Logic functors can
be concrete domains like integers, strings, or algebraic
combinators like product or sum of logics.</P>
<P>Logic functors are coded as Objective Caml modules. A logic
semantics is associated to each of these logic functors. This
enables to define properties of logics like the consistency and
completeness of the entailment prover, and to prove under which
conditions a generated entailement prover satisfies these
properties given the properties of argument logics.</P>

<P>
<A NAME="Loom"></A> </P>
<DT><B>Loom</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.isi.edu/isd/LOOM/">http://www.isi.edu/isd/LOOM/</A></LI>
</UL>
</P>
<P>* Note: Loom has been succeeded by 
<A HREF="#PowerLoom">PowerLoom</A>
.</P>
<P>Loom is a language and environment for constructing intelligent
applications. The heart of Loom is a knowledge representation system
that is used to provide deductive support for the declarative portion
of the Loom language. Declarative knowledge in Loom consists of
definitions, rules, facts, and default rules. A deductive engine called
a classifier utilizes forward-chaining, semantic unification and
object-oriented truth maintainance technologies in order to compile the
declarative knowledge into a network designed to efficiently support
on-line deductive query processing.</P>
<P>The Loom system implements a logic-based pattern matcher that drives a
production rule facility and a pattern-directed method dispatching
facility that supports the definition of object-oriented methods. The
high degree of integration between Loom's declarative and procedural
components permits programmers to utilize logic programming, production
rule, and object-oriented programming paradigms in a single
application. Loom can also be used as a deductive layer that overlays
an ordinary CLOS network. In this mode, users can obtain many of the
benefits of using Loom without impacting the function or performance of
their CLOS-based applications.</P>

<P>
<A NAME="maxent"></A> </P>
<DT><B>maxent</B><DD><P>
<UL>
<LI>Python/C++ version: 
<A HREF="http://homepages.inf.ed.ac.uk/lzhang10/maxent_toolkit.html">http://homepages.inf.ed.ac.uk/lzhang10/maxent_toolkit.html</A></LI>
<LI>Java version: 
<A HREF="http://maxent.sourceforge.net/">maxent.sourceforge.net</A></LI>
</UL>
</P>
<P>The Maximum Entropy Toolkit provides a set of tools and library for
constructing maximum entropy (maxent) models in either Python or C++.
Maxent Entropy Model is a general purpose machine learning framework
that has proved to be highly expressive and powerful in statistical
natural language processing, statistical physics, computer vision and
many other fields.</P>
<P>It features conditional maximum entropy models, L-BFGS and GIS
parameter estimation, Gaussian Prior smoothing, a C++ API, a Python
extension module, a command line utility, and good documentation. A
Java version is also available.</P>

<P>
<A NAME="Nyquist"></A>  </P>
<DT><B>Nyquist</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-2.cs.cmu.edu/~music/nyquist/">www-2.cs.cmu.edu/~music/nyquist/</A></LI>
</UL>
</P>
<P>The Computer Music Project at CMU is developing computer music
and interactive performance technology to enhance human musical
experience and creativity. This interdisciplinary effort draws
on Music Theory, Cognitive Science, Artificial Intelligence and
Machine Learning, Human Computer Interaction, Real-Time Systems,
Computer Graphics and Animation, Multimedia, Programming
Languages, and Signal Processing. A paradigmatic example of
these interdisciplinary efforts is the creation of interactive
performances that couple human musical improvisation with
intelligent computer agents in real-time.</P>

<P>
<A NAME="OpenCyc"></A> </P>
<DT><B>OpenCyc</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.opencyc.org/">http://www.opencyc.org/</A></LI>
<LI>Alt Web site: 
<A HREF="http://sourceforge.net/projects/opencyc/">http://sourceforge.net/projects/opencyc/</A></LI>
</UL>
</P>
<P>OpenCyc is the open source version of Cyc, the largest and most
complete general knowledge base and commonsense reasoning engine. An
ontology based on 6000 concepts and 60000 assertions about them.</P>

<P>
<A NAME="Pattern"></A> </P>
<DT><B>Pattern</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.clips.ua.ac.be/pages/pattern">http://www.clips.ua.ac.be/pages/pattern</A></LI>
</UL>
</P>
<P>Pattern is a web mining module for the Python programming language. It
bundles tools for data retrieval (Google + Twitter + Wikipedia API, web
spider, HTML DOM parser), text analysis (rule-based shallow parser,
WordNet interface, syntactical + semantical n-gram search algorithm,
tf-idf + cosine similarity + LSA metrics) and data visualization (graph
networks).</P>

<P>
<A NAME="PowerLoom"></A> </P>
<DT><B>PowerLoom</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.isi.edu/isd/LOOM/PowerLoom/">http://www.isi.edu/isd/LOOM/PowerLoom/</A></LI>
</UL>
</P>
<P>PowerLoom is the successor to the 
<A HREF="#Loom">Loom</A>
 knowledge
representation system. It provides a language and environment for
constructing intelligent, knowledge-based applications. PowerLoom uses
a fully expressive, logic-based representation language (a variant of
KIF). It uses a natural deduction inference engine that combines
forward and backward chaining to derive what logically follows from the
facts and rules asserted in the knowledge base. While PowerLoom is not
a description logic, it does have a description classifier which uses
technology derived from the Loom classifier to classify descriptions
expressed in full first order predicate calculus (see paper). PowerLoom
uses modules as a structuring device for knowledge bases, and
ultra-lightweight worlds to support hypothetical reasoning.</P>
<P>To implement PowerLoom we developed a new programming language called
<A HREF="#STELLA">STELLA</A>
, which is a Strongly Typed, Lisp-like LAnguage that
can be translated into Lisp, C++ and Java. PowerLoom is written in
STELLA and therefore available in Common-Lisp, C++ and Java versions. </P>

<P>
<A NAME="PyCLIPS"></A> </P>
<DT><B>PyCLIPS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pyclips.sourceforge.net/web/">http://pyclips.sourceforge.net/web/</A></LI>
</UL>
</P>
<P>PyCLIPS is an extension module for the Python language that embeds full
CLIPS functionality in Python applications. This means that you can
provide Python with a strong, reliable, widely used and well documented
inference engine.</P>

<P>
<A NAME="Pyke"></A> </P>
<DT><B>Pyke</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pyke.sourceforge.net/">http://pyke.sourceforge.net/</A></LI>
</UL>
</P>
<P>Pyke is a knowledge-based inference engine (expert system) written in
100% python that can:</P>
<P>
<UL>
<LI> Do both forward-chaining (data driven) and backward-chaining
(goal directed) inferencing.
<UL>
<LI> Pyke may be embedded into any python program.</LI>
</UL>

</LI>
<LI> Automatically generate python programs by assembling
individual python functions into complete call graphs.

<UL>
<LI> This is done through a unique design where the individual
python functions are attached to backward-chaining rules.
</LI>
<LI> Unlike other approaches to code reuse (e.g. Zope adapters
and generic functions), this allows the inference engine to ensure
that all of the function's requirements are completely satisfied,
by examining the entire call graph down to the leaves, before any
of the functions are executed.
</LI>
<LI> This is an optional feature. You don't need to use it if you
just want the inferencing capability by itself.
</LI>
</UL>
</LI>
</UL>
</P>

<P>
<A NAME="python-dlp"></A> </P>
<DT><B>python-dlp</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://code.google.com/p/python-dlp/">http://code.google.com/p/python-dlp/</A></LI>
</UL>
</P>
<P>python-dlp aims to be a contemporary expert system based on the
Semantic Web technologies. Traditionally, expert systems are an
application of computing and artificial intelligence with the aim
of supporting software that attempts to reproduce the deterministic
behavior of one or more human experts in a specific problem domain. 
It utilizes the efficient RETE_UL algorithm as the 'engine' for the
expert system</P>

<P>
<A NAME="Reverend"></A> </P>
<DT><B>Reverend</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/reverend/">http://sourceforge.net/projects/reverend/</A></LI>
</UL>
</P>
<P>Reverned is a general purpose Bayesian classifier written in Python. It
is designed to be easily extended to any application domain.</P>

<P>
<A NAME="Screamer"></A> </P>
<DT><B>Screamer</B><DD><P>
<UL>
<LI>Latest version is part of CLOCC: 
<A HREF="http://clocc.sourceforge.net/">clocc.sourceforge.net</A></LI>
</UL>
</P>
<P>Screamer is an extension of Common Lisp that adds support for
nondeterministic programming. Screamer consists of two
levels. The basic nondeterministic level adds support for
backtracking and undoable side effects.  On top of this
nondeterministic substrate, Screamer provides a comprehensive
constraint programming language in which one can formulate and
solve mixed systems of numeric and symbolic
constraints. Together, these two levels augment Common Lisp with
practically all of the functionality of both Prolog and
constraint logic programming languages such as CHiP and CLP(R).
Furthermore, Screamer is fully integrated with Common
Lisp. Screamer programs can coexist and interoperate with other
extensions to Common Lisp such as CLOS, CLIM and Iterate.</P>

<P>
<A NAME="SPASS"></A> </P>
<DT><B>SPASS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.spass-prover.org/">http://www.spass-prover.org/</A></LI>
</UL>
</P>
<P>SPASS: An Automated Theorem Prover for First-Order Logic with Equality</P>
<P>If you are interested in first-order logic theorem proving, the formal
analysis of software, systems, protocols, formal approaches to AI
planning, decision procedures, modal logic theorem proving, SPASS may
offer you the right functionality.</P>

<P>
<A NAME="Torch"></A> </P>
<DT><B>Torch</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.torch.ch/">www.torch.ch</A></LI>
<LI>Successor: 
<A HREF="#Torch5">Torch5</A>
</LI>
</UL>
</P>
<P>Torch is a machine-learning library, written in C++.  Its aim is to
provide the state-of-the-art of the best algorithms.  It is, and it
will be, in development forever.</P>
<P>
<UL>
<LI>Many gradient-based methods, including multi-layered
perceptrons, radial basis functions, and mixtures of experts.  Many
small "modules" (Linear module, Tanh module, SoftMax module, ...)
can be plugged together.
</LI>
<LI>Support Vector Machine, for classification and regression.
</LI>
<LI>Distribution package, includes Kmeans, Gaussian Mixture
Models, Hidden Markov Models, and Bayes Classifier, and classes for
speech recognition with embedded training.
</LI>
<LI>Ensemble models such as Bagging and Adaboost.
</LI>
<LI>Non-parametric models such as K-nearest-neighbors, Parzen
Regression and Parzen Density Estimator.
</LI>
<LI></LI>
</UL>
</P>
<P>Torch is an open library whose authors encourage everybody to develop
new packages to be included in future versions on the official website.</P>

</DL>
</P>


<H2><A NAME="ss2.2">2.2</A> <A HREF="AI-Alife-HOWTO.html#toc2.2">AI software kits, applications, etc.</A>
    </H2>


<P>These are various applications, software kits, etc. meant for research
in the field of artificial intelligence. Their ease of use will vary,
as they were designed to meet some particular research interest more
than as an easy to use commercial package.</P>
<P>
<DL>
<P>
<A NAME="ASA"></A> </P>
<DT><B>ASA - Adaptive Simulated Annealing</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ingber.com/#ASA-CODE">http://www.ingber.com/#ASA-CODE</A></LI>
</UL>
</P>

<P>ASA (Adaptive Simulated Annealing) is a powerful global
optimization C-code algorithm especially useful for nonlinear and/or
stochastic systems.</P>
<P>ASA is developed to statistically find the best global fit of a
nonlinear non-convex cost-function over a D-dimensional space. This
algorithm permits an annealing schedule for 'temperature' T decreasing
exponentially in annealing-time k, T = T_0 exp(-c k^1/D).
The introduction of re-annealing also permits adaptation to changing
sensitivities in the multi-dimensional parameter-space. This annealing
schedule is faster than fast Cauchy annealing, where T = T_0/k,
and much faster than Boltzmann annealing, where T = T_0/ln k.</P>

<P>
<A NAME="Babylon"></A> </P>
<DT><B>Babylon</B><DD><P>
<UL>
<LI>Archive: 
<A HREF="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/expert/systems/babylon/">http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/expert/systems/babylon/</A></LI>
</UL>
</P>
<P>BABYLON is a modular, configurable, hybrid environment for
developing expert systems. Its features include objects, rules with
forward and backward chaining, logic (Prolog) and constraints. BABYLON
is implemented and embedded in Common Lisp.</P>

<P>
<A NAME="cfengine"></A> </P>
<DT><B>cfengine</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.iu.hio.no/cfengine/">www.iu.hio.no/cfengine/</A></LI>
</UL>
</P>
<P>Cfengine, or the configuration engine is a very high level language for
building expert systems which administrate and configure large computer
networks. Cfengine uses the idea of classes and a primitive form of
intelligence to define and automate the configuration of large systems
in the most economical way possible. Cfengine is design to be a part of
computer immune systems.</P>

<P>
<A NAME="CLIPS"></A> </P>
<DT><B>CLIPS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://clipsrules.sourceforge.net/">http://clipsrules.sourceforge.net/</A></LI>
</UL>
</P>
<P>CLIPS is a productive development and delivery expert system tool
which provides a complete environment for the construction of rule
and/or object based expert systems.</P>
<P>CLIPS provides a cohesive tool for handling a wide variety of
knowledge with support for three different programming paradigms:
rule-based, object-oriented and procedural.  Rule-based programming
allows knowledge to be represented as heuristics, or "rules of thumb,"
which specify a set of actions to be performed for a given
situation. Object-oriented programming allows complex systems to be
modeled as modular components (which can be easily reused to model
other systems or to create new components).  The procedural
programming capabilities provided by CLIPS are similar to capabilities
found in languages such as C, Pascal, Ada, and LISP.</P>

<P>
<A NAME="EMA-XPS"></A> </P>
<DT><B>EMA-XPS - A Hybrid Graphic Expert System Shell</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ema-xps.org/">http://ema-xps.org/</A></LI>
</UL>
</P>
<P>EMA-XPS is a hybrid graphic expert system shell based on the
ASCII-oriented shell Babylon 2.3 of the German National Research
Center for Computer Sciences (GMD). In addition to Babylon's AI-power
(object oriented data representation, forward and backward chained
rules - collectible into sets, horn clauses, and constraint networks)
a graphic interface based on the X11 Window System and the OSF/Motif
Widget Library has been provided.</P>

<P>
<A NAME="Eprover"></A> </P>
<DT><B>Eprover</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.eprover.org/">http://www.eprover.org/</A></LI>
<LI>Web site: 
<A HREF="http://www4.informatik.tu-muenchen.de/~schulz/WORK/eprover.html">http://www4.informatik.tu-muenchen.de/~schulz/WORK/eprover.html</A></LI>
</UL>
</P>
<P>The E Equational Theorem Prover is a purely equational theorem prover.
The core proof procedure operates on formulas in clause normal form,
using a calculus that combines superposition (with selection of negative
literals) and rewriting. No special rules for non-equational literals
have been implemented, i.e., resolution is simulated via paramodulation
and equality resolution. The basic calculus is extended with rules for AC
redundancy elemination, some contextual simplification, and
pseudo-splitting. The latest version of E also supports simultaneous
paramodulation, either for all inferences or for selected inferences.</P>
<P>E is based on the DISCOUNT-loop variant of the given-clause algorithm,
i.e. a strict separation of active and passive facts. Proof search in E
is primarily controlled by a literal selection strategy, a clause
evaluation heuristic, and a simplification ordering. The prover supports
a large number of preprogrammed literal selection strategies, many of
which are only experimental. Clause evaluation heuristics can be
constructed on the fly by combining various parameterized primitive
evaluation functions, or can be selected from a set of predefined
heuristics. Supported term orderings are several parameterized instances
of Knuth-Bendix-Ordering (KBO) and Lexicographic Path Ordering (LPO). </P>

<P>
<A NAME="Fool-Fox"></A> </P>
<DT><B>FOOL &amp; FOX</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://rhaug.de/fool/">rhaug.de/fool/</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.informatik.uni-oldenburg.de/pub/fool/">ftp.informatik.uni-oldenburg.de/pub/fool/</A></LI>
</UL>
</P>

<P>FOOL stands for the Fuzzy Organizer OLdenburg. It is a result from
a project at the University of Oldenburg. FOOL is a graphical user
interface to develop fuzzy rulebases.  FOOL will help you to invent
and maintain a database that specifies the behavior of a
fuzzy-controller or something like that.</P>

<P>FOX is a small but powerful fuzzy engine which reads this database,
reads some input values and calculates the new control value.</P>

<P>
<A NAME="FreeHAL"></A> </P>
<DT><B>FreeHAL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="https://freehal.net">https://freehal.net</A></LI>
</UL>
</P>
<P>FreeHAL is a self-learning conversation simulator which uses semantic
nets to organize its knowledge.</P>
<P>FreeHAL uses a semantic network, pattern matching, stemmers, part of
speech databases, part of speech taggers, and Hidden Markov Models.
Both the online and the download version support TTS.</P>

<P>
<A NAME="FUF-SURGE"></A> </P>
<DT><B>FUF and SURGE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.bgu.ac.il/surge/index.html">http://www.cs.bgu.ac.il/surge/index.html</A></LI>
</UL>
</P>
<P>FUF is an extended implementation of the formalism of functional
unification grammars (FUGs) introduced by Martin Kay specialized to
the task of natural language generation. It adds the following
features to the base formalism:
<UL>
<LI>Types and inheritance.</LI>
<LI>Extended control facilities (goal freezing, intelligent
backtracking).</LI>
<LI>Modular syntax.</LI>
</UL>

These extensions allow the development of large grammars which can be
processed efficiently and can be maintained and understood more
easily.  SURGE is a large syntactic realization grammar of English
written in FUF. SURGE is developed to serve as a black box syntactic
generation component in a larger generation system that encapsulates a
rich knowledge of English syntax. SURGE can also be used as a platform
for exploration of grammar writing with a generation perspective.</P>

<P>
<A NAME="GATE"></A> </P>
<DT><B>GATE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://gate.ac.uk/">http://gate.ac.uk/</A></LI>
<LI>Alt site: 
<A HREF="http://sourceforge.net/projects/gate">http://sourceforge.net/projects/gate</A></LI>
</UL>
</P>
<P>GATE (General Architecture for Text Engineering) is an architecture,
framework and development environment for developing, evaluating and
embedding Human Language Technology.</P>
<P>GATE is made up of three elements:
<UL>
<LI>An architecture describing how language processing systems are
made up of components.</LI>
<LI>A framework (or class library, or SDK), written in Java and
tested on Linux, Windoze and Solaris.</LI>
<LI>A graphical development environment built on the framework.</LI>
</UL>
</P>

<P>
<A NAME="Grammar Workbench"></A> </P>
<DT><B>The Grammar Workbench</B><DD><P>
<UL>
<LI>Web site: ??? 
<A HREF="http://www.cs.kun.nl/agfl/">www.cs.kun.nl/agfl/</A></LI>
</UL>
</P>
<P>Seems to be obsolete??? Its gone from the site, though its parent
project is still ongoing.</P>
<P>The Grammar Workbench, or GWB for short, is an environment for the
comfortable development of Affix Grammars in the AGFL-formalism. Its
purposes are: 
<UL>
<LI>to allow the user to input, inspect and modify a grammar; </LI>
<LI>to perform consistency checks on the grammar; </LI>
<LI>to compute grammar properties; </LI>
<LI>to generate example sentences; </LI>
<LI>to assist in performing grammar transformations. </LI>
</UL>
</P>

<P>
<A NAME="GSM Suite"></A> </P>
<DT><B>GSM Suite</B><DD><P>
<UL>
<LI>Alt site: 
<A HREF="http://www.ibiblio.org/pub/Linux/apps/graphics/draw/">www.ibiblio.org/pub/Linux/apps/graphics/draw/</A></LI>
</UL>
</P>
<P>The GSM Suite is a set of programs for using Finite State
Machines in a graphical fashion. The suite consists of programs
that edit, compile, and print state machines. Included in the
suite is an editor program, gsmedit, a compiler, gsm2cc, that
produces a C++ implementation of a state machine, a PostScript
generator, gsm2ps, and two other minor programs. GSM is licensed
under the GNU Public License and so is free for your use under
the terms of that license.</P>

<P>
<A NAME="Isabelle"></A> </P>
<DT><B>Isabelle</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://isabelle.in.tum.de/">isabelle.in.tum.de</A></LI>
</UL>
</P>
<P>Isabelle is a popular generic theorem prover developed at Cambridge
University and TU Munich. Existing logics like Isabelle/HOL provide a
theorem proving environment ready to use for sizable applications.
Isabelle may also serve as framework for rapid prototyping of deductive
systems. It comes with a large library including Isabelle/HOL
(classical higher-order logic), Isabelle/HOLCF (Scott's Logic for
Computable Functions with HOL), Isabelle/FOL (classical and
intuitionistic first-order logic), and Isabelle/ZF (Zermelo-Fraenkel
set theory on top of FOL).</P>

<P>
<A NAME="Jess"></A> </P>
<DT><B>Jess, the Java Expert System Shell</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://herzberg.ca.sandia.gov/jess/">herzberg.ca.sandia.gov/jess/</A></LI>
</UL>
</P>
<P>Jess is a clone of the popular CLIPS expert system shell written
entirely in Java. With Jess, you can conveniently give your
applets the ability to 'reason'. Jess is compatible with all
versions of Java starting with version 1.0.2. Jess implements
the following constructs from CLIPS: defrules, deffunctions,
defglobals, deffacts, and deftemplates.  </P>

<P>
<A NAME="learn"></A> </P>
<DT><B>learn</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ibiblio.org/pub/Linux/apps/cai/">www.ibiblio.org/pub/Linux/apps/cai/</A></LI>
</UL>
</P>
<P>Learn is a vocable learning program with memory model. </P>

<P>
<A NAME="LISA"></A> </P>
<DT><B>LISA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lisa.sourceforge.net/">lisa.sourceforge.net</A></LI>
</UL>
</P>
<P>LISA (Lisp-based Intelligent Software Agents) is a production-rule
system heavily influenced by JESS (Java Expert System Shell). It has at
its core a reasoning engine based on the Rete pattern matching
algorithm. LISA also provides the ability to reason over ordinary CLOS
objects.</P>

<P>
<A NAME="Livingstone2"></A> </P>
<DT><B>Livingstone2</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ti.arc.nasa.gov/opensource/projects/livingstone2/">http://ti.arc.nasa.gov/opensource/projects/livingstone2/</A></LI>
</UL>
</P>
<P>Livingstone2 (L2) is a reusable artificial intelligence (AI) software
system designed to assist spacecraft, life support systems, chemical
plants or other complex systems in operating robustly with minimal
human supervision, even in the face of hardware failures or unexpected
events.</P>

<P>
<A NAME="NICOLE"></A> </P>
<DT><B>NICOLE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://nicole.sourceforge.net/">http://nicole.sourceforge.net/</A></LI>
</UL>
</P>
<P>NICOLE (Nearly Intelligent Computer Operated Language Examiner) is a
theory or experiment that if a computer is given enough combinations of
how words, phrases and sentences are related to one another, it could
talk back to you. It is an attempt to simulate a conversation by
learning how words are related to other words. A human communicates
with NICOLE via the keyboard and NICOLE responds back with its own
sentences which are automatically generated, based on what NICOLE has
stored in it's database. Each new sentence that has been typed in, and
NICOLE doesn't know about, is included into NICOLE's database, thus
extending the knowledge base of NICOLE.</P>

<P>
<A NAME="Otter"></A> </P>
<DT><B>Otter: An Automated Deduction System</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-unix.mcs.anl.gov/AR/otter/">http://www-unix.mcs.anl.gov/AR/otter/</A></LI>
</UL>
</P>
<P>Our current automated deduction system  Otter is designed to prove
theorems stated in first-order logic with equality.  Otter's
inference rules are based on resolution and paramodulation, and it
includes facilities for term rewriting, term orderings, Knuth-Bendix
completion, weighting, and strategies for directing and restricting
searches for proofs.   Otter can also be used as a symbolic
calculator and has an embedded equational programming system.</P>

<P>
<A NAME="PVS"></A> </P>
<DT><B>PVS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pvs.csl.sri.com/">pvs.csl.sri.com/</A></LI>
</UL>
</P>
<P>PVS is a verification system: that is, a specification language
integrated with support tools and a theorem prover. It is
intended to capture the state-of-the-art in mechanized formal
methods and to be sufficiently rugged that it can be used for
significant applications. PVS is a research prototype: it
evolves and improves as we develop or apply new capabilities,
and as the stress of real use exposes new requirements.</P>

<P>
<A NAME="SNePS"></A> </P>
<DT><B>SNePS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cse.buffalo.edu/sneps/">www.cse.buffalo.edu/sneps/</A></LI>
</UL>
</P>
<P>The long-term goal of The SNePS Research Group is the design and
construction of a natural-language-using computerized cognitive
agent, and carrying out the research in artificial intelligence,
computational linguistics, and cognitive science necessary for
that endeavor. The three-part focus of the group is on knowledge
representation, reasoning, and natural-language understanding
and generation. The group is widely known for its development of
the SNePS knowledge representation/reasoning system, and Cassie,
its computerized cognitive agent.  </P>

<P>
<A NAME="Soar"></A> </P>
<DT><B>Soar</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sitemaker.umich.edu/soar">sitemaker.umich.edu/soar</A></LI>
</UL>
</P>

<P>Soar has been developed to be a general cognitive architecture.
We intend ultimately to enable the Soar architecture to:
<UL>
<LI>work on the full range of tasks expected of an
intelligent agent, from highly routine to extremely difficult,
open-ended problems</LI>
<LI>represent and use appropriate forms of knowledge, such as
procedural, declarative, episodic, and possibly iconic</LI>
<LI>employ the full range of problem solving methods</LI>
<LI>interact with the outside world and</LI>
<LI>learn about all aspects of the tasks and its performance on them. </LI>
</UL>

In other words, our intention is for Soar to support all the
capabilities required of a general intelligent agent.</P>
<P>
<A NAME="TCM"></A> </P>
<DT><B>TCM</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://wwwhome.cs.utwente.nl/~tcm/">http://wwwhome.cs.utwente.nl/~tcm/</A></LI>
</UL>
</P>
<P>TCM (Toolkit for Conceptual Modeling) is our suite of graphical
editors. TCM contains graphical editors for Entity-Relationship
diagrams, Class-Relationship diagrams, Data and Event Flow
diagrams, State Transition diagrams, Jackson Process Structure
diagrams and System Network diagrams, Function Refinement trees
and various table editors, such as a Function-Entity table
editor and a Function Decomposition table editor.  TCM is easy
to use and performs numerous consistency checks, some of them
immediately, some of them upon request.</P>

<P>
<A NAME="Yale"></A> </P>
<DT><B>Yale</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://yale.sf.net/">yale.sf.net/</A></LI>
<LI>Alt Web site: 
<A HREF="http://rapid-i.com/">rapid-i.com/</A></LI>
</UL>
</P>
<P>YALE (Yet Another Learning Environment) is an environment for machine
learning experiments. Experiments can be made up of a large number of
arbitrarily nestable operators and their setup is described by XML
files which can easily created with a graphical user interface.
Applications of YALE cover both research and real-world learning tasks.</P>

<P>
<A NAME="WEKA"></A> </P>
<DT><B>WEKA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.waikato.ac.nz/~ml/">lucy.cs.waikato.ac.nz/~ml/</A></LI>
</UL>
</P>

<P>WEKA (Waikato Environment for Knowledge Analysis) is an
state-of-the-art facility for applying machine learning
techniques to practical problems. It is a comprehensive software
"workbench" that allows people to analyse real-world data. It
integrates different machine learning tools within a common
framework and a uniform user interface. It is designed to
support a "simplicity-first" methodology, which allows users to
experiment interactively with simple machine learning tools
before looking for more complex solutions.</P>


</DL>
</P>



<HR>
<H2><A NAME="Connectionism"></A> <A NAME="s3">3.</A> <A HREF="AI-Alife-HOWTO.html#toc3">Connectionism</A></H2>

<P>Connectionism is a technical term for a group of related
techniques. These techniques include areas such as Artificial
Neural Networks, Semantic Networks and a few other similar
ideas. My present focus is on neural networks (though I am
looking for resources on the other techniques). Neural
networks are programs designed to simulate the workings of the
brain. They consist of a network of small mathematical-based
nodes, which work together to form patterns of information.
They have tremendous potential and currently seem to be having
a great deal of success with image processing and robot
control.</P>


<H2><A NAME="ss3.1">3.1</A> <A HREF="AI-Alife-HOWTO.html#toc3.1">Connectionist class/code libraries</A>
</H2>


<P>These are libraries of code or classes for use in programming within
the Connectionist field.  They are not meant as stand alone
applications, but rather as tools for building your own applications.</P>
<P>
<DL>
<P>
<A NAME="Baysian Modeling"></A> </P>
<DT><B>Software for Flexible Bayesian Modeling</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.utoronto.ca/~radford/fbm.software.html">www.cs.utoronto.ca/~radford/fbm.software.html</A></LI>
</UL>
</P>
<P>This software implements flexible Bayesian models for regression
and classification applications that are based on multilayer
perceptron neural networks or on Gaussian processes.  The
implementation uses Markov chain Monte Carlo methods.  Software
modules that support Markov chain sampling are included in the
distribution, and may be useful in other applications.</P>

<P>
<A NAME="BELIEF"></A> </P>
<DT><B>BELIEF</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/probabl/belief/">www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/probabl/belief/</A></LI>
</UL>
</P>

<P>BELIEF is a Common Lisp implementation of the Dempster and Kong
fusion and propagation algorithm for Graphical Belief Function
Models and the Lauritzen and Spiegelhalter algorithm for
Graphical Probabilistic Models. It includes code for
manipulating graphical belief models such as Bayes Nets and
Relevance Diagrams (a subset of Influence Diagrams) using both
belief functions and probabilities as basic representations of
uncertainty. It uses the Shenoy and Shafer version of the
algorithm, so one of its unique features is that it supports
both probability distributions and belief functions.  It also
has limited support for second order models (probability
distributions on parameters).</P>
<P>
<A NAME="bpnn.py"></A> </P>
<DT><B>bpnn.py</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://arctrix.com/nas/python/bpnn.py">http://arctrix.com/nas/python/bpnn.py</A></LI>
</UL>
</P>
<P>A simple back-propogation ANN in Python.</P>

<P>
<A NAME="brain"></A> </P>
<DT><B>brain</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://harthur.github.com/brain/">http://harthur.github.com/brain/</A></LI>
</UL>
</P>
<P>Brain is a lightweight JavaScript library for  neural networks. It
implements the standard feedforward multi-layer perceptron neural
network trained with backpropagation.</P>
<P>
<A NAME="brain-simulator"></A> </P>
<DT><B>brain-simulator</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.briansimulator.org/">http://www.briansimulator.org/</A></LI>
</UL>
</P>
<P>Brian is a clock-driven simulator for spiking neural networks. It is
designed with an emphasis on flexibility and extensibility, for rapid
development and refinement of neural models. Neuron models are
specified by sets of user-specified differential equations, threshold
conditions and reset conditions (given as strings). The focus is
primarily on networks of single compartment neuron models (e.g. leaky
integrate-and-fire or Hodgkin-Huxley type neurons). It is written in
Python and is easy to learn and use, highly flexible and easily
extensible. Features include:</P>
<P>
<UL>
<LI>a system for specifying quantities with physical dimensions</LI>
<LI>exact numerical integration for linear differential equations</LI>
<LI>Euler, Runge-Kutta and exponential Euler integration for
nonlinear differential equations</LI>
<LI>synaptic connections with delays</LI>
<LI>short-term and long-term plasticity (spike-timing dependent
plasticity)</LI>
<LI>a library of standard model components, including
integrate-and-fire equations, synapses and ionic currents</LI>
<LI>a toolbox for automatically fitting spiking neuron models to
electrophysiological recordings</LI>
</UL>
</P>

<P>
<A NAME="CNNs"></A> </P>
<DT><B>CNNs</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.isiweb.ee.ethz.ch/haenggi/CNNsim.html">http://www.isiweb.ee.ethz.ch/haenggi/CNNsim.html</A></LI>
<LI>Newer Version: 
<A HREF="http://www.isiweb.ee.ethz.ch/haenggi/CNNsim_adv_manual.html">http://www.isiweb.ee.ethz.ch/haenggi/CNNsim_adv_manual.html</A></LI>
<LI>Old Page: 
<A HREF="http://www.ce.unipr.it/research/pardis/CNN/cnn.html">http://www.ce.unipr.it/research/pardis/CNN/cnn.html</A></LI>
</UL>
</P>
<P>Cellular Neural Networks (CNN)  is a massive parallel computing
paradigm defined in discrete N-dimensional spaces. A visualizing CNN
Simulator which allows to track the way in which the state trajectories
evolve, thus gaining an insight into the behavior of  CNN dynamics.
This may be useful for forming an idea how a CNN 'works', especially
for those people who are not experienced in CNN theory.</P>

<P>
<A NAME="CONICAL"></A> </P>
<DT><B>CONICAL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://strout.net/conical/">strout.net/conical/</A></LI>
</UL>
</P>
<P>CONICAL is a C++ class library for building simulations common
in computational neuroscience. Currently its focus is on
compartmental modeling, with capabilities similar to GENESIS and
NEURON. A model neuron is built out of compartments, usually
with a cylindrical shape. When small enough, these open-ended
cylinders can approximate nearly any geometry. Future classes
may support reaction-diffusion kinetics and more. A key feature
of CONICAL is its cross-platform compatibility; it has been
fully co-developed and tested under Unix, DOS, and Mac OS.</P>

<P>
<A NAME="Encog"></A> </P>
<DT><B>Encog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.heatonresearch.com/">http://www.heatonresearch.com/</A></LI>
</UL>
</P>
<P>Encog is an advanced neural network and machine learning framework.
Encog contains classes to create a wide variety of networks, as well as
support classes to normalize and process data for these neural
networks. Encog trains using multithreaded resilient propagation. Encog
can also make use of a GPU to further speed processing time. A GUI
based workbench is also provided to help model and train neural
networks. Encog has been in active development since 2008.  Encog is
available for Java, .Net and Silverlight.</P>

<P>
<A NAME="FANN"></A> </P>
<DT><B>FANN</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://leenissen.dk/fann/">http://leenissen.dk/fann/</A></LI>
</UL>
</P>
<P>Fast Artificial Neural Network Library is a free open source neural
network library, which implements multilayer artificial neural networks
in C with support for both fully connected and sparsely connected
networks. Cross-platform execution in both fixed and floating point are
supported. It includes a framework for easy handling of training data
sets. It is easy to use, versatile, well documented, and fast. PHP,
C++, .NET, Ada, Python, Delphi, Octave, Ruby, Prolog Pure Data and
Mathematica bindings are available. A reference manual accompanies the
library with examples and recommendations on how to use the library. A
graphical user interface is also available for the library.</P>

<P>
<A NAME="ffnet"></A> </P>
<DT><B>ffnet</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ffnet.sourceforge.net/">http://ffnet.sourceforge.net/</A></LI>
</UL>
</P>
<P>ffnet is a fast and easy-to-use feed-forward neural network training
solution for python. Many nice features are implemented: arbitrary
network connectivity, automatic data normalization, very efficient
training tools, network export to fortran code.</P>

<P>
<A NAME="Joone"></A> </P>
<DT><B>Joone</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/joone/">http://sourceforge.net/projects/joone/</A></LI>
</UL>
</P>
<P>Joone is a neural net framework to create, train and test neural nets.
The aim is to create a distributed environment based on JavaSpaces both
for enthusiastic and professional users, based on the newest Java
technologies.  Joone is composed of a central engine that is the
fulcrum of all applications that already exist or will be developed.
The neural engine is modular, scalable, multitasking and tensile.
Everyone can write new modules to implement new algorithms or new
architectures starting from the simple components distributed with the
core engine.  The main idea is to create the basis to promote a zillion
of AI applications that revolve around the core framework.</P>

<P>
<A NAME="Matrix Class"></A> </P>
<DT><B>Matrix Class</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.cs.ucla.edu/pub/">ftp.cs.ucla.edu/pub/</A></LI>
</UL>
</P>
<P>A simple, fast, efficient C++ Matrix class designed for
scientists and engineers. The Matrix class is well suited for
applications with complex math algorithms. As an demonstration
of the Matrix class, it was used to implement the backward error
propagation algorithm for a multi-layer feed-forward artificial
neural network.</P>

<P>
<A NAME="NEAT"></A> </P>
<DT><B>NEAT</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://nn.cs.utexas.edu/project-view.php?RECORD_KEY(Projects)=ProjID&amp;ProjID(Projects)=14">http://nn.cs.utexas.edu/project-view.php?RECORD_KEY(Projects)=ProjID&amp;ProjID(Projects)=14</A></LI>
<LI>Web site: 
<A HREF="http://www.cs.ucf.edu/~kstanley/neat.html">http://www.cs.ucf.edu/~kstanley/neat.html</A></LI>
</UL>
</P>
<P>Many neuroevolution methods evolve fixed-topology networks. Some
methods evolve topologies in addition to weights, but these usually
have a bound on the complexity of networks that can be evolved and
begin evolution with random topologies. This project is based on a
neuroevolution method called NeuroEvolution of Augmenting Topologies
(NEAT) that can evolve networks of unbounded complexity from a minimal
starting point.</P>
<P>The research as a broader goal of showing that evolving topologies is
necessary to achieve 3 major goals of neuroevolution: (1) Continual
coevolution: Successful competitive coevolution can use the evolution
of topologies to continuously elaborate strategies. (2) Evolution of
Adaptive Networks: The evolution of topologies allows neuroevolution to
evolve adaptive networks with plastic synapses by designating which
connections should be adaptive and in what ways. (3) Combining Expert
Networks: Separate expert neural networks can be fused through the
evolution of connecting neurons between them.</P>

<P>
<A NAME="NeuroLab"></A> </P>
<DT><B>NeuroLab</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://packages.python.org/neurolab/">http://packages.python.org/neurolab/</A></LI>
</UL>
</P>
<P>NeuroLab - a library of basic neural networks algorithms with flexible
network configurations and learning algorithms for Python. To simplify
the using of the library, interface is similar to the package of Neural
Network Toolbox (NNT) of MATLAB (c). The library is based on the
package numpy (http://numpy.scipy.org), some learning algorithms are
used scipy.optimize (http://scipy.org).</P>

<P>
<A NAME="Pulcinella"></A> </P>
<DT><B>Pulcinella</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://iridia.ulb.ac.be/pulcinella/">iridia.ulb.ac.be/pulcinella/</A></LI>
</UL>
</P>
<P>Pulcinella is written in CommonLisp, and appears as a library of
Lisp functions for creating, modifying and evaluating valuation
systems. Alternatively, the user can choose to interact with
Pulcinella via a graphical interface (only available in Allegro
CL). Pulcinella provides primitives to build and evaluate
uncertainty models according to several uncertainty calculi,
including probability theory, possibility theory, and
Dempster-Shafer's theory of belief functions; and the
possibility theory by Zadeh, Dubois and Prade's. A User's Manual
is available on request.</P>

<P>
<A NAME="scnANNlib"></A> </P>
<DT><B>scnANNlib</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.sentinelchicken.org/projects/scnANNlib/">www.sentinelchicken.org/projects/scnANNlib/</A></LI>
</UL>
</P>
<P>SCN Artificial Neural Network Library provides a programmer with a
simple object-oriented API for constructing ANNs. Currently, the
library supports non-recursive networks with an arbitrary number of
layers, each with an arbitrary number of nodes. Facilities exist for
training with momentum, and there are plans to gracefully extend the
functionality of the library in later releases.</P>

<P>
<A NAME="UTCS"></A> </P>
<DT><B>UTCS Neural Nets Research Group Software</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://nn.cs.utexas.edu/soft-list.php">http://nn.cs.utexas.edu/soft-list.php</A></LI>
</UL>
</P>
<P>A bit different from the other entries, this is a reference to a
collection of software rather than one application. It was all
developed by the 
<A HREF="http://nn.cs.utexas.edu/">UTCS         Neural Net Research Group</A>. Here's a summary of some of the packages
available:</P>
<P>
<UL>
<LI>Natural Language Processing
<UL>
<LI>MIR - Tcl/Tk-based rapid prototyping for sentence
processing</LI>
<LI>SPEC - Parsing complex sentences</LI>
<LI>DISCERN - Processing script-based stories, including
<UL>
<LI>PROC - Parsing, generation, question answering</LI>
<LI>HFM - Episodic memory organization</LI>
<LI>DISLEX - Lexical processing</LI>
<LI>DISCERN - The full integrated model</LI>
</UL>
</LI>
<LI>FGREPNET - Learning distributed representations</LI>
</UL>
</LI>
<LI>Self-Organization
<UL>
<LI>LISSOM - Maps with self-organizing lateral connections.</LI>
<LI>FM - Generic Self-Organizing Maps</LI>
</UL>
</LI>
<LI>Neuroevolution
<UL>
<LI>Enforced Sub-Populations (ESP) for sequential decision
tasks
<UL>
<LI>Non-Markov Double Pole Balancing</LI>
</UL>
</LI>
<LI>Symbiotic, Adaptive NeuroEvolution (SANE; predecessor of
ESP)
<UL>
<LI>JavaSANE - Java software package for applying SANE to
new tasks</LI>
<LI>SANE-C - C version, predecessor of JavaSANE</LI>
<LI>Pole Balancing - Neuron-level SANE on the Pole
Balancing task</LI>
</UL>
</LI>
<LI>NeuroEvolution of Augmenting Topologies (NEAT)
software for evolving neural networks using structure</LI>
</UL>
</LI>
</UL>
</P>

<P>
<A NAME="C++ ANNs"></A> </P>
<DT><B>Various (C++) Neural Networks</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.dontveter.com/nnsoft/nnsoft.html">www.dontveter.com/nnsoft/nnsoft.html</A></LI>
</UL>
</P>
<P>Example neural net codes from the book, 
<A HREF="http://www.dontveter.com/basisofai/basisofai.html">The       Pattern Recognition Basics of AI</A>.
These are simple example codes of these various
neural nets. They work well as a good starting point for simple
experimentation and for learning what the code is like behind the
simulators. The types of networks available on this site are:
(implemented in C++)</P>

<P>
<UL>
<LI>The Backprop Package</LI>
<LI>The Nearest Neighbor Algorithms</LI>
<LI>The Interactive Activation Algorithm</LI>
<LI>The Hopfield and Boltzman machine Algorithms</LI>
<LI>The Linear Pattern Classifier</LI>
<LI>ART I</LI>
<LI>Bi-Directional Associative Memory</LI>
<LI>The Feedforward Counter-Propagation Network</LI>
</UL>
</P>


</DL>
</P>

<H2><A NAME="ss3.2">3.2</A> <A HREF="AI-Alife-HOWTO.html#toc3.2">Connectionist software kits/applications</A>
    </H2>


<P>These are various applications, software kits, etc. meant for research
in the field of Connectionism. Their ease of use will vary, as they
were designed to meet some particular research interest more than as
an easy to use commercial package.
<DL>

<P>
<A NAME="Aspirin-MIGRANES"></A> </P>
<DT><B>Aspirin - MIGRAINES</B><DD><P>(am6.tar.Z on ftp site)
<UL>
<LI>FTP site: 
<A HREF="ftp://sunsite.unc.edu/pub/academic/computer-science/neural-networks/programs/Aspirin/">sunsite.unc.edu/pub/academic/computer-science/neural-networks/programs/Aspirin/</A></LI>
</UL>
</P>

<P>The software that we are releasing now is for creating,
and evaluating, feed-forward networks such as those used with the
backpropagation learning algorithm. The software is aimed both at
the expert programmer/neural network researcher who may wish to tailor
significant portions of the system to his/her precise needs, as well
as at casual users who will wish to use the system with an absolute
minimum of effort.</P>


<P>
<A NAME="DDLab"></A> </P>
<DT><B>DDLab</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ddlab.com/">http://www.ddlab.com/</A></LI>
</UL>
</P>
<P>DDLab is an interactive graphics program for research into the
dynamics of finite binary networks, relevant to the study of
complexity, emergent phenomena, neural networks, and aspects of
theoretical biology such as gene regulatory networks. A network
can be set up with any architecture between regular CA (1d or
2d) and "random Boolean networks" (networks with arbitrary
connections and heterogeneous rules). The network may also have
heterogeneous neighborhood sizes.</P>

<P>
<A NAME="Emergent"></A> </P>
<DT><B>Emergent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://grey.colorado.edu/emergent/index.php/Main_Page">http://grey.colorado.edu/emergent/index.php/Main_Page</A></LI>
</UL>
</P>
<P>Note: this is a descendant of 
<A HREF="#PDP++">PDP++</A>
</P>
<P>emergent is a comprehensive, full-featured neural network simulator
that allows for the creation and analysis of complex, sophisticated
models of the brain in the world. With an emphasis on qualitative
analysis and teaching, it also supports the workflow of professional
neural network researchers. The GUI environment allows users to quickly
construct basic networks, modify the input/output patterns,
automatically generate the basic programs required to train and test
the network, and easily utilize several data processing and network
analysis tools. In addition to the basic preset network train and test
programs, the high level drag-and-drop programming interface, built on
top of a scripting language that has full introspective access to all
aspects of networks and the software itself, allows one to write
programs that seamlessly weave together the training of a network and
evolution of its environment without ever typing out a line of code.
Networks and all of their state variables are visually inspected in 3D,
allowing for a quick "visual regression" of network dynamics and robot
behavior.</P>

<P>
<A NAME="GENESIS"></A> </P>
<DT><B>GENESIS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://genesis-sim.org/">http://genesis-sim.org/</A></LI>
</UL>
</P>
<P>GENESIS (short for GEneral NEural SImulation System) is a
general purpose simulation platform which was developed to
support the simulation of neural systems ranging from complex
models of single neurons to simulations of large networks made
up of more abstract neuronal components. GENESIS has provided
the basis for laboratory courses in neural simulation at both
Caltech and the Marine Biological Laboratory in Woods Hole, MA,
as well as several other institutions. Most current GENESIS
applications involve realistic simulations of biological neural
systems. Although the software can also model more abstract
networks, other simulators are more suitable for backpropagation
and similar connectionist modeling.</P>

<P>
<A NAME="JavaBayes"></A> </P>
<DT><B>JavaBayes</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.cmu.edu/~javabayes/">http://www.cs.cmu.edu/~javabayes/</A></LI>
</UL>
</P>
<P>The JavaBayes system is a set of tools, containing a
graphical editor, a core inference engine and a parser.
JavaBayes can produce:
<UL>
<LI> the marginal distribution for any variable in a network.</LI>
<LI> the expectations for univariate functions (for example,
expected value for variables).</LI>
<LI> configurations with maximum a posteriori probability.</LI>
<LI> configurations with maximum a posteriori expectation for
univariate functions.</LI>
</UL>
</P>

<P>
<A NAME="Jbpe"></A> </P>
<DT><B>Jbpe</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://cs.felk.cvut.cz/~koutnij/studium/jbpe.html">cs.felk.cvut.cz/~koutnij/studium/jbpe.html</A></LI>
</UL>
</P>
<P>Jbpe is a back-propagation neural network editor/simulator.</P>
<P>Features
<UL>
<LI>Standart back-propagation networks creation.</LI>
<LI>Saving network as a text file, which can be edited and loaded
back.</LI>
<LI>Saving/loading binary file</LI>
<LI>Learning from a text file (with structure specified below),
number of learning periods / desired network energy can be
specified as a criterion.</LI>
<LI>Network recall</LI>
</UL>
</P>

<P>
<A NAME="Nengo"></A> </P>
<DT><B>Nengo</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nengo.ca/">http://www.nengo.ca/</A></LI>
</UL>
</P>
<P>Nengo (Nengo Neural Simulator) is a graphical and scripting based
software package for simulating large-scale neural systems.</P>
<P>To use it, you define groups of neurons in terms of what they
represent, and then form connections between neural groups in terms of
what computation should be performed on those representations. Nengo
then uses the Neural Engineering Framework (NEF) to solve for the
appropriate synaptic connection weights to achieve this desired
computation. Nengo also supports various kinds of learning. Nengo helps
make detailed spiking neuron models that implement complex high-level
cognitive algorithms.</P>
<P>Among other things, Nengo has been used to implement motor control,
visual attention, serial recall, action selection, working memory,
attractor networks, inductive reasoning, path integration, and planning
with problem solving.</P>
<P>The Spaun 
<A HREF="http://models.nengo.ca/spaun">http://models.nengo.ca/spaun</A> neural simulator
is implemented in Nengo and its source is available as well.</P>

<P>
<A NAME="NN Generator"></A> </P>
<DT><B>Neural Network Generator</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.idsia.ch/pub/rafal/">ftp.idsia.ch/pub/rafal</A></LI>
</UL>
</P>
<P>The Neural Network Generator is a genetic algorithm for the
topological optimization of feedforward neural networks. It
implements the Semantic Changing Genetic Algorithm and the
Unit-Cluster Model. The Semantic Changing Genetic Algorithm is
an extended genetic algorithm that allows fast dynamic
adaptation of the genetic coding through population
analysis. The Unit-Cluster Model is an approach to the
construction of modular feedforward networks with a ''backbone''
structure.</P>
<P>NOTE: To compile this on Linux requires one change in the Makefiles.
You will need to change '-ltermlib' to '-ltermcap'.</P>

<P>
<A NAME="NEURON"></A> </P>
<DT><B>NEURON</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.neuron.yale.edu/">www.neuron.yale.edu/</A></LI>
</UL>
</P>
<P>NEURON is an extensible nerve modeling and simulation
program. It allows you to create complex nerve models by
connecting multiple one-dimensional sections together to form
arbitrary cell morphologies, and allows you to insert multiple
membrane properties into these sections (including channels,
synapses, ionic concentrations, and counters). The interface was
designed to present the neural modeler with a intuitive
environment and hide the details of the numerical methods used
in the simulation.</P>

<P>
<A NAME="Neuroph"></A> </P>
<DT><B>Neuroph</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://neuroph.sourceforge.net/">http://neuroph.sourceforge.net/</A></LI>
</UL>
</P>
<P>Neuroph is lightweight Java neural network framework to develop common
neural network architectures. It contains well designed, open source
Java library with small number of basic classes which correspond to
basic NN concepts. Also has  nice GUI neural network editor to quickly
create Java neural network components.</P>

<P>
<A NAME="PDP++"></A> </P>
<DT><B>PDP++</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://archive.cnbc.cmu.edu/Resources/PDP++/PDP++.html">http://archive.cnbc.cmu.edu/Resources/PDP++/PDP++.html</A></LI>
<LI>FTP mirror (US): 
<A HREF="ftp://grey.colorado.edu/pub/oreilly/pdp++/">ftp://grey.colorado.edu/pub/oreilly/pdp++/</A></LI>
</UL>
</P>
<P>NOTE: Renamed to 
<A HREF="#Emergent">Emergent</A>
</P>
<P>As the field of Connectionist modeling has grown, so has the need
for a comprehensive simulation environment for the development and
testing of Connectionist models. Our goal in developing PDP++ has been
to integrate several powerful software development and user interface
tools into a general purpose simulation environment that is both user
friendly and user extensible. The simulator is built in the C++
programming language, and incorporates a state of the art script
interpreter with the full expressive power of C++. The graphical user
interface is built with the Interviews toolkit, and allows full access
to the data structures and processing modules out of which the
simulator is built. We have constructed several useful graphical
modules for easy interaction with the structure and the contents of
neural networks, and we've made it possible to change and adapt many
things. At the programming level, we have set things up in such a way
as to make user extensions as painless as possible. The programmer
creates new C++ objects, which might be new kinds of units or new
kinds of processes; once compiled and linked into the simulator, these
new objects can then be accessed and used like any other.</P>

<P>
<A NAME="RNS"></A> </P>
<DT><B>RNS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/rns/">www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/rns/</A></LI>
</UL>
</P>
<P>RNS (Recurrent Network Simulator) is a simulator for recurrent
neural networks. Regular neural networks are also supported. The
program uses a derivative of the back-propagation algorithm, but
also includes other (not that well tested) algorithms.</P>
<P>Features include
<UL>
<LI>freely choosable connections, no restrictions besides memory
or CPU constraints</LI>
<LI>delayed links for recurrent networks</LI>
<LI>fixed values or thresholds can be specified for weights</LI>
<LI>(recurrent) back-propagation, Hebb, differential Hebb,
simulated annealing and more</LI>
<LI>patterns can be specified with bits, floats, characters,
numbers, and random bit patterns with Hamming distances can
be chosen for you</LI>
<LI>user definable error functions</LI>
<LI>output results can be used without modification as input</LI>
</UL>
</P>

<P>
<A NAME="Python Smantic Nets"></A> </P>
<DT><B>Semantic Networks in Python</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://strout.net/info/coding/python/ai/index.html">strout.net/info/coding/python/ai/index.html</A></LI>
</UL>
</P>
<P>The semnet.py module defines several simple classes for
building and using semantic networks.  A semantic network is a
way of representing knowledge, and it enables the program to
do simple reasoning with very little effort on the part of the
programmer.</P>
<P>The following classes are defined:
<UL>
<LI><B>Entity</B>: This class represents a noun; it is
something which can be related to other things, and about
which you can store facts.</LI>
<LI><B>Relation</B>: A Relation is a type of relationship
which may exist between two entities.  One special relation,
"IS_A", is predefined because it has special meaning (a sort
of logical inheritance).</LI>
<LI><B>Fact</B>: A Fact is an assertion that a relationship
exists between two entities.</LI>
</UL>
</P>

<P>With these three object types, you can very quickly define knowledge
about a set of objects, and query them for logical conclusions.</P>

<P>
<A NAME="SNNS"></A> </P>
<DT><B>SNNS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-ra.informatik.uni-tuebingen.de/SNNS/">http://www-ra.informatik.uni-tuebingen.de/SNNS/</A></LI>
</UL>
</P>
<P>Stuttgart Neural Net Simulator (version 4.1).  An awesome neural
net simulator. Better than any commercial simulator I've seen. The
simulator kernel is written in C (it's fast!). It supports over 20
different network architectures, has 2D and 3D X-based graphical
representations, the 2D GUI has an integrated network editor, and can
generate a separate NN program in C. SNNS is very powerful, though
a bit difficult to learn at first. To help with this it comes with
example networks and tutorials for many of the architectures.
ENZO, a supplementary system allows you to evolve your networks with
genetic algorithms.</P>

<P>
<A NAME="TOOLDIAG"></A> </P>
<DT><B>TOOLDIAG</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.inf.ufes.br/~thomas/home/soft.html">www.inf.ufes.br/~thomas/home/soft.html</A></LI>
<LI>Alt site: 
<A HREF="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/tooldiag/0.html">http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/tooldiag/0.html</A></LI>
</UL>
</P>
<P>TOOLDIAG is a collection of methods for statistical pattern
recognition. The main area of application is classification. The
application area is limited to multidimensional continuous
features, without any missing values. No symbolic features
(attributes) are allowed. The program in implemented in the 'C'
programming language and was tested in several computing
environments.</P>

<P>
<A NAME="XNBC"></A> </P>
<DT><B>XNBC</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.b3e.jussieu.fr/xnbc/">www.b3e.jussieu.fr/xnbc/</A></LI>
</UL>
</P>
<P>XNBC v8 is a simulation tool for the neuroscientists interested in
simulating biological neural networks using a user friendly tool.</P>
<P>XNBC is a software package for simulating biological neural networks.</P>
<P>Four neuron models are available, three phenomenologic models (xnbc,
leaky integrator and conditional burster) and an ion-conductance based
model. Inputs to the simulated neurons can be provided by experimental
data stored in files, allowing the creation of `hybrid'' networks.</P>


</DL>
</P>

<HR>
<H2><A NAME="Evolutionary Computing"></A> <A NAME="s4">4.</A> <A HREF="AI-Alife-HOWTO.html#toc4">Evolutionary Computing</A>    </H2>

<P>Evolutionary computing is actually a broad term for a vast
array of programming techniques, including genetic algorithms,
complex adaptive systems, evolutionary programming, etc.
The main thrust of all these techniques is the idea of
evolution. The idea that a program can be written that will
<I>evolve</I> toward a certain goal.  This goal can be
anything from solving some engineering problem to winning a
game.</P>


<H2><A NAME="ss4.1">4.1</A> <A HREF="AI-Alife-HOWTO.html#toc4.1">EC class/code libraries</A>
    </H2>


<P>These are libraries of code or classes for use in programming within
the evolutionary computation field.  They are not meant as stand alone
applications, but rather as tools for building your own applications.</P>
<P>
<DL>
<P>
<A NAME="ANNEvolve"></A> </P>
<DT><B>ANNEvolve</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://annevolve.sourceforge.net/">annevolve.sourceforge.net</A></LI>
</UL>
</P>
<P>A collection of programs using evolved artificial neural networks to
solve a series of problems. The long term goal of the project is to
advance our level of understanding about simulated evolution as a means
to configure and optimize Artificial Neural Nets (ANNs). The medium
term goal is to apply our methods to a series of interesting problems
such as sail boat piloting and playing the game NIM.</P>
<P>A secondary goal is educational in nature. We attempt to write our
software with ample explanation, not just for the user, but for the
engineer/programmer/scientist who wants to understand the innermost
detail. All of the source code is freely available to anyone to use
without restriction.</P>
<P>All of the ANNEvolve software is implemented in C and Python.</P>

<P>
<A NAME="EAP"></A> </P>
<DT><B>EAP</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://code.google.com/p/deap/">http://code.google.com/p/deap/</A></LI>
</UL>
</P>
<P>EAP has been built using the Python and UNIX programming philosophies
in order to provide a transparent, simple and coherent environment for
implementing your favourite evolutionary algorithms. EAP is very easy
to use even for those who do not know much about the Python programming
language. EAP uses the object oriented paradigm that is provided by
Python in order to make development simple and beautiful.  It also
contains a 15 illustrative and diversified examples, to help newcomers
to ramp up very quickly in using this environment.</P>
<P>It includes Genetic Algorithms using any imaginable representation,
Genetic Programming with strongly and loosely typed trees in addition
to automatically defined functions, Evolution Strategies (including
Covariance Matrix Adaptation), multiobjective optimization techniques
(NSGA-II and SPEA2), easy parallelization of algorithms and much more
like milestones, genealogy, etc.</P>

<P>
<A NAME="daga"></A> </P>
<DT><B>daga</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://garage.cps.msu.edu/software/daga3.2/">garage.cps.msu.edu/software/daga3.2/</A></LI>
</UL>
</P>

<P>daga is an experimental release of a 2-level genetic algorithm
compatible with the GALOPPS GA software. It is a meta-GA which
dynamically evolves a population of GAs to solve a problem presented to
the lower-level GAs. When multiple GAs (with different operators,
parameter settings, etc.) are simultaneously applied to the same
problem, the ones showing better performance have a higher probability
of surviving and "breeding" to the next macro-generation (i.e.,
spawning new "daughter"-GAs with characteristics inherited from the
parental GA or GAs.  In this way, we try to encourage good
problem-solving strategies to spread to the whole population of GAs.</P>

<P>
<A NAME="DEAP"></A> </P>
<DT><B>DEAP</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://deap.googlecode.com">http://deap.googlecode.com</A></LI>
</UL>
</P>
<P>DEAP is intended to be an easy to use distributed evolutionary
algorithm library in the Python language. Its two main components are
modular and can be used separately. The first module is a Distributed
Task Manager (DTM), which is intended to run on cluster of computers
using TCP or a MPI connection. The second part is the Evolutionary
Algorithms in Python (EAP) framework. EAP is the evolutionary core of
DEAP, it provides data structures, methods and tools to design any kind
of evolutionary algorithm. It works in perfect harmony with DTM,
allowing easy parallelization of any demanding evolutionary task.</P>

<P>
<A NAME="dgpf"></A> </P>
<DT><B>dgpf</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://dgpf.sourceforge.net/">dgpf.sourceforge.net</A></LI>
</UL>
</P>
<P>The Distributed Genetic Programming Framework (DGPF) is a scalable Java
environment for heuristic, simulation-based search algorithms of any
kind and Genetic Algorithms in special. We use the broad foundation of
a search algorithms layer to provide a Genetic Programming system which
is able to create Turing-complete code.</P>
<P>It's under the LGPL license. It allows you to use heuristic searches
like GA and randomized Hill Climbing for any problem space you like to
with just minimal programming effort. Also, you may distribute all
these searches over a network, using the client/server, the
peer-to-peer, or even a client/server+ peer-to-peer hybrid distribution
scheme. You also can construct heterogeneous search algorithms where GA
cooperates with Hill Climbing without changing any code.</P>

<P>
<A NAME="Ease"></A> </P>
<DT><B>Ease</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.sprave.com/Ease/Ease.html">www.sprave.com/Ease/Ease.html</A></LI>
</UL>
</P>
<P>Ease - Evolutionary Algorithms Scripting Evironment - is an extension
to the Tcl scripting language, providing commands to create, modify,
and evaluate populations of individuals represented by real number
vectors and/or bit strings.</P>

<P>
<A NAME="EO"></A> </P>
<DT><B>EO</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://eodev.sourceforge.net/">eodev.sourceforge.net</A></LI>
</UL>
</P>
<P>EO is a templates-based, ANSI-C++ compliant evolutionary
computation library. It contains classes for any kind of
evolutionary computation (specially genetic algorithms) you might
come up to. It is component-based, so that if you don't find the
class you need in it, it is very easy to subclass existing  
abstract or concrete class.</P>

<P>
<A NAME="Evocosm"></A> </P>
<DT><B>Evocosm</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.coyotegulch.com/products/libevocosm/">http://www.coyotegulch.com/products/libevocosm/</A></LI>
</UL>
</P>
<P>Evocosm is a set of classes that abstract the fundamental components of
an evolutionary algorithm. See the site for details, but here is a
simple list of the provided classes; Random Numbers, OpenMP,
Floating-Point Chromosomes, Roulettte Wheels, Organisms, Fitness
Landscapes, Evocosms, Fitness Scaling, Migration, Selecting Survivors,
Reproduction, Mutation Operations.</P>

<P>
<A NAME="evolver"></A> </P>
<DT><B>evolver</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="https://launchpad.net/evolver">https://launchpad.net/evolver</A></LI>
</UL>
</P>
<P>A Python library for creating and working with genetic algorithms and
genetic (evolved) programs. Allows one to do Python-based evolutionary
programming; string-based as well as source code tree node
optimization/search solution discovery.</P>

<P>
<A NAME="Fortran GA"></A> </P>
<DT><B>FORTRAN GA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://cuaerospace.com/carroll/ga.html">cuaerospace.com/carroll/ga.html</A></LI>
</UL>
</P>
<P>This program is a FORTRAN version of a genetic algorithm driver.
This code initializes a random sample of individuals with
different parameters to be optimized using the genetic algorithm
approach, i.e.  evolution via survival of the fittest.  The
selection scheme used is tournament selection with a shuffling
technique for choosing random pairs for mating.  The routine
includes binary coding for the individuals, jump mutation, creep
mutation, and the option for single-point or uniform crossover.
Niching (sharing) and an option for the number of children per
pair of parents has been added.  More recently, an option for
the use of a micro-GA has been added.</P>

<P>
<A NAME="FREVO"></A> </P>
<DT><B>FREVO</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://frevo.sourceforge.net/">http://frevo.sourceforge.net/</A></LI>
</UL>
</P>
<P>FREVO is an open-source framework developed in Java to help engineers
and scientists in evolutionary design or optimization tasks. The major
feature of FREVO is the componentwise decomposition and separation of
the key building blocks for each optimization tasks. We identify these
as the problem definition, solution representation and the optimization
method. This structure enables the components to be designed separately
allowing the user to easily swap and evaluate different configurations
and methods or to connect an external simulation tool.</P>

<P>
<A NAME="GALib"></A> </P>
<DT><B>GAlib: Matthew's Genetic Algorithms Library</B><DD><P>
<UL>
<LI>Web Site: 
<A HREF="http://lancet.mit.edu/ga/">http://lancet.mit.edu/ga/</A></LI>
<LI>Download: 
<A HREF="http://lancet.mit.edu/ga/dist/">http://lancet.mit.edu/ga/dist/</A></LI>
<LI>Register GAlib at: 
<A HREF="http://lancet.mit.edu/ga/Register.html">http://lancet.mit.edu/ga/Register.html</A></LI>
</UL>
</P>
<P>GAlib contains a set of C++ genetic algorithm objects.  The
library includes tools for using genetic algorithms to do
optimization in any C++ program using any representation and genetic
operators.  The documentation includes an extensive overview of how
to implement a genetic algorithm as well as examples illustrating
customizations to the GAlib classes.</P>


<P>
<A NAME="GALOPPS"></A> </P>
<DT><B>GALOPPS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://garage.cse.msu.edu/software/galopps/">http://garage.cse.msu.edu/software/galopps/</A> </LI>
<LI>FTP site: 
<A HREF="ftp://garage.cse.msu.edu/pub/GA/galopps/">ftp://garage.cse.msu.edu/pub/GA/galopps/</A></LI>
</UL>
</P>
<P>GALOPPS is a flexible, generic GA, in 'C'.  It was based upon
Goldberg's Simple Genetic Algorithm (SGA) architecture, in order to
make it easier for users to learn to use and extend.</P>
<P>GALOPPS extends the SGA capabilities several fold:
<UL>
<LI> (optional) A new Graphical User Interface, based on TCL/TK, 
for Unix users, allowing easy running of GALOPPS 3.2 (single 
or multiple subpopulations) on one or more processors.  GUI 
writes/reads "standard" GALOPPS input and master files, and 
displays graphical output (during or after run) of 
user-selected variables.</LI>
<LI> 5 selection methods: roulette wheel, stochastic remainder
sampling, tournament selection, stochastic universal sampling,
linear-ranking-then-SUS.</LI>
<LI> Random or superuniform initialization of "ordinary"
(non-permutation) binary or non-binary chromosomes; random
initialization of permutation-based chromosomes; or 
user-supplied initialization of arbitrary types of chromosomes.</LI>
<LI> Binary or non-binary alphabetic fields on value-based
chromosomes, including different user-definable field sizes.</LI>
<LI> 3 crossovers for value-based representations: 1-pt, 2-pt, and
uniform, all of which operate at field boundaries if a 
non-binary alphabet is used.</LI>
<LI> 4 crossovers for order-based reps: PMX, order-based, uniform
order-based, and cycle.</LI>
<LI> 4 mutations: fast bitwise, multiple-field, swap and random
sublist scramble.</LI>
<LI> Fitness scaling: linear scaling, Boltzmann scaling, sigma
truncation, window scaling, ranking.</LI>
<LI><B>Plus</B> a whole lot more....</LI>
</UL>
</P>

<P>
<A NAME="GAS"></A> </P>
<DT><B>GAS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://starship.python.net/crew/gandalf/">http://starship.python.net/crew/gandalf/</A></LI>
</UL>
</P>
<P>GAS means "Genetic Algorithms Stuff".
GAS is freeware.</P>
<P>Purpose of GAS is to explore and exploit artificial evolutions.
Primary implementation language of GAS is Python.  The GAS
software package is meant to be a Python framework for applying
genetic algorithms. It contains an example application where it
is tried to breed Python program strings.  This special problem
falls into the category of Genetic Programming (GP), and/or
Automatic Programming.  Nevertheless, GAS tries to be useful for
other applications of Genetic Algorithms as well.</P>

<P>
<A NAME="GAUL"></A> </P>
<DT><B>GAUL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://gaul.sourceforge.net/">http://gaul.sourceforge.net/</A></LI>
<LI>SF project site: 
<A HREF="http://sourceforge.net/projects/gaul/">http://sourceforge.net/projects/gaul/</A></LI>
</UL>
</P>
<P>The Genetic Algorithm Utility Library (GAUL) is a flexible programming
library designed to aid development of applications that require the
use of genetic algorithms.  Features include:</P>
<P>
<UL>
<LI>Darwinian, Lamarckian or Baldwinian evolutionary schemes.</LI>
<LI>Both steady-state and generation-based GAs included.</LI>
<LI>The island model of evolution is available.</LI>
<LI>Chromosome datatype agnostic. A selection of common chromosome
types are built-in.</LI>
<LI>Allows user-defined crossover, mutation, selection, adaptation
and replacement operators.</LI>
<LI>Support for multiple, simultaneously evolved,populations.</LI>
<LI>Choice of high-level or low-level interface functions.</LI>
<LI>Additional, non-GA, optimisation algorithms are built-in for
local optimisation or comparative purposes.</LI>
<LI>Trivial to extend using external code via the built-in code 
hooks.</LI>
<LI>May be driven by, or extended by, powerful S-Lang scripts.</LI>
<LI>Support for multiprocessor calculations.</LI>
<LI>Written using highly portable C code.</LI>
</UL>
</P>

<P>
<A NAME="GECO"></A> </P>
<DT><B>GECO</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://common-lisp.net/project/geco/">http://common-lisp.net/project/geco/</A></LI>
</UL>
</P>

<P>GECO (Genetic Evolution through Combination of Objects), an
extendible object-oriented tool-box for constructing genetic algorithms
(in Lisp).  It provides a set of extensible classes and methods
designed for generality. Some simple examples are also provided to
illustrate the intended use.</P>

<P>
<A NAME="GenePool"></A> </P>
<DT><B>GenePool</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.rubinsteyn.com/genepool/">http://www.rubinsteyn.com/genepool/</A></LI>
</UL>
</P>
<P>GenePool is a framework for writing evolutionary optimization
algorithms in OCaml. This library is not a complete solution but rather
is a generic skeleton which takes care of the plumbing and nuisances of
optimization. You provide GenePool with functions that give meaning to
fitness and reproduction and after a specified number of generation,
GenePool returns an array of the best "genomes" it evolved.</P>

<P>
<A NAME="Genetic"></A> </P>
<DT><B>Genetic</B><DD><P>
<UL>
<LI>Web site: ???</LI>
<LI>You can get it from the debian repository:
<A HREF="http://packages.qa.debian.org/g/genetic.html">http://packages.qa.debian.org/g/genetic.html</A></LI>
</UL>
</P>
<P>This is a package for genetic algorythms and AI in Python.</P>
<P>Genetic can typically solve ANY problem that consists to minimize a 
function.</P>
<P>It also includes several demos / examples, like the TSP (traveling 
saleman problem).</P>

<P>
<A NAME="GPdata"></A> </P>
<DT><B>GPdata</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/">ftp://ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/</A></LI>
</UL>
</P>
<P>GPdata-3.0.tar.gz (C++) contains a version of Andy Singleton's
GP-Quick version 2.1 which has been extensively altered to support:
<UL>
<LI>Indexed memory operation (cf. teller)</LI>
<LI>multi tree programs</LI>
<LI>Adfs</LI>
<LI>parameter changes without recompilation</LI>
<LI>populations partitioned into demes</LI>
<LI>(A version of) pareto fitness</LI>
</UL>

This ftp site also contains a small C++ program (ntrees.cc) to
calculate the number of different there are of a given length and
given function and terminal set.</P>

<P>
<A NAME="Java GP - gpjpp"></A> </P>
<DT><B>gpjpp Genetic Programming in Java</B><DD><P>
<UL>
<LI>The code can be found in the tarball linked from 
"GP and Othello Java code and READMEs" on this page: 
<A HREF="http://www1.cs.columbia.edu/~evs/ml/hw4.html">http://www1.cs.columbia.edu/~evs/ml/hw4.html</A></LI>
</UL>
</P>
<P>gpjpp is a Java package I wrote for doing research in genetic
programming. It is a port of the gpc++ kernel written by Adam
Fraser and Thomas Weinbrenner. Included in the package are
four of Koza's standard examples: the artificial ant, the
hopping lawnmower, symbolic regression, and the boolean
multiplexer. Here is a partial list of its features:
<UL>
<LI>graphic output of expression trees</LI>
<LI>efficient diversity checking </LI>
<LI>Koza's greedy over-selection option for large populations</LI>
<LI>extensible GPRun class that encapsulates most details of a
genetic programming test</LI>
<LI>more robust and efficient streaming code, with automatic 
checkpoint and restart built into the GPRun class</LI>
<LI>an explicit complexity limit that can be set on each GP</LI>
<LI>additional configuration variables to allow more testing 
without recompilation</LI>
<LI>support for automatically defined functions (ADFs)</LI>
<LI>tournament and fitness proportionate selection</LI>
<LI>demetic grouping</LI>
<LI>optional steady state population</LI>
<LI>subtree crossover</LI>
<LI>swap and shrink mutation</LI>
</UL>
</P>

<P>
<A NAME="jaga"></A> </P>
<DT><B>jaga</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://cs.felk.cvut.cz/~koutnij/studium/jaga/jaga.html">cs.felk.cvut.cz/~koutnij/studium/jaga/jaga.html</A></LI>
</UL>
</P>
<P>Simple genetic algorithm package written in Java.</P>

<P>
<A NAME="JGAP"></A> </P>
<DT><B>JGAP</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://jgap.sourceforge.net/">http://jgap.sourceforge.net/</A></LI>
</UL>
</P>
<P>JGAP (pronounced "jay-gap") is a Genetic Algorithms and Genetic
Programming component provided as a Java framework. It provides basic
genetic mechanisms that can be easily used to apply evolutionary
principles to problem solutions.</P>
<P>JGAP was designed to be very easy to use "out of the box", while also
designed to be highly modular so that more adventurous users can easily
plug-in custom genetic operators and other sub-components.</P>

<P>
<A NAME="lil-gp"></A> </P>
<DT><B>lil-gp</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://garage.cse.msu.edu/software/lil-gp/">http://garage.cse.msu.edu/software/lil-gp/</A></LI>
</UL>
</P>

<DT><B>patched lil-gp *</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://cs.gmu.edu/~sean/research/lil-gp-patch/">http://cs.gmu.edu/~sean/research/lil-gp-patch/</A></LI>
</UL>
</P>
<P>lil-gp is a generic 'C' genetic programming tool. It was written
with a number of goals in mind: speed, ease of use and support for a
number of options including:
<UL>
<LI> Generic 'C' program that runs on UNIX workstations</LI>
<LI> Support for multiple population experiments, using
arbitrary and user settable topologies for exchange, for
a single processor (i.e., you can do multiple population gp
experiments on your PC).</LI>
<LI> lil-gp manipulates trees of function pointers which are
allocated in single, large memory blocks for speed and to
avoid swapping.</LI>
</UL>

* The patched lil-gp kernel is strongly-typed, with modifications on
multithreading, coevolution, and other tweaks and features.</P>

<P>
<A NAME="Lithos"></A> </P>
<DT><B>Lithos</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.esatclear.ie/~rwallace/lithos.html">www.esatclear.ie/~rwallace/lithos.html</A></LI>
</UL>
</P>
<P>Lithos is a stack based evolutionary computation system. Unlike most EC
systems, its representation language is computationally complete, while
also being faster and more compact than the S-expressions used in
genetic programming. The version presented here applies the system to
the game of Go, but can be changed to other problems by simply plugging
in a different evaluation function. ANSI C source code is provided.</P>

<P>
<A NAME="Open BEAGLE"></A> </P>
<DT><B>Open BEAGLE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://beagle.gel.ulaval.ca/">beagle.gel.ulaval.ca</A></LI>
</UL>
</P>
<P>Open BEAGLE is a C++ evolutionary computation framework. It provides a
high-level software environment to do any kind of evolutionary
computation, with support for tree-based genetic programming, bit
string and real-valued genetic algorithms, evolution strategy,
co-evolution, and evolutionary multi-objective optimization.</P>

<P>
<A NAME="PGAPack"></A> </P>
<DT><B>PGAPack</B><DD><P>Parallel Genetic Algorithm Library
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.mcs.anl.gov/pub/pgapack/">ftp://ftp.mcs.anl.gov/pub/pgapack/</A></LI>
</UL>
</P>
<P>PGAPack is a general-purpose, data-structure-neutral, parallel
genetic algorithm library. It is intended to provide most capabilities
desired in a genetic algorithm library, in an integrated, seamless,
and portable manner. Key features are in PGAPack V1.0 include:
<UL>
<LI>Callable from Fortran or C.</LI>
<LI>Runs on uniprocessors, parallel computers, and workstation networks.</LI>
<LI>Binary-, integer-, real-, and character-valued native data types. </LI>
<LI>Full extensibility to support custom operators and new data types.</LI>
<LI>Easy-to-use interface for novice and application users.</LI>
<LI>Multiple levels of access for expert users.</LI>
<LI>Parameterized population replacement.</LI>
<LI>Multiple crossover, mutation, and selection operators.</LI>
<LI>Easy integration of hill-climbing heuristics.</LI>
<LI>Extensive debugging facilities.</LI>
<LI>Large set of example problems.</LI>
<LI>Detailed users guide.</LI>
</UL>
</P>

<P>
<A NAME="PIPE"></A> </P>
<DT><B>PIPE</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.idsia.ch/pub/rafal/">ftp.idsia.ch/pub/rafal</A></LI>
</UL>
</P>
<P>Probabilistic Incremental Program Evolution (PIPE) is a novel
technique for automatic program synthesis. The software is written in C.
It ...</P>
<P>
<UL>
<LI>is easy to install (comes with an automatic installation tool).</LI>
<LI>is easy to use: setting up PIPE_V1.0 for different 
problems requires a minimal amount of programming. User-written, 
application-independent program parts can easily be reused.</LI>
<LI>is efficient: PIPE_V1.0 has been tuned to speed up
performance.</LI>
<LI>is portable: comes with source code (optimized for SunOS 
5.5.1).</LI>
<LI>is extensively documented(!) and contains three example
applications.</LI>
<LI>supports statistical evaluations: it facilitates running
multiple experiments and collecting results in output files.</LI>
<LI>includes testing tool for testing generalization of evolved
programs.</LI>
<LI>supports floating point and integer arithmetic.</LI>
<LI>has extensive output features.</LI>
<LI>For lil-gp users: Problems  set up for lil-gp 1.0 can be 
easily ported to PIPE_v1.0. The testing tool can also be
used to process programs evolved by lil-gp 1.0.</LI>
</UL>
</P>

<P>
<A NAME="plop"></A> </P>
<DT><B>plop</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://code.google.com/p/plop/">http://code.google.com/p/plop/</A></LI>
</UL>
</P>
<P>A Common Lisp framework for experimenting with meta-optimizing semantic
evolutionary search (
<A HREF="http://metacog.org/doc.html">MOSES</A>) and related approaches to learning with probability
distributions over program spaces based on:</P>
<P>
<UL>
<LI>reduction to normal form</LI>
<LI>representation-building</LI>
<LI>deme (sub-population) management</LI>
<LI>probabilistic model-building (aka estimation-of-distribution algorithms) </LI>
</UL>
</P>

<P>
<A NAME="Pyevolve"></A> </P>
<DT><B>Pyevolve</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pyevolve.sourceforge.net/">http://pyevolve.sourceforge.net/</A></LI>
</UL>
</P>
<P>Pyevolve was developed to be a complete genetic algorithm framework,
the main objectives of Pyevolve are:</P>
<P>
<UL>
<LI>written in pure python, to maximize the cross-platform issue;</LI>
<LI>easy to use API, the API must be easy for end-user;</LI>
<LI>see the evolution, the user can and must see and interact with
the evolution statistics, graphs and etc;</LI>
<LI>extensible, the API must be extensible, the user can create new
representations, genetic operators like crossover, mutation and etc;</LI>
<LI>fast, the design must be optimized for performance;</LI>
<LI>common features, the framework must implement the most common
features: selectors like roulette wheel, tournament, ranking, uniform.
Scaling schemes like linear scaling, etc;</LI>
<LI>default parameters, we must have default operators, settings, 
etc in all options;</LI>
<LI>open-source, the source is for everyone, not for only one.</LI>
</UL>
</P>

<P>
<A NAME="pygp"></A> </P>
<DT><B>pygp</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/pygp/files/">http://sourceforge.net/projects/pygp/files/</A></LI>
</UL>
</P>
<P>Your basic genetic algorithm package for python.</P>

<P>
<A NAME="tinygp"></A> </P>
<DT><B>tinygp</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.laserpirate.com/as3tinygp/">http://www.laserpirate.com/as3tinygp/</A></LI>
</UL>
</P>
<P>Small genetic programming library in C++ and ActionScript 3 (Javascript
engine embedded in Flash) with flash demos.</P>
<P>This GP library uses the standard Koza expression tree program
representation. It uses the 'grow' algorithm to generate random
expressions. Mutation is performed by selecting a random subexpression
in an expression tree, and replacing it with a new random expression
(which satisfies the maximum tree depth constraint). Crossover (mating)
between two expressions is performed by selecting a random
subexpression in each parent, then exchanging them (although it only
makes on child, not two).</P>
<P>In addition to the core code for creating, mutating, mating and
evaluating expressions, the library includes a steady-state genetic
algorithm with tournament selection, and a worst-out, elitist
replacement policy (i.e. when a new child is created, it replaces the
worse member of the population, only if it is better). </P>

<P>
<A NAME="txevolver"></A> </P>
<DT><B>txevolver</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="https://launchpad.net/txevolver">https://launchpad.net/txevolver</A></LI>
</UL>
</P>
<P>A Twisted-based set of libraries for performing calculations of genetic
algorithms as well as genetic programs in an asynchronous, distributed
manner.</P>


</DL>
</P>


<H2><A NAME="ss4.2">4.2</A> <A HREF="AI-Alife-HOWTO.html#toc4.2">EC software kits/applications</A>
    </H2>


<P>These are various applications, software kits, etc. meant for research
in the field of evolutionary computing. Their ease of use will vary, as they
were designed to meet some particular research interest more than as
an easy to use commercial package.</P>
<P>
<DL>

<P>
<A NAME="ADATE"></A> </P>
<DT><B>ADATE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-ia.hiof.no/~rolando/adate_intro.html">www-ia.hiof.no/~rolando/adate_intro.html</A></LI>
</UL>
</P>
<P>ADATE (Automatic Design of Algorithms Through Evolution) is a system 
for automatic programming i.e., inductive inference of algorithms, 
which may be the best way to develop artificial and general 
intelligence.</P>

<P>The ADATE system can automatically generate non-trivial and novel
algorithms. Algorithms are generated through large scale combinatorial
search that employs sophisticated program transformations and
heuristics. The ADATE system is particularly good at synthesizing
symbolic, functional programs and has several unique qualities.</P>


<P>
<A NAME="esep-xesep"></A> </P>
<DT><B>esep &amp; xesep</B><DD><P>
<UL>
<LI>Web site(esep): 
<A HREF="http://www.iit.edu/~elrad/esep.html">www.iit.edu/~elrad/esep.html</A></LI>
<LI>Web site(xesep): 
<A HREF="http://www.iit.edu/~elrad/xesep.html">www.iit.edu/~elrad/xesep.html</A></LI>
</UL>
</P>

<P>This is a new scheduler, called Evolution Scheduler, based on
Genetic Algorithms and Evolutionary Programming. It lives with
original Linux priority scheduler.This means you don't have to
reboot to change the scheduling policy. You may simply use the
manager program esep to switch between them at any time, and
esep itself is an all-in-one for scheduling status, commands,
and administration. We didn't intend to remove the original
priority scheduler; instead, at least, esep provides you with
another choice to use a more intelligent scheduler, which
carries out natural competition in an easy and effective way.</P>
<P>Xesep is a graphical user interface to the esep (Evolution
Scheduling and Evolving Processes). It's intended to show users
how to start, play, and feel the Evolution Scheduling and
Evolving Processes, including sub-programs to display system
status, evolving process status, queue status, and evolution
scheduling status periodically in as small as one mini-second.</P>

<P>
<A NAME="Corewars"></A> </P>
<DT><B>Corewars</B><DD><P>
<UL>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/corewars/">http://sourceforge.net/projects/corewars/</A></LI>
</UL>
</P>
<P>Corewars is a game which simulates a virtual machine with a number of
programs. Each program tries to crash the others. The program that
lasts the longest time wins. A number of sample programs are provided
and new programs can be written by the player. Screenshots are
available at the Corewars homepage.</P>

<P>
<A NAME="JCASim"></A> </P>
<DT><B>JCASim</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.jweimar.de/jcasim/">http://www.jweimar.de/jcasim/</A></LI>
</UL>
</P>
<P>JCASim is a general-purpose system for simulating cellular automata in
Java. It includes a stand-alone application and an applet for web
presentations. The cellular automata can be specified in Java, in CDL,
or using an interactive dialogue. The system supports many different
lattice geometries (1-D, 2-D square, hexagonal, triangular, 3-D),
neighborhoods, boundary conditions, and can display the cells using
colors, text, or icons.</P>

<P>
<A NAME="JGProg"></A> </P>
<DT><B>JGProg</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://jgprog.sourceforge.net/">jgprog.sourceforge.net</A></LI>
</UL>
</P>
<P>Genetic Programming (JGProg) is an open-source Java implementation of
a strongly-typed Genetic Programming experimentation platform. Two 
example "worlds" are provided, in which a population evolves and 
solves the problem.</P>


</DL>
</P>




<HR>
<H2><A NAME="Alife &amp; Complex Systems"></A> <A NAME="s5">5.</A> <A HREF="AI-Alife-HOWTO.html#toc5">Alife &amp; Complex Systems</A>    </H2>


<P>Alife takes yet another approach to exploring the mysteries of
intelligence.  It has many aspects similar to EC and Connectionism, but
takes these ideas and gives them a meta-level twist. Alife emphasizes the
development of intelligence through <I>emergent</I> behavior of
<I>complex adaptive systems</I>.  Alife stresses the social or group
based aspects of intelligence. It seeks to understand life and survival. By
studying the behaviors of groups of 'beings' Alife seeks to discover the
way intelligence or higher order activity emerges from seemingly simple
individuals. Cellular Automata and Conway's Game of Life are probably the
most commonly known applications of this field. Complex Systems
(abbreviated CS) are very similar to alife in the way the are approached,
just more general in definition (ie.  alife is a type of complex system).
Usually complex system software takes the form of a simulator.</P>


<H2><A NAME="ss5.1">5.1</A> <A HREF="AI-Alife-HOWTO.html#toc5.1">Alife &amp; CS class/code libraries</A>
    </H2>


<P>These are libraries of code or classes for use in programming within
the artificial life field.  They are not meant as stand alone
applications, but rather as tools for building your own applications.</P>

<P>
<DL>

<P>
<A NAME="AgentFarms"></A> </P>
<DT><B>AgentFarms</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.agentfarms.net">http://www.agentfarms.net</A></LI>
</UL>
</P>
<P>Agent Farms is a system for modelling and simulation of complex,
multi-agent based systems. The system can be used for:
<UL>
<LI>Creating models of multi-agent systems</LI>
<LI>Interactive and distributed simulation</LI>
<LI>Observation and visualisation of the simulation</LI>
<LI>Population modification and migration</LI>
</UL>
</P>

<P>
<A NAME="Biome"></A> </P>
<DT><B>Biome</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/biome/">http://sourceforge.net/projects/biome/</A></LI>
</UL>
</P>
<P>Biome is a C++ library aimed at individual-based/agent-based
simulations. It is somewhat similar to Swarm, EcoSim or Simex but tries
to be more efficient and less monolithic without compromising object-
oriented design. Currently there is an event based scheduling system, a
C++ified Mersenne-Twister RNG, several general analysis classes, some
Qt-based GUI classes, a very basic persistence/database framework (used
also for parameter storage) and many other small useful things.</P>

<P>
<A NAME="CAGE"></A> </P>
<DT><B>CAGE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.alcyone.com/software/cage/">http://www.alcyone.com/software/cage/</A></LI>
</UL>
</P>
<P>CAGE is a fairy generic and complete cellular automaton simulation
engine in Python. It supports both 1D and 2D automata, a variety of
prepackaged rules, and the concept of "agents" which can move about
independently on the map for implementing agent behavior.</P>

<P>
<A NAME="Cellular"></A> </P>
<DT><B>Cellular</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://zhar.net/howto/homeless/cellular/">http://zhar.net/howto/homeless/cellular/</A></LI>
</UL>
</P>
<P>The Cellular automata programming system consists of a compiler for the
Cellang cellular automata programming language, along with the
corresponding documentation, viewer, and various tools. Postscript
versions of the tutorial and language reference manual are available for
those wanting more detailed information. The most important
distinguishing features of Cellang, include support for:</P>
<P>
<UL>
<LI>any number of dimensions;</LI>
<LI>compile time specification of each dimensions size;
cell neighborhoods of any size (though bounded at compile time)
and shape;</LI>
<LI>positional and time dependent neighborhoods;</LI>
<LI>associating multiple values (fields), including arrays,
with each cell;</LI>
<LI>associating a potentially unbounded number of mobile
agents [ Agents are mobile entities based on a mechanism of
the same name in the Creatures system, developed by Ian
Stephenson (ian@ohm.york.ac.uk).] with each cell; and</LI>
<LI>local interactions only, since it is impossible to
construct automata that contain any global control or
references to global variables.</LI>
</UL>
</P>

<P>
<A NAME="Integrating Modelling Toolkit"></A> </P>
<DT><B>Integrating Modelling Toolkit</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/imt/">sourceforge.net/projects/imt/</A></LI>
</UL>
</P>
<P>The Integrating Modelling Toolkit (IMT) is a generic, comprehensive,
and extensible set of abstractions allowing definition and use of
interoperable model components.  Modellers create an IMT "world" made
of IMT "agents" that will perform each a particular phase of a
modelling task.  The core set of IMT agents can describe generic,
modular, distributed model components, either native to the IMT or
integrating existing simulation toolkits, specialized for tasks that
range from simple calculation of functions in an interpreted language
to spatially explicit simulation, model optimization, GIS analysis,
visualization and advanced statistical analysis.  IMT agents are
designed to easily "glue" together in higher-level simulations
integrating different modelling paradigms and toolkits.  The IMT can be
easily extended by users and developers through a convenient plug-in
mechanism</P>

<P>
<A NAME="MAML"></A> </P>
<DT><B>MAML</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.maml.hu/">http://www.maml.hu/</A></LI>
</UL>
</P>
<P>The current version of MAML is basically an extension to Objective-C
(using the Swarm libraries). It consists of a couple of
'macro-keywords' that define the general structure of a simulation. The
remaining must be filled with pure swarm-code. A MAML-to-Swarm (named
xmc) compiler is also being developed which compiles the source code
into a swarm application.</P>

<P>
<A NAME="MASON"></A> </P>
<DT><B>MASON</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://cs.gmu.edu/~eclab/projects/mason/">http://cs.gmu.edu/~eclab/projects/mason/</A></LI>
</UL>
</P>
<P>MASON Stands for Multi-Agent Simulator Of Neighborhoods... or
Networks... or something...</P>
<P>MASON is a fast discrete-event multi-agent simulation library core in
Java, designed to be the foundation for large custom-purpose Java
simulations, and also to provide more than enough functionality for
many lightweight simulation needs. MASON contains both a model library
and an optional suite of visualization tools in 2D and 3D.</P>

<P>
<A NAME="SimWorld"></A> </P>
<DT><B>SimWorld</B><DD><P>
<UL>
<LI>Web site: http://www.nd.edu/&nbsp;airolab/simworld/</LI>
<LI>New Web site?: http://hrilab.tufts.edu/</LI>
</UL>
</P>
<P>SimWorld is a free artificial life simulation (based on the free
<A HREF="#SimAgent">SimAgent</A>
 toolkit developed by Aaron Sloman), which provides
functionality for running different interacting agents and objects in a
simulated, continuous environment.  The agents are controlled by rules
written in the powerful rule interpreter.   New behaviors of agents can
be defined without any programming knowledge.</P>

<P>
<A NAME="Swarm"></A> </P>
<DT><B>Swarm</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.swarm.org/wiki/Swarm_main_page">www.swarm.org/wiki/Swarm_main_page</A></LI>
<LI>FTP site: 
<A HREF="http://ftp.swarm.org/pub/swarm/">ftp.swarm.org/pub/swarm/</A></LI>
</UL>
</P>

<P>The swarm Alife simulation kit. Swarm is a simulation environment
which facilitates development and experimentation with simulations
involving a large number of agents behaving and interacting within a
dynamic environment.  It consists of a collection of classes and
libraries written in Objective-C and allows great flexibility in
creating simulations and analyzing their results.  It comes with three
demos and good documentation. </P>


</DL>
</P>



<H2><A NAME="ss5.2">5.2</A> <A HREF="AI-Alife-HOWTO.html#toc5.2">Alife &amp; CS software kits, applications, etc.</A>
    </H2>


<P>These are various applications, software kits, etc. meant for research
in the field of artificial life. Their ease of use will vary, as they
were designed to meet some particular research interest more than as
an easy to use commercial package.</P>
<P>
<DL>

<P>
<A NAME="Achilles"></A> </P>
<DT><B>Achilles</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://achilles.sourceforge.net/">http://achilles.sourceforge.net/</A></LI>
</UL>
</P>
<P>Achilles is an evolution simulation based on Larry Yaeger's PolyWorld.
It uses Hebbian neural networks, and an extremely simplified physical
model that allows virtual organisms to interact freely in a simulated
environment.</P>

<P>
<A NAME="Avida"></A> </P>
<DT><B>Avida</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://avida.devosoft.org/">http://avida.devosoft.org/</A></LI>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/avida/">http://sourceforge.net/projects/avida/</A></LI>
</UL>
</P>
<P>The computer program Avida is an auto-adaptive genetic system designed
primarily for use as a platform in Artificial Life research. The Avida
system is based on concepts similar to those employed by the Tierra
program, that is to say it is a population of self-reproducing strings
with a Turing-complete genetic basis subjected to Poisson-random
mutations. The population adapts to the combination of an intrinsic
fitness landscape (self-reproduction) and an externally imposed
(extrinsic) fitness function provided by the researcher. By studying 
this system, one can examine evolutionary adaptation, general traits of
living systems (such as self-organization), and other issues pertaining
to theoretical or evolutionary biology and dynamic systems.</P>

<P>
<A NAME="Biogenesis"></A> </P>
<DT><B>Biogenesis</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://biogenesis.sourceforge.net/">http://biogenesis.sourceforge.net/</A></LI>
</UL>
</P>
<P>Biogenesis is an artificial life program that simulates the processes
involved in the evolution of organisms. It shows colored segment based
organisms that mutate and evolve in a 2D environment. Biogenesis is
based on Primordial Life.</P>

<P>
<A NAME="breve"></A> </P>
<DT><B>breve</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.spiderland.org/breve/">www.spiderland.org/breve/</A></LI>
</UL>
</P>
<P>Breve is a free software package which makes it easy to build 3D
simulations of decentralized systems and artificial life. Users define
the behaviors of agents in a 3D world and observe how they interact.
Breve includes physical simulation and collision detection so you can
simulate realistic creatures, and an OpenGL display engine so you can
visualize your simulated worlds.</P>

<P>
<A NAME="BugsX"></A> </P>
<DT><B>BugsX</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="https://github.com/porridge/bugsx">https://github.com/porridge/bugsx</A></LI>
</UL>
</P>
<P>Display and evolve biomorphs. It is a program which draws the
biomorphs based on parametric plots of Fourier sine and cosine series
and let's you play with them using the genetic algorithm.</P>

<P>
<A NAME="Creatures Docking Station"></A> </P>
<DT><B>Creatures Docking Station</B><DD><P>
<UL>
<LI>Linux info: 
<A HREF="http://www.creaturesdockingstation.com/">http://www.creaturesdockingstation.com/</A></LI>
</UL>
</P>
<P>This is a free version of the Creatures3 ALife game. It has fewer
species and a small 'space-station' world, but can connect to other
worlds over the internet and (if you have the windows version of the
game) can connect to your C3 world. The game itself revolves around
breeding and training the alife creatures, 'Norns'. Its strikes a
pretty nice balance between fun and science, or so I'm told.</P>
<P>(summary written by Steve Grand included below)</P>
<P>The eponymous creatures in this computer game are called Norns, and the
world's population of them at one stage hovered around the five million
mark, making them more common than many familiar natural species. Each
norn is composed of thousands of tiny simulated biological components,
such as neurons, biochemicals, chemoreceptors, chemoemitters and genes.
The norns' genes dictate how these components are assembled to make
complete organisms, and the creatures' behaviour then emerges from the
interactions of those parts, rather than being explicitly 'programmed
in'.</P>
<P>The norns are capable of learning about their environment, either by
being shown things by their owners or through learning by their own
mistakes. They must learn for themselves how to find food and how to
interact with the many objects in their environment. They can interact
with their owners, using simple language, and also with each other.
They can form relationships and produce offspring, which inherit their
neural and biochemical structure from their parents and are capable of
open-ended evolution over time. They can fall prey to a variety of
diseases (as well as genetic defects) and can be treated with
appropriate medicines.</P>

<P>
<A NAME="Critterding"></A> </P>
<DT><B>Critterding</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://critterding.sourceforge.net/">http://critterding.sourceforge.net/</A></LI>
<LI>Web site (telepathic-critterdrug): 
<A HREF="http://m-net.arbornet.org/~flamoot/telepathic-critterdrug.html">http://m-net.arbornet.org/~flamoot/telepathic-critterdrug.html</A></LI>
</UL>
</P>
<P>Critterding is a "Petri dish" universe in 3D that demonstrates evolving
artificial life. Critters start out with completely random brains and
bodies, but will automatically start evolving into something with much
better survival skills. The lifeforms are placed in an artificial
environment where there neural net 'brains' can evolve.</P>
<P>Telepathic-critterdrug is a fork of Critterding introducing a
communications medium (called a retina) and psychoactive substances
that effect this retina.</P>

<P>
<A NAME="dblife-dblifelib"></A> </P>
<DT><B>dblife &amp; dblifelib</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://ibiblio.org/pub/Linux/science/ai/life/">ibiblio.org/pub/Linux/science/ai/life/</A></LI>
</UL>
</P>
<P><I>dblife:</I> Sources for a fancy Game of Life program for X11
(and curses).  It is not meant to be incredibly fast (use xlife for
that:-).  But it IS meant to allow the easy editing and viewing of
Life objects and has some powerful features.  The related dblifelib
package is a library of Life objects to use with the program.</P>
<P><I>dblifelib:</I> This is a library of interesting Life objects,
including oscillators, spaceships, puffers, and other weird things.
The related dblife package contains a Life program which can read the
objects in the Library.</P>

<P>
<A NAME="Drone"></A> </P>
<DT><B>Drone</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cscs.umich.edu/Software/Drone/">www.cscs.umich.edu/Software/Drone/</A></LI>
</UL>
</P>
<P>Drone is a tool for automatically running batch jobs of a simulation
program. It allows sweeps over arbitrary sets of parameters, as well
as multiple runs for each parameter set, with a separate random seed
for each run. The runs may be executed either on a single computer or
over the Internet on a set of remote hosts. Drone is written in Expect
(an extension to the Tcl scripting language) and runs under Unix. It
was originally designed for use with the Swarm agent-based simulation
framework, but Drone can be used with any simulation program that
reads parameters from the command line or from an input file.</P>

<P>
<A NAME="EcoLab"></A> </P>
<DT><B>EcoLab</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ecolab.sourceforge.net/">http://ecolab.sourceforge.net/</A></LI>
</UL>
</P>
<P>EcoLab is a system that implements an abstract ecology model. It
is written as a set of Tcl/Tk commands so that the model
parameters can easily be changed on the fly by means of editing
a script. The model itself is written in C++.</P>

<P>
<A NAME="Framsticks"></A> </P>
<DT><B>Framsticks</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.frams.alife.pl/">http://www.frams.alife.pl/</A></LI>
</UL>
</P>
<P>Framsticks is a three-dimensional life simulation project. Both
mechanical structures ("bodies") and control systems ("brains") of
creatures are modeled. It is possible to design various kinds of
experiments, including simple optimization (by evolutionary
algorithms), co-evolution, open-ended and spontaneous evolution,
distinct gene pools and populations, diverse genotype/phenotype
mappings, and species/ecosystems modeling.</P>

<P>
<A NAME="Fluidiom"></A> </P>
<DT><B>Fluidiom</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ostatic.com/fluidiom">http://ostatic.com/fluidiom</A></LI>
</UL>
</P>
<P>Evolutionary based alife platform. Has a game like feel which makes it
fun while still allowing for some interesting experimentation.</P>
<P>It takes a minimalist approach to spatial structure to make a body,
adds articulation in the form of muscles, and then lets evolution take
over to see if these bodies can learn to walk, run, crawl, or slither
from one place to the other.</P>

<P>
<A NAME="Game Of Life"></A> </P>
<DT><B>Game Of Life (GOL)</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://ibiblio.org/pub/Linux/science/ai/life/">ibiblio.org/pub/Linux/science/ai/life/</A></LI>
</UL>
</P>
<P>GOL is a simulator for conway's game of life (a simple cellular
automata), and other simple rule sets. The emphasis here is on
speed and scale, in other words you can setup large and fast
simulations.</P>

<P>
<A NAME="gant"></A> </P>
<DT><B>gant</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://gant.sourceforge.net/">gant.sourceforge.net</A></LI>
</UL>
</P>
<P>This project is an ANSI C++ implementation of the Generalized Langton
Ant, which lives on a torus.</P>

<P>
<A NAME="gLife"></A> </P>
<DT><B>gLife</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://glife.sourceforge.net/">glife.sourceforge.net</A></LI>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/glife/">sourceforge.net/projects/glife/</A></LI>
</UL>
</P>
<P>This program is similiar to "Conway's Game of Life" but yet it is very
different. It takes "Conway's Game of Life" and applies it to a society
(human society). This means there is a very different (and much larger)
rule set than in the original game. Things need to be taken into account
such as the terrain, age, sex, culture, movement, etc</P>

<P>
<A NAME="Golly"></A> </P>
<DT><B>Golly</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://golly.sourceforge.net/">golly.sourceforge.net</A></LI>
</UL>
</P>
<P>An open source, cross-platform implementation of John Conway's Game of
Life with an unbounded universe and capable of running patterns faster
and further than ever before. It has many features such as;</P>
<P>
<UL>
<LI>Reads RLE, Life 1.05/1.06, and macrocell formats.</LI>
<LI>Supports Wolfram's 1D rules.</LI>
<LI>Can paste in patterns from the clipboard. </LI>
<LI>Scriptable via Python.</LI>
</UL>
</P>

<P>
<A NAME="Langton's Ant"></A> </P>
<DT><B>Langton's Ant</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://theory.org/software/ant/">http://theory.org/software/ant/</A></LI>
</UL>
</P>
<P>Langton's Ant is an example of a finite-state cellular automata. The
ant (or ants) start out on a grid. Each cell is either black or white.
If the ant is on a black square, it turns right 90 and moves forward
one unit. If the ant is on a white square, it turns left 90 and moves
forward one unit.  And when the ant leaves a square, it inverts the
color. The neat thing about Langton's Ant is that no matter what
pattern field you start it out on, it eventually builds a "road," which
is a series of 117 steps that repeat indefinitely, each time leaving
the ant displaced one pixel vertically and horizontally.</P>

<P>
<A NAME="LEE"></A> </P>
<DT><B>LEE</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.informatics.indiana.edu/fil/LEE/">www.informatics.indiana.edu/fil/LEE/</A></LI>
</UL>
</P>
<P>LEE (Latent Energy Environments) is both an Alife model and a
software tool to be used for simulations within the framework of that
model. We hope that LEE will help understand a broad range of issues
in theoretical, behavioral, and evolutionary biology. The LEE tool
described here consists of approximately 7,000 lines of C code and
runs in both Unix and Macintosh platforms.</P>

<P>
<A NAME="MATREM"></A> </P>
<DT><B>MATREM</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.romansland.nl/matrem/">http://www.romansland.nl/matrem/</A></LI>
</UL>
</P>
<P>Matrem is a computer program that simulates life. It belongs to the
emerging science of "artificial life", which studies evolution and
complex systems in general by simulation. Matrem is also a game, where
players compete to create the fittest life form. Their efforts are the
driving force behind the program.</P>

<P>
<A NAME="Nanopond"></A> </P>
<DT><B>Nanopond</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://adam.ierymenko.name/nanopond.shtml">http://adam.ierymenko.name/nanopond.shtml</A></LI>
</UL>
</P>
<P>Nanopond is a "corewar style" evolvable instruction set based virtual
machine written in C. It is similar in design to Tierra and Avida but
considerably smaller and simpler. Version 1.0 weights in at only 840
lines of C code, the majority of which are comments! It is very highly
optimized and supports simple color visualization using the SDL (Simple
Directmedia Layer) library.</P>
<P>More information can be learned by reading the Nanopond source code,
which is very well commented.</P>

<P>
<A NAME="Noble Ape"></A> </P>
<DT><B>Noble Ape</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nobleape.com/sim/">www.nobleape.com/sim/</A></LI>
</UL>
</P>
<P>The Noble Ape Simulation has been developed (as the Nervana Simulation)
since 1996. The aim of the simulation is to create a detailed
biological environment and a cognitive simulation. The Simulation is
intended as a palette for open source development. It provides a stable
means of simulating large scale environments and cognitive processes.</P>
<P>It features a number of autonomous simulation components including a
landscape simulation, biological simulation, weather simulation,
sentient creature (Noble Ape) simulation and a simple intelligent-agent
scripting language (ApeScript).</P>
<P>The code is currently (2007) used by Apple Inc and by INTEL for
processor optimization and performance tuning. Apple includes it with
their CHUD performance and debugging developer tool set.</P>
<P>
<A NAME="Polyworld"></A> </P>
<DT><B>Polyworld</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/polyworld">http://sourceforge.net/projects/polyworld</A></LI>
</UL>
</P>
<P>PolyWorld is a computational ecology that I developed to explore issues
in Artificial Life. Simulated organisms reproduce sexually, fight and
kill and eat each other, eat the food that grows throughout the world,
and either develop successful strategies for survival or die. An
organism's entire behavioral suite (move, turn, attack, eat, mate,
light) is controlled by its neural network "brain". Each brain's
architecture--it's neural wiring diagram--is determined from its
genetic code, in terms of number, size, and composition of neural
clusters (excitatory and inhibitory neurons) and the types of
connections between those clusters (connection density and topological
mapping). Synaptic efficacy is modulated via Hebbian learning, so, in
principle, the organisms have the ability to learn during the course of
their lifetimes. The organisms perceive their world through a sense of
vision, provided by a computer graphic rendering of the world from each
organism's point of view. The organisms' physiologies are also encoded
genetically, so both brain and body, and thus all components of
behavior, evolve over multiple generations. A variety of "species",
with varying individual and group survival strategies have emerged in
various simulations, displaying such complex ethological behaviors as
swarming/flocking, foraging, and attack avoidance.</P>

<P>
<A NAME="POSES++"></A> </P>
<DT><B>POSES++</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.gpc.de/e_poses.html">http://www.gpc.de/e_poses.html</A></LI>
</UL>
</P>
<P>The POSES++ software tool supports the development and
simulation of models.  Regarding the simulation technique models
are suitable reproductions of real or planned systems for their
simulative investigation.</P>

<P>In all industrial sectors or branches POSES++ can model and
simulate any arbitrary system which is based on a discrete and
discontinuous behaviour. Also continuous systems can mostly be
handled like discrete systems e.g., by quantity discretion and
batch processing.</P>

<P>
<A NAME="Tierra"></A> </P>
<DT><B>Tierra</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://life.ou.edu/tierra/">http://life.ou.edu/tierra/</A></LI>
</UL>
</P>

<P>Tierra's written in the C programming language. This source code
creates a virtual computer and its operating system, whose
architecture has been designed in such a way that the executable
machine codes are evolve-able. This means that the machine code can be
mutated (by flipping bits at random) or recombined (by swapping
segments of code between algorithms), and the resulting code remains
functional enough of the time for natural (or presumably artificial)
selection to be able to improve the code over time.</P>

<P>
<A NAME="Trend"></A> </P>
<DT><B>Trend</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.complex.iastate.edu/download/Trend/">www.complex.iastate.edu/download/Trend/</A></LI>
</UL>
</P>
<P>Trend is a general purpose cellular automata simulation environment
with an integrated high level language compiler, a beautiful graphical
user interface, and a fast, three stage cached simulation engine. This
is the simulation system that was used to discover the first emergent
self-replicating cellular automata rule set, and the first problem
solving self-replication loop.</P>
<P>Since its simulator is very flexible with regard to cellular space
sizes, cell structures, neighborhood structures and cellular automata
rules, Trend can simulate almost all one or two-dimensional cellular
automata models. It also has a smart backtracking feature which
simplifies rule set development a lot by allowing users to go back to a
previous stage of simulation! With other advanced features, Trend is
probably the most easy to use 2-dimensional cellular automata
simulator.</P>
<P>Also available is jTrend. A Java version of Trend.</P>

<P>
<A NAME="XLIFE"></A> </P>
<DT><B>XLIFE</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://linux.maruhn.com/sec/xlife.html">http://linux.maruhn.com/sec/xlife.html</A></LI>
</UL>
</P>
<P>This program will evolve patterns for John Horton Conway's game
of Life.  It will also handle general cellular automata with the
orthogonal neighborhood and up to 8 states (it's possible to recompile
for more states, but very expensive in memory).  Transition rules and
sample patterns are provided for the 8-state automaton of E. F. Codd,
the Wireworld automaton, and a whole class of `Prisoner's Dilemma'
games.</P>

<P>
<A NAME="Xtoys"></A> </P>
<DT><B>Xtoys</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://thy.phy.bnl.gov/www/xtoys/xtoys.html">http://thy.phy.bnl.gov/www/xtoys/xtoys.html</A></LI>
</UL>
</P>
<P>xtoys contains a set of cellular automata simulators for X windows.
Programs included are:
<UL>
<LI> xising --- a two dimensional Ising model simulator,</LI>
<LI> xpotts --- the two dimensional Potts model,</LI>
<LI> xautomalab ---  a totalistic cellular automaton simulator,</LI>
<LI> xsand --- for the Bak, Tang, Wiesenfeld sandpile model,</LI>
<LI> xwaves --- demonstrates three different wave equations,</LI>
<LI> schrodinger --- play with the Scrodinger equation in an
adjustable potential.</LI>
</UL>
</P>

</DL>
</P>

<HR>
<H2><A NAME="Agents"></A> <A NAME="Agents &amp; Robotics"></A> <A NAME="s6">6.</A> <A HREF="AI-Alife-HOWTO.html#toc6">Agents &amp; Robotics</A>    </H2>


<P>Software brains for computers that do stuff. Everythin from fun and
games to data mining to physical robotics. This is a great hobbiest
area of AI with many areas of interest to pursue. I've broken it down
loosely into 2 sections. AI for purely software based agents and that
for embodied agents (even if only simulated).</P>


<H2><A NAME="Software Agents"></A> <A NAME="ss6.1">6.1</A> <A HREF="AI-Alife-HOWTO.html#toc6.1">Software Agents</A>
        </H2>


<P>Also known as intelligent software agents or just agents, this
area of AI research deals with simple applications of small
programs that aid the user in his/her work. They can be mobile
(able to stop their execution on one machine and resume it on
another) or static (live in one machine). They are usually
specific to the task (and therefore fairly simple) and meant
to help the user much as an assistant would.</P>
<P>
<DL>
<P>
<A NAME="3APL"></A> </P>
<DT><B>3APL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.uu.nl/3apl/">http://www.cs.uu.nl/3apl/</A></LI>
<LI>Wikipedia entry: 
<A HREF="http://en.wikipedia.org/wiki/3APL">http://en.wikipedia.org/wiki/3APL</A></LI>
<LI>Mobile version: 
<A HREF="http://www.cs.uu.nl/3apl-m/">http://www.cs.uu.nl/3apl-m/</A></LI>
</UL>
</P>
<P>3APL is a programming language for implementing cognitive agents. It
provides programming constructs for implementing agents' beliefs,
goals, basic capabilities (such as belief updates, external actions, or
communication actions) and a set of practical reasoning rules through
which agents' goals can be updated or revised. The 3APL programs are
executed on the 3APL platform. Each 3APL program is executed by means
of an interpreter that deliberates on the cognitive attitudes of that
agent.</P>

<P>
<A NAME="Agent"></A> </P>
<DT><B>Agent</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/">http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/</A></LI>
</UL>
</P>
<P>The Agent is a prototype for an Information Agent system. It is
both platform and language independent, as it stores contained
information in simple packed strings. It can be packed and shipped
across any network with any format, as it freezes itself in its
current state.</P>

<P>
<A NAME="agentTool"></A> </P>
<DT><B>agentTool</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://agenttool.cis.ksu.edu/">http://agenttool.cis.ksu.edu/</A></LI>
</UL>
</P>
<P>agentTool is a Eclipse-based graphical development environment to help
users analyze, design, and implement multiagent systems.  It is
designed to support the highly tailorable Organization-based Multiagent
Systems Engineering (O-MaSE) methodology. agentTool currently supports
all O-MaSE models including the Goal Model, Agent Model, Role Model,
Organization Model, Protocol Model, Plan Model, Capability-Action
Model, Domain Model, and Policy Model.</P>

<P>
<A NAME="Aglets"></A> </P>
<DT><B>Aglets Workbench</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.trl.ibm.com/aglets/index_e.htm">http://www.trl.ibm.com/aglets/index_e.htm</A></LI>
</UL>
</P>
<P>An aglet is a Java object that can move from one host on the
Internet to another.  That is, an aglet that executes on one host can
suddenly halt execution, dispatch to a remote host, and resume
execution there. When the aglet moves, it takes along its program code
as well as its state (data). A built-in security mechanism makes it
safe for a computer to host untrusted aglets. The Java Aglet API
(J-AAPI) is a proposed public standard for interfacing aglets and
their environment. J-AAPI contains methods for initializing an aglet,
message handling, and dispatching, retracting,
deactivating/activating, cloning, and disposing of the aglet. J-AAPI
is simple, flexible, and stable. Application developers can write
platform-independent aglets and expect them to run on any host that
supports J-AAPI.</P>

<P>
<A NAME="AJA"></A> </P>
<DT><B>AJA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://home.arcor.de/michal.badonsky/AJA/">http://home.arcor.de/michal.badonsky/AJA/</A></LI>
</UL>
</P>
<P>AJA (Adaptable Java Agents) consists of two programming languages.
HADL (Higher Agent Definition Language) is a higher-level language used
for the description of the main agent parts. Java+ is the lower-level
language used for the programming of the agent parts defined in HADL.
It is actually Java enriched with the constructs for accessing
higher-level agent parts defined in HADL.</P>

<P>
<A NAME="A.L.I.C.E."></A> </P>
<DT><B>A.L.I.C.E.</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.alicebot.org/">http://www.alicebot.org/</A></LI>
<LI>Other AIML implementations:
<A HREF="http://pyaiml.sourceforge.net/">http://pyaiml.sourceforge.net/</A></LI>
</UL>
</P>
<P>The ALICE software implements AIML (Artificial Intelligence Markup
Language), a non-standard evolving markup language for creating chat
robots. The primary design feature of AIML is minimalism. Compared with
other chat robot languages, AIML is perhaps the simplest. The pattern
matching language is very simple, for example permitting only one
wild-card ('*') match character per pattern. AIML is an XML language,
implying that it obeys certain grammatical meta-rules. The choice of
XML syntax permits integration with other tools such as XML editors.
Another motivation for XML is its familiar look and feel, especially to
people with HTML experience.  </P>

<P>
<A NAME="Ara"></A> </P>
<DT><B>Ara</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html">http://wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html</A></LI>
</UL>
</P>
<P>Ara is a platform for the portable and secure execution of
mobile agents in heterogeneous networks. Mobile agents in this
sense are programs with the ability to change their host machine
during execution while preserving their internal state. This
enables them to handle interactions locally which otherwise had
to be performed remotely. Ara's specific aim in comparison to
similar platforms is to provide full mobile agent functionality
while retaining as much as possible of established programming
models and languages.</P>

<P>
<A NAME="Bee-gent"></A> </P>
<DT><B>Bee-gent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.toshiba.co.jp/rdc/beegent/download/download.htm">http://www.toshiba.co.jp/rdc/beegent/download/download.htm</A></LI>
<LI>FAQ: 
<A HREF="http://www.toshiba.co.jp/rdc/beegent/faq/faq.htm">http://www.toshiba.co.jp/rdc/beegent/faq/faq.htm</A></LI>
</UL>
</P>
<P>Bee-gent is a new type of development framework in that it is a 100%
pure agent system. As opposed to other systems which make only some use
of agents, Bee-gent completely "Agentifies" the communication that
takes place between software applications. The applications become
agents, and all messages are carried by agents. Thus, Bee-gent allows
developers to build flexible open distributed systems that make optimal
use of existing applications.</P>

<P>
<A NAME="Bond"></A> </P>
<DT><B>Bond</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://bond.cs.ucf.edu/">http://bond.cs.ucf.edu/</A></LI>
</UL>
</P>
<P>Bond is a Java based distributed object system and agent framework. It
implements a message based middleware and associated services like
directory, persistence, monitoring and security. Bond allows to easily
build multi agent, distributed applications. Another application of
Bond will be a Virtual Laboratory supporting data annotation and
metacomputing.</P>

<P>
<A NAME="Cougaar"></A> </P>
<DT><B>Cougaar</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cougaar.org/">http://www.cougaar.org/</A></LI>
</UL>
</P>
<P>Cougaar is java-based architecture for the construction of large-scale
distributed agent-based applications.  It is the product of a
multi-year DARPA research project into large scale agent systems and
includes not only the core architecture but also a variety of
demonstration, visualization and management components to simplify the
development of complex, distributed applications. [Yet another java
based agent system -- ed.]</P>

<P>
<A NAME="D'Agent"></A> </P>
<DT><B>D'Agent (was AGENT TCL)</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://agent.cs.dartmouth.edu/software/agent2.0/">http://agent.cs.dartmouth.edu/software/agent2.0/</A></LI>
</UL>
</P>
<P>A transportable agent is a program that can migrate from machine
to machine in a heterogeneous network.  The program chooses when and
where to migrate.  It can suspend its execution at an arbitrary point,
transport to another machine and resume execution on the new machine.
For example, an agent carrying a mail message migrates first to a
router and then to the recipient's mailbox.  The agent can perform
arbitrarily complex processing at each machine in order to ensure that
the message reaches the intended recipient.</P>

<P>
<A NAME="DIET Agents"></A> </P>
<DT><B>DIET Agents</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://diet-agents.sourceforge.net">http://diet-agents.sourceforge.net</A></LI>
</UL>
</P>
<P>DIET Agents is a lightweight, scalable and robust multi-agent platform
in Java. It is especially suitable for rapidly developing P2P prototype
applications and/or adaptive, distributed applications that use
bottom-up, nature-inspired techniques.</P>

<P>
<A NAME="FishMarket"></A> </P>
<DT><B>FishMarket</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.iiia.csic.es/Projects/fishmarket/newindex.html">http://www.iiia.csic.es/Projects/fishmarket/newindex.html</A></LI>
</UL>
</P>
<P>FM - The FishMarket project conducted at the Artificial Intelligence
Research Institute (IIIA-CSIC) attempts to contribute in that direction
by developing FM, an agent-mediated electronic auction house which has
been evolved into a test-bed for electronic auction markets. The
framework, conceived and implemented as an extension of FM96.5 (a
Java-based version of the Fishmarket auction house), allows to define
trading scenarios based on fish market auctions (Dutch auctions). FM
provides the framework wherein agent designers can perform controlled
experimentation in such a way that a multitude of experimental market
scenarios--that we regard as tournament scenarios due to the
competitive nature of the domain-- of varying degrees of realism and
complexity can be specified, activated, and recorded; and trading
(buyer and seller) heterogeneous (human and software) agents compared,
tuned and evaluated.</P>

<P>
<A NAME="Grasshopper"></A> </P>
<DT><B>Grasshopper</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.grasshopper.de/">http://www.grasshopper.de/</A></LI>
</UL>
</P>
<P>Another Java agent system. Full featured and actively developed.
Commercial, but free. Historically targeted at embedded systems.</P>

<P>
<A NAME="Hive"></A> </P>
<DT><B>Hive</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://hive.sourceforge.net/">http://hive.sourceforge.net/</A></LI>
</UL>
</P>
<P>Hive is a Java software platform for creating distributed applications.
Using Hive, programmers can easily create systems that connect and use
data from all over the Internet. At its heart, Hive is an environment
for distributed agents to live, communicating and moving to fulfill
applications. We are trying to make the Internet alive.</P>

<P>
<A NAME="ICM"></A> </P>
<DT><B>ICM</B><DD><P>
<UL>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/networkagent/">http://sourceforge.net/projects/networkagent/</A></LI>
</UL>
</P>
<P>The Inter-Agent Communication Model (ICM) is a communication mechanism
that can be used for sending messages between agents in an asynchronous
fashion. Its intended application area is as a transportation mechanism
for agent communication languages (ACLs), such as KQML and FIPA's ACL.</P>

<P>
<A NAME="Jacomma"></A> </P>
<DT><B>Jacomma</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://jacomma.sourceforge.net/">http://jacomma.sourceforge.net/</A></LI>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/jacomma/">http://sourceforge.net/projects/jacomma/</A></LI>
</UL>
</P>
<P>Jacomma is an agent development platform/framework for developing
distributed, mobile, and reactive information agents with heterogeneous
communication capabilities, in Java and JPython.</P>
<P>Jacomma provides a development framework and an execution environment,
which sits on top of the Inter-Agent Communication Model
infrastructure. The ICM defines a communication protocol, a store and
forward messaging architecture, and low level communication
infrastructure for message exchange.  Communication is truly
asynchronous, based on TCP sockets.</P>
<P>ICM has an entry in this howto, or you can find it via a link off the
site.</P>

<P>
<A NAME="Jade"></A> </P>
<DT><B>Jade</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sharon.cselt.it/projects/jade/">http://sharon.cselt.it/projects/jade/</A></LI>
</UL>
</P>
<P>JADE (Java Agent DEvelopment Framework) is a software framework fully
implemented in Java language. It simplifies the implementation of
multi-agent systems through a middle-ware that claims to comply with
the FIPA specifications and through a set of tools that supports the
debugging and deployment phase. The agent platform can be distributed
across machines (which not even need to share the same OS) and the
configuration can be controlled via a remote GUI. The configuration can
be even changed at run-time by moving agents from one machine to
another one, as and when required.</P>

<P>
<A NAME="JAM Agent"></A> </P>
<DT><B>JAM Agent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.marcush.net/IRS/irs_downloads.html">http://www.marcush.net/IRS/irs_downloads.html</A></LI>
</UL>
</P>
<P>JAM supports both top-down, goal-based reasoning and bottom-up
data-driven reasoning. JAM selects goals and plans based on maximal
priority if metalevel reasoning is not used, or user-developed
metalevel reasoning plans if they exist. JAM's conceptualization of
goals and goal achievement is more classically defined (UMPRS is more
behavioral performance-based than truly goal-based) and makes the
distinction between plans to achieve goals and plans that simply encode
behaviors. Goal-types implemented include achievement (attain a
specified world state), maintenance (re-attain a specified world
state), and performance. Execution of multiple simultaneous goals are
supported, with suspension and resumption capabilities for each goal
(i.e., intention) thread. JAM plans have explicit precondition and
runtime attributes that restrict their applicability, a postcondition
attribute, and a plan attributes section for specifying 
plan/domain-specific plan features. Available plan constructs include:
sequencing, iteration, subgoaling, atomic (i.e., non-interruptable)
plan segments, n-branch deterministic and non-deterministic conditional
execution, parallel execution of multiple plan segments, goal-based or
world state-based synchronization, an explicit failure-handling
section, and Java primitive function definition through building it
into JAM as well as the invocation of predefined (i.e., legacy) class
members via Java's reflection capabilities without having to build it
into JAM.</P>

<P>
<A NAME="JASA"></A> </P>
<DT><B>JASA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.csc.liv.ac.uk/~sphelps/jasa">http://www.csc.liv.ac.uk/~sphelps/jasa</A></LI>
<LI>Alt Web site: 
<A HREF="http://sourceforge.net/projects/jasa/">http://sourceforge.net/projects/jasa/</A></LI>
</UL>
</P>
<P>JASA is a high performance auction simulator suitable for conducting
experiments in agent-based computational economics.  It implements
various auction mechanisms, trading strategies and experiments
described in the computational economics literature, and as the
software matures we hope that it will become a repository for reference
implementations of commonly used mechanisms, strategies and learning
algorithms.</P>

<P>
<A NAME="Jason"></A> </P>
<DT><B>Jason</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://jason.sourceforge.net/">http://jason.sourceforge.net/</A></LI>
</UL>
</P>
<P>A Java-based interpreter for an extended version of AgentSpeak. Unlike
other BDI (Beliefs-Desires-Intentions) agent tools, Jason implements
the operational semantics of AgentSpeak, a BDI logic programming
language extensively discussed in the literature. It is available as
Open Source under GNU LGPL.</P>

<P>
<A NAME="JATLite"></A> </P>
<DT><B>JATLite</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://java.stanford.edu/">http://java.stanford.edu/</A></LI>
</UL>
</P>
<P>JATLite is providing a set of java packages which makes easy to
build multi-agent systems using Java. JATLite provides only
light-weight, small set of packages so that the developers can
handle all the packages with little efforts. For flexibility
JATLite provides four different layers from abstract to Router
implementation. A user can access any layer we are
providing. Each layer has a different set of assumptions. The
user can choose an appropriate layer according to the
assumptions on the layer and user's application. The
introduction page contains JATLite features and the set of
assumptions for each layer.</P>

<P>
<A NAME="JATLiteBeans"></A> </P>
<DT><B>JATLiteBeans</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://waitaki.otago.ac.nz/JATLiteBean/">http://waitaki.otago.ac.nz/JATLiteBean/</A></LI>
</UL>
</P>
<P>
<UL>
<LI>Improved, easier-to-use interface to JATLite features
including KQML message parsing, receiving, and sending.
            </LI>
<LI>Extensible architecture for message handling and agent
"thread of control" management 
            </LI>
<LI>Useful functions for parsing of simple KQML message content
            </LI>
<LI>JATLiteBean supports automatic advertising of agent
capabilities to facilitator agents 
        </LI>
<LI>Automatic, optional, handling of the "forward" performative
        </LI>
<LI>Generic configuration file parser
        </LI>
<LI>KQML syntax checker
        </LI>
</UL>
</P>

<P>
<A NAME="Java Agent Template"></A> </P>
<DT><B>Java(tm) Agent Template</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-cdr.stanford.edu/ABE/JavaAgent.html">www-cdr.stanford.edu/ABE/JavaAgent.html</A></LI>
</UL>
</P>
<P>The JAT provides a fully functional template, written entirely in
the Java language, for constructing software agents which communicate
peer-to-peer with a community of other agents distributed over the
Internet. Although portions of the code which define each agent are
portable, JAT agents are not migratory but rather have a static
existence on a single host. This behavior is in contrast to many other
"agent" technologies. (However, using the Java RMI, JAT agents could
dynamically migrate to a foreign host via an agent resident on that
host).  Currently, all agent messages use KQML as a top-level protocol
or message wrapper. The JAT includes functionality for dynamically
exchanging "Resources", which can include Java classes (e.g. new
languages and interpreters, remote services, etc.), data files and
information inlined into the KQML messages.</P>

<P>
<A NAME="lyntin"></A> </P>
<DT><B>lyntin</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lyntin.sourceforge.net/">lyntin.sourceforge.net/</A></LI>
</UL>
</P>
<P>Lyntin is an extensible Mud client and framework for the creation of
autonomous agents, or bots, as well as mudding in general. Lyntin is
centered around Python, a dynamic, object-oriented, and fun programming
language and based on TinTin++ a lovely mud client.</P>

<P>
<A NAME="Mole"></A> </P>
<DT><B>Mole</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://mole.informatik.uni-stuttgart.de/">mole.informatik.uni-stuttgart.de/</A></LI>
</UL>
</P>
<P>Mole is an agent system supporting mobile agents programmed in
Java.  Mole's agents consist of a cluster of objects, which have
no references to the outside, and as a whole work on tasks given
by the user or another agent. They have the ability to roam a
network of "locations" autonomously. These "locations" are an
abstraction of real, existing nodes in the underlying
network. They can use location-specific resources by
communicating with dedicated agents representing these
services. Agents are able to use services provided by other
agents and to provide services as well.</P>

<P>
<A NAME="Narval"></A> </P>
<DT><B>Narval</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.logilab.org/">www.logilab.org</A></LI>
</UL>
</P>
<P>Narval is the acronym of "Network Assistant Reasoning with a Validating
Agent Language". It is a personal network assistant based on artificial
intelligence and agent technologies. It executes recipes (sequences of
actions) to perform tasks. It is easy to specify a new action using XML
and to implement it using Python.  Recipes can be built and debugged
using a graphical interface.</P>

<P>
<A NAME="NeL"></A> </P>
<DT><B>NeL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nevrax.org/">www.nevrax.org</A></LI>
</UL>
</P>
<P>NeL is actually a game development library (for massive multi-player
games), but I'm including it here as it (will) include a fairly
sizable AI library. Here's a blurb from the whitepaper:</P>
<P>The purpose of the AI library is to provide a pragmatic approach to
creating a distributed agents platform. Its focus is agents; individual
entities that communicate regardless of location, using an
action-reaction model.</P>

<P>
<A NAME="OAA"></A> </P>
<DT><B>OAA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ai.sri.com/~oaa/">www.ai.sri.com/~oaa/</A></LI>
</UL>
</P>
<P>The Open Agent Architecture is a framework in which a community of
software agents running on distributed machines can work together on
tasks assigned by human or non-human participants in the community.
Distributed cooperation and high-level communication are two ideas
central to the foundation of the OAA.</P>
<P>It defines an interagent communication language and supports multiple
platforms and programming languages.</P>

<P>
<A NAME="OpenCV"></A> </P>
<DT><B>OpenCV</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://opencvlibrary.sourceforge.net/">http://opencvlibrary.sourceforge.net/</A></LI>
</UL>
</P>
<P>OpenCV (Open Source Computer Vision) is a library of programming
functions mainly aimed at real time computer vision.</P>
<P>Example applications of the OpenCV library are Human-Computer
Interaction (HCI); Object Identification, Segmentation and Recognition;
Face Recognition; Gesture Recognition; Motion Tracking, Ego Motion,
Motion Understanding; Structure From Motion (SFM); and Mobile Robotics.</P>

<P>
<A NAME="OpenCog"></A> </P>
<DT><B>OpenCog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.opencog.org/">http://www.opencog.org/</A></LI>
</UL>
</P>
<P>The Open Cognition Framework (OpenCog) is software for the
collaborative development of safe and beneficial Artificial General
Intelligence.</P>
<P>OpenCog provides research scientists and software developers with a
common platform to build and share artificial intelligence programs.
The framework includes:</P>
<P>
<UL>
<LI>a flexible and highly optimized in-memory database for
knowledge representation,</LI>
<LI>a plug-in architecture for cognitive algorithms and a cognitive
process scheduler,</LI>
<LI>a built-in LISP-like programming language, and</LI>
<LI>other components to support artificial intelligence research
and development. </LI>
</UL>
</P>

<P>
<A NAME="OpenSteer"></A> </P>
<DT><B>OpenSteer</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://opensteer.sourceforge.net/">opensteer.sourceforge.net</A></LI>
</UL>
</P>
<P>OpenSteer is a C++ library to help build steering behaviors for
autonomous characters in games and animation. OpenSteer provides an app
which displays predefined demos of steering behaviors. You can
prototype, visualize and debug your own as a plug-in.</P>

<P>
<A NAME="ORTS"></A> </P>
<DT><B>ORTS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="https://skatgame.net/mburo/orts/">https://skatgame.net/mburo/orts/</A></LI>
</UL>
</P>
<P>ORTS is a programming environment for studying real-time AI problems
such as pathfinding, dealing with imperfect information, scheduling,
and planning in the domain of RTS games. These games are fast-paced and
very popular. Furthermore, the current state of RTS game AI is bleak
which is mainly caused by the lack of planning and learning - areas in
which humans are currently much better than machines. Therefore, RTS
games make an ideal test-bed for real-time AI research. Unfortunately,
commercial RTS games are closed software which prevents researchers
from connecting remote AI modules to them. Furthermore, commercial RTS
games are based on peer-to-peer technology - which in a nutshell runs
the entire simulation on all player machines and just hides part of the
game state from the players. By tampering with the client software it
is possible to reveal the entire game state and thereby gain an unfair
advantage. We feel that this is unacceptable for playing games on the
internet. We therefore started the ORTS project to create a free
software system that lets people and machines play fair RTS games. The
communication protocol is public and all source code and artwork is
freely available. Users can connect whatever client software they like.
This is made possible by a server/client architecture in which only the
currently visible parts of the game state are sent to the players. This
openness leads to new and interesting possibilities ranging from
on-line tournaments of autonomous AI players to gauge their playing
strength to hybrid systems in which human players use sophisticated
GUIs which allow them to delegate tasks to AI helper modules of
increasing performance.</P>

<P>
<A NAME="Penguin!"></A> </P>
<DT><B>Penguin!</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/">http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/</A></LI>
</UL>
</P>
<P>Penguin is a Perl 5 module. It provides you with a set of functions which
allow you to:
<UL>
<LI>send encrypted, digitally signed Perl code to a remote machine
to be executed.</LI>
<LI>receive code and, depending on who signed it, execute it in an
arbitrarily secure, limited compartment.</LI>
</UL>

The combination of these functions enable direct Perl coding of
algorithms to handle safe internet commerce, mobile
information-gathering agents, "live content" web browser helper
apps, distributed load-balanced computation, remote software
update, distance machine administration, content-based
information propagation, Internet-wide shared-data applications,
network application builders, and so on.</P>

<P>
<A NAME="Ps-i"></A> </P>
<DT><B>Ps-i</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ps-i.sourceforge.net/">ps-i.sourceforge.net</A></LI>
</UL>
</P>
<P>Ps-i is an environment for running agent-based simulations. It is
cross-platform, with binaries available for Win32. Features include: </P>
<P>
<UL>
<LI>declarative language for model specification</LI>
<LI>industry standard Tcl/Tk scripting
with built-in routine optimization, speculative evaluation
and xf86 JIT compiler users can create complex models without
sacrificing perfomance </LI>
<LI>user friendly interface </LI>
<LI>save and restore program runs </LI>
<LI>change model parameters on the fly </LI>
<LI>data visualization: field display with multiple agent shapes and
color, statistics window, agent viewer, routine browser and
highlight agents tool </LI>
</UL>
</P>

<P>
<A NAME="Pyro"></A> </P>
<DT><B>Pyro</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pyrorobotics.org/">http://pyrorobotics.org/</A></LI>
</UL>
</P>
<P>Pyro is a library, environment, graphical user interface, and low-level
drivers to explore AI and robotics using the Python language. It works
with many real robotics platforms and simulators. Extensive algorithms
including behavior-based, vision (motion tracking, blobs, etc.),
learning (back-propagation, self-organizing maps, etc.), evolutionary,
and more.</P>

<P>
<A NAME="Quackle"></A> </P>
<DT><B>Quackle</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.quackle.org/">http://www.quackle.org/</A></LI>
<LI>Alt Web site: 
<A HREF="http://web.mit.edu/jasonkb/www/quackle/">http://web.mit.edu/jasonkb/www/quackle/</A></LI>
<LI>Alt Web site: 
<A HREF="http://sourceforge.net/projects/quackle">http://sourceforge.net/projects/quackle</A></LI>
</UL>
</P>
<P>Quackle is a world-class crossword game artificial intelligence and
analysis tool. It includes a move generator, simulator, and Qt-based
user interface and can be used with any board layout, alphabet,
lexicon, and tile distribution.</P>

<P>
<A NAME="Recast"></A> </P>
<DT><B>Recast</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://code.google.com/p/recastnavigation/">http://code.google.com/p/recastnavigation/</A></LI>
</UL>
</P>
<P>Recast is state of the art navigation mesh construction toolset for
games.</P>
<P>
<UL>
<LI>It is automatic, which means that you can throw any level
geometry at it and you will get robust mesh out</LI>
<LI>It is fast which means swift turnaround times for level
designers</LI>
<LI>It is open source so it comes with full source and you can
customize it to your hearts content.</LI>
</UL>
</P>
<P>The Library is free for commercial use and open source under the ZLib
License.</P>
<P>Recast is accompanied with Detour, path-finding and spatial reasoning
toolkit. You can use any navigation mesh with Detour, but of course the
data generated with Recast fits perfectly.</P>
<P>Detour offers simple static navigation mesh which is suitable for many
simple cases, as well as tiled navigation mesh which allows you to plug
in and out pieces of the mesh. The tiled mesh allows to create systems
where you stream new navigation data in and out as the player
progresses the level, or you may regenerate tiles as the world changes. </P>

<P>
<A NAME="Remembrance Agents"></A> </P>
<DT><B>Remembrance Agents</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.remem.org/">www.remem.org</A></LI>
</UL>
</P>
<P>Remembrance Agents are a set of applications that watch over a user's
shoulder and suggest information relevant to the current situation.
While query-based memory aids help with direct recall, remembrance
agents are an augmented associative memory.  For example, the
word-processor version of the RA continuously updates a list of
documents relevant to what's being typed or read in an emacs buffer.
These suggested documents can be any text files that might be relevant
to what you are currently writing or reading.  They might be old emails
related to the mail you are currently reading, or abstracts from papers
and newspaper articles that discuss the topic of your writing.</P>

<P>
<A NAME="SimAgent"></A> </P>
<DT><B>SimAgent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.bham.ac.uk/research/projects/poplog/packages/simagent.html">www.cs.bham.ac.uk/research/projects/poplog/packages/simagent.html</A></LI>
</UL>
</P>
<P>The SimAgent toolkit provides a range of resources for research and
teaching related to the development of interacting agents in
environments of various degrees and kinds of complexity. It can be run
as a pure simulation tool, or installed in a robot with a sufficiently
powerful on-board computer, e.g. running linux. It was originally
developed to support exploratory research on human-like intelligent
agents, but has also been used for student projects developing a
variety of interactive games and simulations.</P>

<P>
<A NAME="spyse"></A> </P>
<DT><B>spyse</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://spyse.sf.net/">spyse.sf.net</A></LI>
<LI>Alt Web site: 
<A HREF="http://zope.org/Members/drapmeyer/spyse">zope.org/Members/drapmeyer/spyse</A></LI>
</UL>
</P>
<P>spyse is a development framework and platform for building multi-agent
systems using the Python programming language. A multi-agent system
(MAS) combines concepts from distributed computing and artificial
intelligence.  Agents are autonomously reasoning software entities that
can collaborate (or compete) in order to achieve a (common) goal. By
cooperating they create emergent behaviour in the system (distributed
artificial intelligence). The architecture of a MAS is specified in the
FIPA standard.</P>
<P>Spyse provides multiple means for reasoning (BDI logics, CLIPS expert
shell, etc.) and communicating locally and remotely.</P>
<P>Each agent has its own thread of control. Agents within and among
instances of the platform communicate by exchanging messages based on
ontologies. Spyse makes use of the Web Ontology Language (OWL) defined
for the Semantic Web.</P>

<P>
<A NAME="TKQML"></A> </P>
<DT><B>TKQML</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.csee.umbc.edu/tkqml/">www.csee.umbc.edu/tkqml/</A> </LI>
</UL>
</P>
<P>TKQML is a KQML application/addition to Tcl/Tk, which allows Tcl
based systems to communicate easily with a powerful agent
communication language.</P>

<P>
<A NAME="Tocoma Project"></A> </P>
<DT><B>The Tocoma Project</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.tacoma.cs.uit.no/">www.tacoma.cs.uit.no/</A></LI>
</UL>
</P>
<P>An agent is a process that may migrate through a computer network
in order to satisfy requests made by clients. Agents are an attractive
way to describe network-wide computations.</P>
<P>The TACOMA project focuses on operating system support for agents and
how agents can be used to solve problems traditionally addressed by
operating systems. We have implemented a series of prototype systems
to support agents.</P>
<P>TACOMA Version 1.2 is based on UNIX and TCP. The system supports
agents written in C, Tcl/Tk, Perl, Python, and Scheme (Elk). It is
implemented in C. This TACOMA version has been in public domain since
April 1996.</P>
<P>We are currently focusing on heterogeneity, fault-tolerance, security
and management issues. Also, several TACOMA applications are under
construction. We implemented StormCast 4.0, a wide-area network
weather monitoring system accessible over the internet, using TACOMA
and Java. We are now in the process of evaluating this application,
and plan to build a new StormCast version to be completed by June
1997.</P>

<P>
<A NAME="UMPRS Agent"></A> </P>
<DT><B>UMPRS Agent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.marcush.net/IRS/">http://www.marcush.net/IRS/</A></LI>
</UL>
</P>
<P>UMPRS supports top-down, goal-based reasoning and selects goals and
plans based on maximal priority. Execution of multiple simultaneous
goals are supported, with suspension and resumption capabilities for
each goal (i.e., intention) thread. UMPRS plans have an integrated
precondition/runtime attribute that constrain their applicability.
Available plan constructs include: sequencing, iteration, subgoaling,
atomic (i.e., non-interruptable) blocks, n-branch deterministic
conditional execution, explicit failure-handling section, and C++
primitive function definition.</P>

<P>
<A NAME="WebMate"></A> </P>
<DT><B>WebMate</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.cmu.edu/~softagents/webmate/">http://www.cs.cmu.edu/~softagents/webmate/</A></LI>
</UL>
</P>

<P>WebMate is a personal agent for World-Wide Web browsing and
searching. It accompanies you when you travel on the internet
and provides you what you want. </P>
<P>Features include:
<UL>
<LI>Searching enhancement, including parallel search, searching
keywords refinement using our relevant keywords extraction technology,
relevant feedback, etc.
</LI>
<LI>Browsing assistant, including learning your current interesting,
recommending you new URLs according to your profile and selected
resources, monitoring bookmarks of Netscape or IE, sending the current
browsing page to your friends, etc.
</LI>
<LI>Offline browsing, including downloading the following pages from
the current page for offline browsing.
</LI>
<LI>Filtering HTTP header, including recording http header and all
the transactions between your browser and WWW servers, etc.
</LI>
<LI>Checking the HTML page to find the errors or dead links,  etc.
</LI>
<LI>Programming in Java, independent of operating system, runing in
multi-thread.
</LI>
</UL>
</P>

</DL>
</P>

<H2><A NAME="Robotics and Simulators"></A> <A NAME="ss6.2">6.2</A> <A HREF="AI-Alife-HOWTO.html#toc6.2">Robotics and Simulators</A>
        </H2>


<P>From fun battling robot games to full robot control systems. The idea is
physical agents in the real world, or at least their control programming.</P>
<P>
<DL>
<P>
<A NAME="BattleBots"></A> </P>
<DT><B>BattleBots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.bluefire.nu/battlebots/">www.bluefire.nu/battlebots/</A></LI>
</UL>
</P>
<P>AI programming game where you design the bot by selecting hardware and
programming its CPU, then competing with other bots. Competitions can
have teams and special rules for a game. </P>
<P>The hardware for use in your bot includes weapons, engine, scanners,
CPU, etc. The programming lauguage is dependent on the CPU type and is
similar to an assembly language. </P>

<P>
<A NAME="Cadaver"></A> </P>
<DT><B>Cadaver</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.erikyyy.de/cadaver/">www.erikyyy.de/cadaver/</A></LI>
</UL>
</P>
<P>Cadaver is a simulated world of cyborgs and nature in realtime.  The
battlefield consists of forests, grain, water, grass, carcass (of
course) and lots of other things. The game server manages the game and
the rules.  You start a server and connect some clients.  The clients
communicate with the server using a very primitive protocol.  They can
order cyborgs to harvest grain, attack enemies or cut forest.  The game
is not intended to be played by humans!  There is too much to control.
Only for die-hards: Just telnet to the server and you can enter
commands by hand.  Instead the idea is that you write artificial  
intelligence clients to beat the other artificial intelligences.  You
can choose a language (and operating system) of your choice to do that
task.  It is enough to write a program that communicates on standard
input and standard output channels.  Then you can use programs like
"socket" to connect your clients to the server.  It is NOT needed to
write TCP/IP code, although i did so :) The battle shall not be boring,
and so there is the so called spyboss client that displays the action
graphically on screen.</P>

<P>
<A NAME="Carmen"></A> </P>
<DT><B>Carmen</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://carmen.sourceforge.net/">http://carmen.sourceforge.net/</A></LI>
</UL>
</P>
<P>CARMEN, the Carnegie Mellon Robot Navigation Toolkit. CARMEN is an
open-source collection of software for mobile robot control. CARMEN is
modular software designed to provide basic navigation primatives
including: base and sensor control, logging, obstacle avoidance,
localization, path planning, and mapping. </P>

<P>
<A NAME="CLARAty"></A> </P>
<DT><B>CLARAty</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://claraty.jpl.nasa.gov/man/overview/">http://claraty.jpl.nasa.gov/man/overview/</A></LI>
</UL>
</P>
<P>CLARAty is an integrated framework for reusable robotic software. It
defines interfaces for common robotic functionality and integrates
multiple implementations of any given functionality. Examples of such
capabilities include pose estimation, navigation, locomotion and
planning. In addition to supporting multiple algorithms, it provides
adaptations to multiple robotic platforms.</P>
<P>This is a public release of the some of the code used in the Mars rover
projects at NASA. It is under a free for non-commercial use licence and
consists of large number of modules and algorithms along with extensive
documentation.</P>

<P>
<A NAME="GNU Robots"></A> </P>
<DT><B>GNU Robots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.gnu.org/software/robots/">http://www.gnu.org/software/robots/</A></LI>
</UL>
</P>
<P>GNU Robots is a game/diversion where you construct a program for a
little robot, then watch him explore a world. The world is
filled with baddies that can hurt you, objects that you can bump into,
and food that you can eat. The goal of the game is to collect as
many prizes as possible before are killed by a baddie or you run out of
energy. Robots can be written in Guile scheme or using a GUI.</P>

<P>
<A NAME="Infon Battle Arena"></A> </P>
<DT><B>Infon Battle Arena</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://infon.dividuum.de/">http://infon.dividuum.de/</A></LI>
<LI>Web site: 
<A HREF="https://github.com/dividuum/infon">https://github.com/dividuum/infon</A></LI>
</UL>
</P>
<P>Infon Battle Arena is a networked multiplayer real-time programming
game featuring little creatures fighting for food. You upload your
Creature Code (written in Lua) to a game server using a telnet
Interface. The game server then runs your code. The graphical client
can be used to watch running games or replay recorded games.</P>

<P>
<A NAME="Khepera Sim"></A> </P>
<DT><B>Khepera Simulator</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://diwww.epfl.ch/w3lami/team/michel/khep-sim/">http://diwww.epfl.ch/w3lami/team/michel/khep-sim/</A></LI>
</UL>
</P>
<P>Khepera Simulator is a public domain software package written by
<A HREF="http://diwww.epfl.ch/w3lami/team/michel/">Olivier         MICHEL</A> during the preparation of his Ph.D. thesis, at the Laboratoire
I3S, URA 1376 of CNRS and University of Nice-Sophia Antipolis, France.
It allows to write your own controller for the mobile robot Khepera
using C or C++ languages, to test them in a simulated environment and
features a nice colorful X11 graphical interface. Moreover, if you own
a Khepera robot, it can drive the real robot using the same control
algorithm. It is mainly oriented toward to researchers studying
autonomous agents.</P>

<P>
<A NAME="MRPT"></A> </P>
<DT><B>MRPT</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://babel.isa.uma.es/mrpt/index.php/Main_Page">http://babel.isa.uma.es/mrpt/index.php/Main_Page</A></LI>
</UL>
</P>
<P>The Mobile Robot Programming Toolkit (MRPT) is an extensive,
cross-platform, and open source C++ library aimed to help robotics
researchers to design and implement algorithms in the fields of
Simultaneous Localization and Mapping (SLAM), computer vision, and
motion planning (obstacle avoidance).</P>

<P>
<A NAME="Nero"></A> </P>
<DT><B>Nero</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nerogame.org/">http://www.nerogame.org/</A></LI>
</UL>
</P>
<P>Neuro-Evolving Robotic Operatives, or NERO for short, is a unique
computer game that lets you play with adapting intelligent agents
hands-on. Evolve your own robot army by tuning their artificial brains
for challenging tasks, then pit them against your friends' teams in
online competitions!</P>
<P>The goals of the project are (1) to demonstrate the power of
state-of-the-art machine learning technology, (2) to create an engaging
game based on it, and (3) to provide a robust and challenging
development and benchmarking domain for AI researchers.</P>
<P>Closed source but free to download. They are working on OpenNERO which
will be open source and more intended as a research platform.</P>

<P>
<A NAME="Orca"></A> </P>
<DT><B>Orca</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://orca-robotics.sourceforge.net/">http://orca-robotics.sourceforge.net/</A></LI>
<LI>Web site: 
<A HREF="https://github.com/naderman/orca-robotics">https://github.com/naderman/orca-robotics</A></LI>
</UL>
</P>
<P>Orca is an open-source framework for developing component-based robotic
systems. It provides the means for defining and developing the
building-blocks which can be pieced together to form arbitrarily
complex robotic systems, from single vehicles to distributed sensor
networks.</P>

<P>
<A NAME="Player"></A> </P>
<DT><B>Player</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://playerstage.sourceforge.net/">http://playerstage.sourceforge.net/</A></LI>
<LI>Player wiki: 
<A HREF="http://playerstage.sourceforge.net/wiki/Player">http://playerstage.sourceforge.net/wiki/Player</A></LI>
</UL>
</P>
<P>Player is a device server that provides a powerful, flexible interface
to a variety of sensors and actuators (e.g., robots). Because Player
uses a TCP socket-based client/server model, robot control programs can
be written in any programming language and can execute on any computer
with network connectivity to the robot. In addition, Player supports
multiple concurrent client connections to devices, creating new
possibilities for distributed and collaborative sensing and control.</P>

<P>
<A NAME="RealTimeBattle"></A> </P>
<DT><B>RealTimeBattle</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://realtimebattle.sourceforge.net/">http://realtimebattle.sourceforge.net/</A></LI>
</UL>
</P>
<P>RealTimeBattle is a programming game, in which robots controlled by
programs are fighting each other. The goal is to destroy the enemies,
using the radar to examine the environment and the cannon to shoot.</P>
<P>
<UL>
<LI>Game progresses in real time, with the robot programs
running as child processes to RealTimeBattle.</LI>
<LI>The robots communicate with the main program using the
standard input and output.</LI>
<LI>Robots can be constructed in almost any programming language.</LI>
<LI>Maximum number of robots can compete simultaneously.</LI>
<LI>A simple messaging language is used for communication, which
makes it easy to start constructing robots.</LI>
<LI>Robots behave like real physical object.</LI>
<LI>You can create your own arenas.</LI>
<LI>Highly configurable.</LI>
</UL>
</P>

<P>
<A NAME="Robocode"></A> </P>
<DT><B>Robocode</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://robocode.sourceforge.net/">http://robocode.sourceforge.net/</A></LI>
</UL>
</P>
<P>A java based robot combat programming game. It provides a simple API
and class framework. It is designed as a means of learning Java and is
easy to start using while not constraining the programmer from more
advanced techniques. It has a built in security manager for running
other peoples robots in a safe way.</P>

<P>
<A NAME="Robodeb"></A> </P>
<DT><B>Robodeb</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.transterpreter.org/robodeb/">http://www.transterpreter.org/robodeb/</A></LI>
</UL>
</P>
<P>Robodeb is a complete robotics simulation environment for teaching
concurrency and parallelism. It provides a unique environment for
exploring concurrency and robotics. It provides a complete IDE for the
occam-pi programming language, and leverages the Transterpreter, our
portable and flexible runtime for the language. This combination is
critical, as it provides a principled interface to the Player/Stage
API, a set of widely used libraries for controlling the Pioneer3
robotics platform.</P>

<P>
<A NAME="RobotFlow"></A> </P>
<DT><B>RobotFlow</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://robotflow.sourceforge.net/">http://robotflow.sourceforge.net/</A></LI>
</UL>
</P>
<P>RobotFlow is a mobile robotics tookit based on the
<A HREF="http://flowdesigner.sourceforge.net">FlowDesigner</A>
project. FlowDesigner is a data-flow oriented architecture, similar to
Simulink (Matlab) or Labview that is free (LGPL) and versatile. The
visual programming interface provided in the FlowDesigner project will
help people to better visualize &amp; understand what is really happening
in the robot's control loops, sensors, actuators, by using graphical
probes and debugging in real-time.</P>

<P>
<A NAME="RoboTournament"></A> </P>
<DT><B>RoboTournament</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://robotournament.sourceforge.net/">http://robotournament.sourceforge.net/</A></LI>
</UL>
</P>
<P>RoboTournament is a RoboRally inspired game where players program their
robots to vanquish their opponents. RoboTournament features: Multiple
Game Types: Death Match, Rally, and Capture The Flag. Multi-Player
through TCP/IP, Six weapons including BFG, Map Editor, and a wide
variety of board elements.</P>

<P>
<A NAME="ROS"></A> </P>
<DT><B>ROS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ros.org/wiki/">http://www.ros.org/wiki/</A></LI>
</UL>
</P>
<P>ROS is an operating system for your robot. It provides the services you
would expect from an operating system, including hardware abstraction,
low-level device control, implementation of commonly-used
functionality, message-passing between processes, and package
management. It also provides tools and libraries for obtaining,
building, writing, and running code across multiple computers.</P>

<P>
<A NAME="Simbad"></A> </P>
<DT><B>Simbad</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://simbad.sourceforge.net/">http://simbad.sourceforge.net/</A></LI>
</UL>
</P>
<P>Simbad is a Java 3d robot simulator for scientific and educationnal
purposes.  It is mainly dedicated to researchers/programmers who want
a simple basis for studying Situated Artificial Intelligence, Machine
Learning, and more generally AI algorithms, in the context of
Autonomous Robotics  and  Autonomous Agents. It is not intented to
provide a real world simulation and is kept voluntarily readable and
simple.</P>
<P>Simbad enables programmers to write their own robot controller, modify
the environment and use the available sensors. Don't think of it as a
finite product but merely as an opened framework to test your own
ideas.</P>

<P>
<A NAME="SimRobot"></A> </P>
<DT><B>SimRobot</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.informatik.uni-bremen.de/simrobot/">http://www.informatik.uni-bremen.de/simrobot/</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/">ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/</A></LI>
</UL>
</P>
<P>SimRobot is a program for simulation of sensor based robots in a
3D environment. It is written in C++, runs under UNIX and X11 and
needs the graphics toolkit XView.
<UL>
<LI>Simulation of robot kinematics</LI>
<LI>Hierarchically built scene definition via a simple definition
language</LI>
<LI>Various sensors built in: camera, facette eye, distance
measurement, light sensor, etc.</LI>
<LI>Objects defined as polyeders</LI>
<LI>Emitter abstractly defined; can be interpreted e.g. as
light or sound</LI>
<LI>Camera images computed according to the raytracing or
Z-buffer algorithms known from computer graphics</LI>
<LI>Specific sensor/motor software interface for communicating
with the simulation</LI>
<LI>Texture mapping onto the object surfaces: bitmaps in various
formats</LI>
<LI>Comprehensive visualization of the scene: wire frame w/o
hidden lines, sensor and actor values</LI>
<LI>Interactive as well as batch driven control of the agents
and operation in the environment</LI>
<LI>Collision detection</LI>
<LI>Extendability with user defined object types</LI>
<LI>Possible socket communication to e.g. the Khoros image
processing software</LI>
</UL>
</P>

<P>
<A NAME="TclRobots"></A> </P>
<DT><B>TclRobots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nyx.net/~tpoindex/">http://www.nyx.net/~tpoindex/</A></LI>
</UL>
</P>
<P>TclRobots is a programming game, similar to 'Core War'.  To play
TclRobots, you must write a Tcl program that controls a robot.  The
robot's mission is to survive a battle with other robots.  Two, three,
or four robots compete during a battle, each running different
programs (or possibly the same program in different robots.)  Each
robot is equipped with a scanner, cannon, drive mechanism.  A single
match continues until one robot is left running.  Robots may compete
individually, or combine in a team oriented battle.  A tournament
can be run with any number of robot programs, each robot playing every
other in a round-robin fashion, one-on-one.  A battle simulator is
available to help debug robot programs.</P>
<P>The TclRobots program provides a physical environment, imposing
certain game parameters to which all robots must adhere.  TclRobots
also provides a view on a battle, and a controlling user interface.
TclRobots requirements: a wish interpreter built from Tcl 7.4 and Tk
4.0.</P>

<P>
<A NAME="URBI"></A> </P>
<DT><B>URBI</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.urbiforge.org/">http://www.urbiforge.org/</A></LI>
</UL>
</P>
<P>URBI is a Universal Real-time Behavior Interface and gives you a simple
but powerful way to control any robot or complex system like a video
game, using a convenient and easy to use scripting language that can be
interfaced with several popular programming languages (C++, Java,
Matlab,...) and OS (Windows, Mac OSX, Linux). URBI is based on a
client/server architecture, which give a great deal of flexibility.
URBI includes powerful features compared to existing scripting
solutions: parallel execution of commands, event programming, command
tagging, dynamic variables,... Currently, URBI is used as well by
academic research labs, the industry and by hobbyists.</P>

<P>
<A NAME="VWORLD"></A> </P>
<DT><B>VWORLD</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://zhar.net/projects/vworld/">http://zhar.net/projects/vworld/</A></LI>
</UL>
</P>
<P>Vworld is a simulated environment for research with autonomous
agents written in prolog. It is currently in something of an
beta stage. It works well with SWI-prolog, but should work with
Quitnus-prolog with only a few changes.  It is being designed to
serve as an educational tool for class projects dealing with
prolog and autonomous agents. It comes with three demo worlds or
environments, along with sample agents for them. There are
two versions now. One written for SWI-prolog and one written for
LPA-prolog. Documentation is roughly done (with a
student/professor framework in mind).</P>


<P>
<A NAME="Yampa"></A> </P>
<DT><B>Yampa</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.haskell.org/yampa/">http://www.haskell.org/yampa/</A></LI>
</UL>
</P>
<P>FRP system with robotics library and graphical interactive robotics
simulator.</P>
<P>Functional reactive programming, or FRP, is a paradigm for programming
hybrid systems  i.e., systems containing a combination of both
continuous and discrete components  in a high-level, declarative way.
The key ideas in FRP are its notions of continuous, time-varying
values, and time-ordered sequences of discrete events. Yampa is an
instantiation of FRP as a domain-specific language embedded in Haskell.</P>

<P>
<A NAME="YARP"></A> </P>
<DT><B>YARP</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://eris.liralab.it/yarp/">http://eris.liralab.it/yarp/</A></LI>
</UL>
</P>
<P>YARP is plumbing for robot software.  It is a set of libraries,
protocols, and tools to keep modules and devices cleanly decoupled. It
is reluctant middleware, with no desire or expectation to be in control
of your system.</P>
<P>More specifically, YARP supports building a robot control system as a
collection of programs communicating in a peer-to-peer way, with a
family of connection types that meet the diverse, sometimes
contradictory, and always changing needs of advanced robotics. We also
encourage compilation and use of hardware devices in a future-proof
way. Our strategic goal is to increase the longevity of robot software
projects.</P>



</DL>
</P>

<HR>
<H2><A NAME="Statistical &amp; Machine Learning"></A> <A NAME="s7">7.</A> <A HREF="AI-Alife-HOWTO.html#toc7">Statistical &amp; Machine Learning</A>  </H2>


<P>All about getting machines to learn to do something rather than
explicitly programming to do it. Tends to deal with pattern matching
a lot and are heavily math and statistically based. Technically
<A HREF="#Connectionism">Connectionism</A>
 falls under this category, but it is such a
large sub-field I'm keeping it in a separate section.</P>


<H2><A NAME="ss7.1">7.1</A> <A HREF="AI-Alife-HOWTO.html#toc7.1">Libraries</A>
  </H2>


<P>Libraries or frameworks used for writing machine learning systems.</P>
<P>
<DL>
<P>
<A NAME="CognitiveFoundry"></A> </P>
<DT><B>CognitiveFoundry</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://foundry.sandia.gov/">http://foundry.sandia.gov/</A></LI>
</UL>
</P>
<P>The Cognitive Foundry is a modular Java software library for the
research and development of cognitive systems. It contains many
reusable components for machine learning, statistics, and cognitive
modeling. It is primarily designed to be easy to plug into applications
to provide adaptive behaviors.</P>

<P>
<A NAME="CompLearn"></A> </P>
<DT><B>CompLearn</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://complearn.org/">http://complearn.org/</A></LI>
</UL>
</P>
<P>CompLearn is a software system built to support compression-based
learning in a wide variety of applications. It provides this support in
the form of a library written in highly portable ANSI C that runs in
most modern computer environments with minimal confusion. It also
supplies a small suite of simple, composable command-line utilities as
simple applications that use this library. Together with other commonly
used machine-learning tools such as LibSVM and GraphViz, CompLearn
forms an attractive offering in machine-learning frameworks and
toolkits.</P>

<P>
<A NAME="Elefant"></A> </P>
<DT><B>Elefant</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://elefant.developer.nicta.com.au/">http://elefant.developer.nicta.com.au/</A></LI>
</UL>
</P>
<P>Elefant (Efficient Learning, Large-scale Inference, and Optimisation
Toolkit) is an open source library for machine learning licensed under
the Mozilla Public License (MPL). We develop an open source machine
learning toolkit which provides</P>
<P>
<UL>
<LI>algorithms for machine learning utilising the power of
multi-core/multi-threaded processors/operating systems (Linux,
WIndows, Mac OS X),</LI>
<LI>a graphical user interface for users who want to quickly
prototype machine learning experiments,</LI>
<LI>tutorials to support learning about Statistical Machine
Learning (Statistical Machine Learning at The Australian National
University), and</LI>
<LI>detailed and precise documentation for each of the above.</LI>
</UL>
</P>

<P>
<A NAME="Maximum Entropy Toolkit"></A> </P>
<DT><B>Maximum Entropy Toolkit</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://homepages.inf.ed.ac.uk/lzhang10/maxent_toolkit.html">http://homepages.inf.ed.ac.uk/lzhang10/maxent_toolkit.html</A></LI>
</UL>
</P>
<P>The Maximum Entropy Toolkit provides a set of tools and library for
constructing maximum entropy (maxent) model in either Python or C++.</P>
<P>Maxent Entropy Model is a general purpose machine learning framework
that has proved to be highly expressive and powerful in statistical
natural language processing, statistical physics, computer vision and
many other fields.</P>

<P>
<A NAME="Milk"></A> </P>
<DT><B>Milk</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://packages.python.org/milk/">http://packages.python.org/milk/</A></LI>
<LI>Web site: 
<A HREF="https://github.com/luispedro/milk">https://github.com/luispedro/milk</A></LI>
</UL>
</P>
<P>Milk is a machine learning toolkit in Python. It's focus is on
supervised classification with several classifiers available: SVMs
(based on libsvm), k-NN, random forests, decision trees. It also
performs feature selection. These classifiers can be combined in many
ways to form different classification systems. For unsupervised
learning, milk supports k-means clustering and affinity propagation.</P>

<P>
<A NAME="NLTK"></A> </P>
<DT><B>NLTK</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://nltk.org/">http://nltk.org/</A></LI>
</UL>
</P>
<P>NLTK, the Natural Language Toolkit, is a suite of Python libraries and
programs for symbolic and statistical natural language processing.
NLTK includes graphical demonstrations and sample data. It is
accompanied by extensive documentation, including tutorials that
explain the underlying concepts behind the language processing tasks
supported by the toolkit.</P>
<P>NLTK is ideally suited to students who are learning NLP (natural
language processing) or conducting research in NLP or closely related
areas, including empirical linguistics, cognitive science, artificial
intelligence, information retrieval, and machine learning. NLTK has
been used successfully as a teaching tool, as an individual study tool,
and as a platform for prototyping and building research systems.</P>

<P>
<A NAME="peach"></A> </P>
<DT><B>peach</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://code.google.com/p/peach/">http://code.google.com/p/peach/</A></LI>
</UL>
</P>
<P>Peach is a pure-python module, based on SciPy and NumPy to implement
algorithms for computational intelligence and machine learning. Methods
implemented include, but are not limited to, artificial neural
networks, fuzzy logic, genetic algorithms, swarm intelligence and much
more.</P>
<P>The aim of this library is primarily educational. Nonetheless, care was
taken to make the methods implemented also very efficient.</P>

<P>
<A NAME="pebl"></A> </P>
<DT><B>pebl</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://code.google.com/p/pebl-project/">http://code.google.com/p/pebl-project/</A></LI>
</UL>
</P>
<P>Pebl is a python library and command line application for learning the
structure of a Bayesian network given prior knowledge and observations.
Pebl includes the following features:</P>
<P>
<UL>
<LI>Can learn with observational and interventional data</LI>
<LI>Handles missing values and hidden variables using exact and
heuristic methods</LI>
<LI>Provides several learning algorithms; makes creating new ones
simple</LI>
<LI>Has facilities for transparent parallel execution using several
cluster/grid resources</LI>
<LI>Calculates edge marginals and consensus networks</LI>
<LI>Presents results in a variety of formats </LI>
</UL>
</P>

<P>
<A NAME="PyBrain"></A> </P>
<DT><B>PyBrain</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pybrain.org/">http://pybrain.org/</A></LI>
</UL>
</P>
<P>PyBrain is a modular Machine Learning Library for Python. It's goal is
to offer flexible, easy-to-use yet still powerful algorithms for
Machine Learning Tasks and a variety of predefined environments to test
and compare your algorithms.</P>
<P>PyBrain contains algorithms for neural networks, for reinforcement
learning (and the combination of the two), for unsupervised learning,
and evolution. Since most of the current problems deal with continuous
state and action spaces, function approximators (like neural networks)
must be used to cope with the large dimensionality. Our library is
built around neural networks in the kernel and all of the training
methods accept a neural network as the to-be-trained instance. This
makes PyBrain a powerful tool for real-life tasks.</P>

<P>
<A NAME="MBT"></A> </P>
<DT><B>MBT</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ilk.uvt.nl/mbt/">http://ilk.uvt.nl/mbt/</A></LI>
</UL>
</P>
<P>MBT is a memory-based tagger-generator and tagger in one. The
tagger-generator part can generate a sequence tagger on the basis of a
training set of tagged sequences; the tagger part can tag new
sequences. MBT can, for instance, be used to generate part-of-speech
taggers or chunkers for natural language processing. It has also been
used for named-entity recognition, information extraction in
domain-specific texts, and disfluency chunking in transcribed speech.</P>

<P>
<A NAME="MLAP book samples"></A> </P>
<DT><B>MLAP book samples</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://seat.massey.ac.nz/personal/s.r.marsland/MLBook.html">http://seat.massey.ac.nz/personal/s.r.marsland/MLBook.html</A></LI>
</UL>
</P>
<P>Not a library per-say, but a whole slew of example machine learning
algorithms from the book "Machine Learning: An Algorithmic Perspective"
by Stephen Marsland.  All code is written in python.</P>

<P>
<A NAME="scikits.learn"></A> </P>
<DT><B>scikits.learn</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://scikit-learn.org/stable/">http://scikit-learn.org/stable/</A></LI>
</UL>
</P>
<P>scikits-learn is a Python module integrating classic machine learning
algorithms in the tightly-knit world of scientific Python packages
(numpy, scipy, matplotlib). It aims to provide simple and efficient
solutions to learning problems that are accessible to everybody and
reusable in various contexts: machine-learning as a versatile tool for
science and engineering.</P>

<P>
<A NAME="Shogun"></A> </P>
<DT><B>Shogun</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.shogun-toolbox.org/">http://www.shogun-toolbox.org/</A></LI>
</UL>
</P>
<P>The machine learning toolbox's focus is on large scale kernel methods
and especially on Support Vector Machines (SVM). It provides a generic
SVM object interfacing to several different SVM implementations, among
them the state of the art LibSVM and SVMLight. Each of the SVMs can be
combined with a variety of kernels. The toolbox not only provides
efficient implementations of the most common kernels, like the Linear,
Polynomial, Gaussian and Sigmoid Kernel but also comes with a number of
recent string kernels as e.g.  the Locality Improved, Fischer, TOP,
Spectrum, Weighted Degree Kernel (with shifts). For the latter the
efficient LINADD optimizations are implemented. Also SHOGUN offers the
freedom of working with custom pre-computed kernels. One of its key
features is the combined kernel which can be constructed by a weighted
linear combination of a number of sub-kernels, each of which not
necessarily working on the same domain. An optimal sub-kernel weighting
can be learned using Multiple Kernel Learning. Currently SVM 2-class
classification and regression problems can be dealt with.  However
SHOGUN also implements a number of linear methods like Linear
Discriminant Analysis (LDA), Linear Programming Machine (LPM), (Kernel)
Perceptrons and features algorithms to train hidden markov models. The
input feature-objects can be dense, sparse or strings and of type
int/short/double/char and can be converted into different feature
types. Chains of preprocessors (e.g. substracting the mean) can be
attached to each feature object allowing for on-the-fly pre-processing.</P>
<P>SHOGUN is implemented in C++ and interfaces to Matlab(tm), R, Octave
and Python.</P>

<P>
<A NAME="timbl"></A> </P>
<DT><B>timbl</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ilk.uvt.nl/timbl/">http://ilk.uvt.nl/timbl/</A></LI>
</UL>
</P>
<P>The Tilburg Memory Based Learner, TiMBL, is a tool for NLP research,
and for many other domains where classification tasks are learned from
examples.  It is an efficient implementation of k-nearest neighbor
classifier.</P>
<P>TiMBL's features are:
<UL>
<LI>Fast, decision-tree-based implementation of k-nearest neighbor
lassification;</LI>
<LI>Implementations of IB1 and IB2, IGTree, TRIBL, and TRIBL2
algorithms;</LI>
<LI>Similarity metrics: Overlap, MVDM, Jeffrey Divergence, Dot
product, Cosine;</LI>
<LI>Feature weighting metrics: information gain, gain ratio,
chi squared, shared variance;</LI>
<LI>Distance weighting metrics: inverse, inverse linear,
exponential decay;</LI>
<LI>Extensive verbosity options to inspect nearest neighbor sets;</LI>
<LI>Server functionality and extensive API;</LI>
<LI>Fast leave-one-out testing and internal cross-validation;</LI>
<LI>and Handles user-defined example weighting.</LI>
</UL>
</P>


</DL>
</P>

<H2><A NAME="ss7.2">7.2</A> <A HREF="AI-Alife-HOWTO.html#toc7.2">Applications</A>
  </H2>


<P>Full applications that implement various machine learning or statistical
systems oriented toward general learning (i.e., no spam filters and the
like).</P>
<P>
<DL>
<P>
<A NAME="dbacl"></A> </P>
<DT><B>dbacl</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://dbacl.sourceforge.net/">http://dbacl.sourceforge.net/</A></LI>
</UL>
</P>
<P>The dbacl project consist of a set of lightweight UNIX/POSIX utilities
which can be used, either directly or in shell scripts, to classify
text documents automatically, according to Bayesian statistical
principles.</P>

<P>
<A NAME="Torch5"></A> </P>
<DT><B>Torch5</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://torch5.sourceforge.net/">http://torch5.sourceforge.net/</A></LI>
</UL>
</P>
<P>Torch5 provides a matlab-like environment for state-of-the-art machine
learning algorithms. It is easy to use and provides a very efficient
implementation, thanks to a easy and fast scripting language (Lua) and
a underlying C++ implementation. It is distributed under a BSD license.</P>
<P>This is the successor to the 
<A HREF="#Torch">Torch3</A> project.</P>

<P>
<A NAME="Vowpal Wabbit"></A> </P>
<DT><B>Vowpal Wabbit</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://hunch.net/~vw/">http://hunch.net/~vw/</A></LI>
</UL>
</P>
<P>Vowpal Wabbit is a fast online learning algorithm.  It features:</P>
<P>
<UL>
<LI>flexible input data specification</LI>
<LI>speedy learning</LI>
<LI>scalability (bounded memory footprint, suitable for 
distributed computation)</LI>
<LI>feature pairing</LI>
</UL>
</P>
<P>The core algorithm is specialist gradient descent (GD) on a loss
function (several are available), The code should be easily usable.</P>


</DL>
</P>

<HR>
<H2><A NAME="Programming languages"></A> <A NAME="s8">8.</A> <A HREF="AI-Alife-HOWTO.html#toc8">Programming languages</A>    </H2>


<P>While any programming language can be used for artificial
intelligence/life research, these are programming languages which
are used extensively for, if not specifically made for, artificial
intelligence programming.</P>

<P>
<DL>
<P>
<A NAME="2APL"></A> </P>
<DT><B>2APL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://apapl.sourceforge.net/">http://apapl.sourceforge.net/</A></LI>
</UL>
</P>
<P>2APL (pronounced as double-a-p-l) is an agent-oriented programming
language that facilitates the implementation of multi-agent systems. At
the multi-agent level, it provides programming constructs to specify a
multi-agent system in terms of a set of individual agents, a set of
environments in which they can perform actions, and the access relation
between the individual agents and the environments. At the individual
agent level, it provides programming constructs to implement cognitive
agents based on the BDI architecture.</P>

<P>
<A NAME="Alloy"></A> </P>
<DT><B>Alloy</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://alloy.mit.edu/">http://alloy.mit.edu/</A></LI>
</UL>
</P>
<P>The Alloy Analyzer is a tool for analyzing models written in Alloy, a
simple structural modeling language based on first-order logic. The
tool can generate instances of invariants, simulate the execution of
operations (even those defined implicitly), and check user-specified
properties of a model. Alloy and its analyzer have been used primarily
to explore abstract software designs. Its use in analyzing code for
conformance to a specification and as an automatic test case generator
are being investigated in ongoing research projects.</P>

<P>
<A NAME="APRIL"></A> </P>
<DT><B>APRIL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/networkagent/">sourceforge.net/projects/networkagent/</A></LI>
</UL>
</P>
<P>APRIL is a symbolic programming language that is designed for writing
mobile, distributed and agent-based systems especially in an Internet
environment. It has advanced features such as a macro sub-language,
asynchronous message sending and receiving, code mobility, pattern
matching, higher-order functions and strong typing. The language is
compiled to byte-code which is then interpreted by the APRIL
runtime-engine.  APRIL now requires the InterAgent Communications Model
(ICM) to be installed before it can be installed. [Ed. ICM can be found
at the same web site]</P>

<P>
<A NAME="Ciao Prolog"></A> </P>
<DT><B>Ciao Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ciaohome.org/">http://www.ciaohome.org/</A></LI>
</UL>
</P>
<P>Ciao is a complete Prolog system subsuming ISO-Prolog with a novel
modular design which allows both restricting and extending the
language. Ciao extensions currently include feature terms (records),
higher-order, functions, constraints, objects, persistent predicates, a
good base for distributed execution (agents), and concurrency.
Libraries also support WWW programming, sockets, and external
interfaces (C, Java, TCL/Tk, relational databases, etc.). An
Emacs-based environment, a stand-alone compiler, and a toplevel shell
are also provided.</P>

<P>
<A NAME="Curry"></A> </P>
<DT><B>Curry</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.informatik.uni-kiel.de/~mh/curry/">http://www.informatik.uni-kiel.de/~mh/curry/</A></LI>
</UL>
</P>
<P>Curry is a universal programming language aiming to amalgamate the most
important declarative programming paradigms, namely functional
programming and logic programming. Moreover, it also covers the most
important operational principles developed in the area of integrated
functional logic languages: "residuation" and "narrowing" (there is an
older survey and a newer survey on functional logic programming).</P>
<P>Curry combines in a seamless way features from functional programming
(nested expressions, higher-order functions, lazy evaluation), logic
programming (logical variables, partial data structures, built-in
search), and concurrent programming (concurrent evaluation of
expressions with synchronization on logical variables). Moreover, Curry
provides additional features in comparison to the pure languages
(compared to functional programming: search, computing with partial
information; compared to logic programming: more efficient evaluation
due to the deterministic and demand-driven evaluation of functions).</P>

<P>
<A NAME="ECLiPSe"></A> </P>
<DT><B>ECLiPSe</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://eclipseclp.org/">http://eclipseclp.org/</A></LI>
</UL>
</P>
<P>ECLiPSe is a software system for the cost-effective development and
deployment of constraint programming applications, e.g. in the areas of
planning, scheduling, resource allocation, timetabling, transport etc.
It is also ideal for teaching most aspects of combinatorial problem
solving, e.g.  problem modelling, constraint programming, mathematical
programming, and search techniques. It contains several constraint
solver libraries, a high-level modelling and control language,
interfaces to third-party solvers, an integrated development
environment and interfaces for embedding into host environments.</P>

<P>
<A NAME="ECoLisp"></A> </P>
<DT><B>ECoLisp</B><DD><P>
<UL>
<LI>Web site (???): 
<A HREF="http://www.di.unipi.it/~attardi/software.html">http://www.di.unipi.it/~attardi/software.html</A></LI>
</UL>
</P>
<P>ECoLisp (Embeddable Common Lisp) is an implementation of
Common Lisp designed for being embeddable into C based
applications. ECL uses standard C calling conventions for Lisp
compiled functions, which allows C programs to easily call
Lisp functions and viceversa. No foreign function interface is
required: data can be exchanged between C and Lisp with no
need for conversion. ECL is based on a Common Runtime Support
(CRS) which provides basic facilities for memory managment,
dynamic loading and dumping of binary images, support for
multiple threads of execution. The CRS is built into a library
that can be linked with the code of the application. ECL is
modular: main modules are the program development tools (top
level, debugger, trace, stepper), the compiler, and CLOS. A
native implementation of CLOS is available in ECL: one can
configure ECL with or without CLOS. A runtime version of ECL
can be built with just the modules which are required by the
application. The ECL compiler compiles from Lisp to C, and
then invokes the GCC compiler to produce binaries.</P>

<P>
<A NAME="ESTEREL"></A> </P>
<DT><B>ESTEREL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-sop.inria.fr/meije/esterel/">http://www-sop.inria.fr/meije/esterel/</A></LI>
</UL>
</P>
<P>Esterel is both a programming language, dedicated to programming
reactive systems, and a compiler which translates Esterel programs into
finite-state machines. It is particularly well-suited to programming
reactive systems, including real-time systems and control automata.</P>
<P>Only the binary is available for the language compiler. :P</P>

<P>
<A NAME="Godel"></A> </P>
<DT><B>G&ouml;del</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cs.bris.ac.uk/~bowers/goedel.html">http://www.cs.bris.ac.uk/~bowers/goedel.html</A></LI>
</UL>
</P>
<P>G&ouml;del is a declarative, general-purpose programming language in the
family of logic programming languages.  It is a strongly typed language,
the type system being based on many-sorted logic with parametric
polymorphism.  It has a module system.  G&ouml;del supports infinite
precision integers, infinite precision rationals, and also
floating-point numbers.  It can solve constraints over finite domains of
integers and also linear rational constraints. It supports processing of
finite sets.  It also has a flexible computation rule and a pruning
operator which generalizes the commit of the concurrent logic
programming languages.  Considerable emphasis is placed on G&ouml;del's
meta- logical facilities which provide significant support for
meta-programs that do analysis, transformation, compilation,
verification, debugging, and so on.</P>

<P>
<A NAME="CLisp"></A> </P>
<DT><B>CLisp (Lisp)</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://clisp.sourceforge.net/">http://clisp.sourceforge.net/</A></LI>
<LI>Alt Web site: 
<A HREF="http://clisp.org/">http://clisp.org/</A></LI>
</UL>
</P>
<P>CLISP is a Common Lisp implementation by Bruno Haible and Michael
Stoll.  It mostly supports the Lisp described by
<A HREF="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html">Common LISP: The Language (2nd edition)</A>
and the ANSI Common Lisp
standard.  CLISP includes an interpreter, a byte-compiler, a large
subset of CLOS (Object-Oriented Lisp) , a foreign language interface
and, for some machines, a screen editor.</P>
<P>The user interface language (English, German, French) is chosen at
run time.  Major packages that run in CLISP include CLX &amp; Garnet.
CLISP needs only 2 MB of memory.</P>

<P>
<A NAME="CMU CL"></A> </P>
<DT><B>CMU Common Lisp</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.cons.org/cmucl/">http://www.cons.org/cmucl/</A></LI>
<LI>Linux Installation: 
<A HREF="http://www.telent.net/lisp/howto.html">http://www.telent.net/lisp/howto.html</A></LI>
</UL>
</P>
<P>CMU Common Lisp is a public domain "industrial strength" Common
Lisp programming environment. Many of the X3j13 changes have been
incorporated into CMU CL. Wherever possible, this has been done so as
to transparently allow the use of either CLtL1 or proposed ANSI
CL. Probably the new features most interesting to users are SETF
functions, LOOP and the WITH-COMPILATION-UNIT macro.</P>

<P>
<A NAME="Gnu-CL"></A> </P>
<DT><B>GCL (Lisp)</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="ftp://ftp.ma.utexas.edu/pub/gcl/">ftp://ftp.ma.utexas.edu/pub/gcl/</A></LI>
</UL>
</P>
<P>GNU Common Lisp (GCL) has a compiler and interpreter for Common
Lisp.  It used to be known as Kyoto Common Lisp.  It is very portable
and extremely efficient on a wide class of applications.  It compares
favorably in performance with commercial Lisps on several large
theorem-prover and symbolic algebra systems. It supports the CLtL1
specification but is moving towards the proposed ANSI definition.  GCL
compiles to C and then uses the native optimizing C compilers (e.g.,
GCC).  A function with a fixed number of args and one value turns into
a C function of the same number of args, returning one value, so GCL
is maximally efficient on such calls.  It has a conservative garbage
collector which allows great freedom for the C compiler to put Lisp
values in arbitrary registers.</P>
<P>It has a source level Lisp debugger for interpreted code, with display
of source code in an Emacs window.  Its profiling tools (based on the
C profiling tools) count function calls and the time spent in each
function.</P>

<P>
<A NAME="GNU Prolog"></A> </P>
<DT><B>GNU Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.gprolog.org/">http://www.gprolog.org/</A></LI>
</UL>
</P>
<P>GNU Prolog is a free Prolog compiler with constraint solving over
finite domains developed by Daniel Diaz.</P>
<P>GNU Prolog accepts Prolog+constraint programs and produces native
binaries (like gcc does from a C source). The obtained executable is
then stand-alone. The size of this executable can be quite small since
GNU Prolog can avoid to link the code of most unused built-in
predicates. The performances of GNU Prolog are very encouraging
(comparable to commercial systems).</P>
<P>Beside the native-code compilation, GNU Prolog offers a classical
interactive interpreter (top-level) with a debugger.</P>
<P>The Prolog part conforms to the ISO standard for Prolog with many
extensions very useful in practice (global variables, OS interface,
sockets,...).</P>
<P>GNU Prolog also includes an efficient constraint solver over Finite
Domains (FD). This opens contraint logic pogramming to the user
combining the power of constraint programming to the declarativity of
logic programming.</P>

<P>
<A NAME="lush"></A> </P>
<DT><B>lush</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lush.sourceforge.net/">http://lush.sourceforge.net/</A></LI>
</UL>
</P>
<P>Lush is an object-oriented programming language designed for
researchers, experimenters, and engineers interested in large-scale
numerical and graphic applications. Lush is designed to be used in
situations where one would want to combine the flexibility of a
high-level, weakly-typed interpreted language, with the efficiency of a
strongly-typed, natively-compiled language, and with the easy
integration of code written in C, C++, or other languages.</P>

<P>
<A NAME="Maude"></A> </P>
<DT><B>Maude</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://maude.cs.uiuc.edu/">http://maude.cs.uiuc.edu/</A></LI>
</UL>
</P>
<P>Maude is a high-performance reflective language and system supporting
both equational and rewriting logic specification and programming for a
wide range of applications. Maude has been influenced in important ways
by the OBJ3 language, which can be regarded as an equational logic
sublanguage. Besides supporting equational specification and
programming, Maude also supports rewriting logic computation.</P>

<P>
<A NAME="Mercury"></A> </P>
<DT><B>Mercury</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://mercurylang.org/">http://mercurylang.org/</A></LI>
</UL>
</P>
<P>Mercury is a new, purely declarative logic programming language.  Like
Prolog and other existing logic programming languages, it is a very
high-level language that allows programmers to concentrate on the
problem rather than the low-level details such as memory management.
Unlike Prolog, which is oriented towards exploratory programming,
Mercury is designed for the construction of large, reliable, efficient
software systems by teams of programmers. As a consequence, programming
in Mercury has a different flavor than programming in Prolog.</P>

<P>
<A NAME="Mozart"></A> </P>
<DT><B>Mozart</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.mozart-oz.org/">http://www.mozart-oz.org/</A></LI>
</UL>
</P>
<P>The Mozart system provides state-of-the-art support in two areas:
open distributed computing and constraint-based inference. Mozart
implements Oz, a concurrent object-oriented language with dataflow
synchronization.  Oz combines concurrent and distributed programming
with logical constraint-based inference, making it a unique choice
for developing multi-agent systems. Mozart is an ideal platform for
both general-purpose distributed applications as well as for hard
problems requiring sophisticated optimization and inferencing
abilities. We have developed applications in scheduling and
time-tabling, in placement and configuration, in natural language and
knowledge representation, multi-agent systems and sophisticated
collaborative tools.</P>

<P>
<A NAME="SWI Prolog"></A> </P>
<DT><B>SWI Prolog</B><DD><P>
<UL>
<LI>Web page: 
<A HREF="http://www.swi-prolog.org/">http://www.swi-prolog.org/</A></LI>
</UL>
</P>
<P>SWI is a free version of prolog in the Edinburgh Prolog family. It is
licensed under the LGPL with many nice features for an AI researcher,
such as; a large library of built-in predicates, a module system,
garbage collection, a two-way interface with the C/C++ language,
coroutines, multi-threading, multiple constraint library, the XPCE
graphics toolkit, plus many more.</P>

<P>
<A NAME="Push"></A> </P>
<DT><B>Push</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://hampshire.edu/lspector/push.html">http://hampshire.edu/lspector/push.html</A></LI>
</UL>
</P>
<P>Push is a programming language intended primarily for use in
evolutionary computation systems (such as genetic programming systems),
as the language in which evolving programs are expressed. Push has an
unusually simple syntax, which facilitates the development (or
evolution) of mutation and recombination operators that generate and
manipulate programs. Despite this simple syntax, Push provides more
expressive power than most other program representations that are used
for program evolution.</P>
<P>Includes several libraries/systems for working with GP (all info on the
Push page). PushGP is a genetic programming system that evolves
programs in the Push programming language. Pushpop is an
"autoconstructive evolution" system that also evolves Push programs.
SwarmEvolve 2.0 is an autoconstuctive evolution system in which flying
agents, controlled by Push programs, evolve in a 3D environment.</P>

<P>
<A NAME="Kali Scheme"></A> </P>
<DT><B>Kali Scheme</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://community.schemewiki.org/kali-scheme/">http://community.schemewiki.org/kali-scheme/</A></LI>
</UL>
</P>
<P>Kali Scheme is a distributed implementation of Scheme that
permits efficient transmission of higher-order objects such as
closures and continuations. The integration of distributed
communication facilities within a higher-order programming
language engenders a number of new abstractions and paradigms
for distributed computing. Among these are user-specified
load-balancing and migration policies for threads,
incrementally-linked distributed computations, agents, and
parameterized client-server applications. Kali Scheme supports
concurrency and communication using first-class procedures and
continuations. It integrates procedures and continuations into a
message-based distributed framework that allows any Scheme
object (including code vectors) to be sent and received in a
message.</P>

<P>
<A NAME="RScheme"></A> </P>
<DT><B>RScheme</B><DD><P>
<UL>
<LI>Web site:
<A HREF="http://www.rscheme.org/">http://www.rscheme.org/</A></LI>
</UL>
</P>
<P>RScheme is an object-oriented, extended version of the Scheme
dialect of Lisp. RScheme is freely redistributable, and offers
reasonable performance despite being extraordinarily portable.
RScheme can be compiled to C, and the C can then compiled with a
normal C compiler to generate machine code. By default, however,
RScheme compiles to bytecodes which are interpreted by a
(runtime) virtual machine. This ensures that compilation is fast
and keeps code size down. In general, we recommend using the
(default) bytecode code generation system, and only compiling
your time-critical code to machine code. This allows a nice
adjustment of space/time tradeoffs.  (see web site for details)</P>

<P>
<A NAME="Scheme 48"></A> </P>
<DT><B>Scheme 48</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://s48.org/">http://s48.org/</A></LI>
</UL>
</P>
<P>Scheme 48 is a Scheme implementation based on a virtual machine
architecture. Scheme 48 is designed to be straightforward, flexible,
reliable, and fast. It should be easily portable to 32-bit
byte-addressed machines that have POSIX and ANSI C support.  In
addition to the usual Scheme built-in procedures and a development
environment, library software includes support for hygienic macros (as
described in the Revised^4 Scheme report), multitasking, records,
exception handling, hash tables, arrays, weak pointers, and FORMAT.
Scheme 48 implements and exploits an experimental module system
loosely derived from Standard ML and Scheme Xerox.  The development
environment supports interactive changes to modules and interfaces.</P>

<P>
<A NAME="SCM"></A> </P>
<DT><B>SCM (<B>Scheme</B>)</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://people.csail.mit.edu/jaffer/SCM.html">http://people.csail.mit.edu/jaffer/SCM.html</A></LI>
</UL>
</P>
<P>SCM conforms to the Revised^4 Report on the Algorithmic Language
Scheme and the IEEE P1178 specification. Scm is written in C. It uses
the following utilities (all available at the ftp site).
<UL>
<LI>SLIB (Standard Scheme Library) is a portable Scheme
library which is intended to provide compatibility and utility
functions for all standard Scheme implementations, including
SCM, Chez, Elk, Gambit, MacScheme, MITScheme, scheme->C,
Scheme48, T3.1, and VSCM, and is available as the file
slib2c0.tar.gz. Written by Aubrey Jaffer.</LI>
<LI>JACAL is a symbolic math system written in Scheme, and is
available as the file jacal1a7.tar.gz.</LI>
<LI>Interfaces to standard libraries including REGEX string
regular expression matching and the CURSES screen management
package.</LI>
<LI>Available add-on packages including an interactive debugger,
database, X-window graphics, BGI graphics, Motif, and
Open-Windows packages.</LI>
<LI>A compiler (HOBBIT, available separately) and dynamic linking
of compiled modules.</LI>
</UL>
</P>

<P>
<A NAME="Shift"></A> </P>
<DT><B>Shift</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.path.berkeley.edu/shift/">http://www.path.berkeley.edu/shift/</A></LI>
</UL>
</P>
<P>Shift is a programming language for describing dynamic
networks of hybrid automata.  Such systems consist of
components which can be created, interconnected and destroyed
as the system evolves. Components exhibit hybrid behavior,
consisting of continuous-time phases separated by
discrete-event transitions. Components may evolve
independently, or they may interact through their inputs,
outputs and exported events. The interaction network itself
may evolve.</P>

<P>
<A NAME="STELLA"></A> </P>
<DT><B>STELLA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.isi.edu/isd/LOOM/Stella/">http://www.isi.edu/isd/LOOM/Stella/</A></LI>
</UL>
</P>
<P>STELLA is a strongly typed, object-oriented, Lisp-like language,
designed to facilitate symbolic programming tasks in artificial
intelligence applications. STELLA preserves those features of Common
Lisp deemed essential for symbolic programming such as built-in support
for dynamic data structures, heterogeneous collections, first-class
symbols, powerful iteration constructs, name spaces, an object-oriented
type system with a meta-object protocol, exception handling, and
language extensibility through macros, but without compromising
execution speed, interoperability with non-STELLA programs, and
platform independence. STELLA programs are translated into a target
language such as C++, Common Lisp, or Java, and then compiled with the
native target language compiler to generate executable code. The
language constructs of STELLA are restricted to those that can be
translated directly into native constructs of the intended target
languages, thus enabling the generation of highly efficient as well as
readable code.</P>

<P>
<A NAME="YAP Prolog"></A> </P>
<DT><B>YAP Prolog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.dcc.fc.up.pt/~vsc/Yap/">http://www.dcc.fc.up.pt/~vsc/Yap/</A></LI>
<LI>Sourceforge site: 
<A HREF="http://sourceforge.net/projects/yap/">http://sourceforge.net/projects/yap/</A></LI>
</UL>
</P>
<P>YAP is a high-performance Prolog compiler developed at
LIACC/Universidade do Porto. Its Prolog engine is based in the WAM
(Warren Abstract Machine), with several optimizations for better
performance. YAP follows the Edinburgh tradition, and is largely
compatible with DEC-10 Prolog, Quintus Prolog, and especially
with C-Prolog. Work on the more recent version of YAP strives at
several goals:</P>
<P>
<UL>
<LI>Portability: The whole system is now written in C. YAP
compiles in popular 32 bit machines, such as Suns and
Linux PCs, and in a 64 bit machines, the Alphas running
OSF Unix and Linux.</LI>
<LI>Performance: We have optimised the emulator to obtain
performance comparable to or better than well-known Prolog
systems. In fact, the current version of YAP performs
better than the original one, written in assembly language.</LI>
<LI>Robustness: We have tested the system with a large array
of Prolog applications.</LI>
<LI>Extensibility: YAP was designed internally from the
beginning to encapsulate manipulation of terms. These
principles were used, for example, to implement a simple
and powerful C-interface. The new version of YAP extends
these principles to accomodate extensions to the
unification algorithm, that we believe will be useful to
implement extensions such as constraint programming.</LI>
<LI>Completeness: YAP has for a long time provided most
builtins expected from a Edinburgh Prolog implementation.
These include I/O functionality, data-base operations,
and modules. Work on YAP aims now at being compatible with
the Prolog standard.</LI>
<LI>Openess: We would like to make new development of YAP
open to the user community.</LI>
<LI>Research: YAP has been a vehicle for research within and
outside our group. Currently research is going on on
parallelisation and tabulation, and we have started work
to support constraint handling.</LI>
</UL>
</P>

</DL>
</P>

<HR>
<H2><A NAME="Missing &amp; Dead"></A> <A NAME="s9">9.</A> <A HREF="AI-Alife-HOWTO.html#toc9">Missing &amp; Dead</A>    </H2>


<P>This is my area for old or bad entries. The MIA section is for entires for
which I no longer have a valid home page. If you have any information
regarding where I can find these now please let me know. The Dead section
is for projects that seem dead. Moving them here allows me to keep my
the main sections clean while allowing for interested parties to
correct me in which case I can just move it back.</P>

<H2><A NAME="ss9.1">9.1</A> <A HREF="AI-Alife-HOWTO.html#toc9.1">MIA - Projects missing linkage.</A>
    </H2>

<P>
<DL>
<P>
<A NAME="AntWars"></A> </P>
<DT><B>AntWars</B><DD><P>
<UL>
<LI>Web site: http://ant-wars.net/</LI>
</UL>
</P>
<P>Ant Wars is a competition which pits clever programs against each
other to do battle and compete for food in virtual worlds. Each
contestant is a species of ant, which can visualize only the world
immediately around him and pheromones left by fellow and enemy ants.
Using this information, the ant brain (a simple state machine) must
guide the ant towards collecting food at his home ant hill, while
fending off or attacking enemies.</P>
<P>Clever use of pheromones and subtle behaviors can create large scale
tactics such as raiding, defense, harvesting, and scouting when many
ants cooperate.</P>

<P>
<A NAME="CASE"></A> </P>
<DT><B>CASE</B><DD><P>
<UL>
<LI>Web site: http://www.iu.hio.no/~cell/</LI>
<LI>FTP site: ftp://ftp.iu.hio.no/pub/</LI>
</UL>
</P>
<P>CASE (Cellular Automaton Simulation Environment) is a C++
toolkit for visualizing discrete models in two dimensions:
so-called cellular automata. The aim of this project is to
create an integrated framework for creating generalized cellular
automata using the best, standardized technology of the day.</P>

<P>
<A NAME="CLEARS"></A> </P>
<DT><B>CLEARS</B><DD><P>
<UL>
<LI>Web site: ????</LI>
</UL>
</P>
<P>The CLEARS system is an interactive graphical environment for
computational semantics. The tool allows exploration and
comparison of different semantic formalisms, and their
interaction with syntax. This enables the user to get an idea of
the range of possibilities of semantic construction, and also
where there is real convergence between theories.</P>

<P>
<A NAME="CLIG"></A> </P>
<DT><B>CLIG</B><DD><P>
<UL>
<LI>Web site: http://www.ags.uni-sb.de/~konrad/clig.html</LI>
</UL>
</P>
<P>CLIG is an interactive, extendible grapher for visualizing linguistic
data structures like trees, feature structures, Discourse
Representation Structures (DRS), logical formulas etc. All of these can
be freely mixed and embedded into each other. The grapher has been
designed both to be stand-alone and to be used as an add-on for
linguistic applications which display their output in a graphical
manner.</P>

<P>
<A NAME="Corewar VM"></A> </P>
<DT><B>Corewar VM</B><DD><P>
<UL>
<LI>Web site: http://www.jedi.claranet.fr/</LI>
</UL>
</P>
<P>This is a virtual machine written in Java (so it is a virtual machine
for another virtual machine !) for a Corewar game.</P>

<P>
<A NAME="DAI"></A> </P>
<DT><B>DAI</B><DD><P>
<UL>
<LI>Web site: http://starship.python.net/crew/gandalf/DNET/AI/</LI>
</UL>
</P>
<P>A library for the Python programming language that provides an
object oriented interface to the CLIPS expert system tool. It
includes an interface to COOL (CLIPS Object Oriented Language)
that allows:
<UL>
<LI>Investigate COOL classes</LI>
<LI>Create and manipulate with COOL instances</LI>
<LI>Manipulate with COOL message-handler's</LI>
<LI>Manipulate with Modules</LI>
</UL>
</P>

<P>
<A NAME="DHARMI"></A> </P>
<DT><B>DHARMI</B><DD><P>
<UL>
<LI>Web site: http://megazone.bigpanda.com/~wolf/DHARMI/</LI>
</UL>
</P>
<P>DHARMI is a high level spatial, tinker-toy like language who's
components are transparently administered by a background
process called the Habitat. As the name suggests, the language
was designed to make modelling prototypes and handle living
data. Programs can be modified while running. This is accomplished
by blurring the distinction between source code, program,
and data.</P>

<P>
<A NAME="Dunce"></A> </P>
<DT><B>Dunce</B><DD><P>
<UL>
<LI>Web site: http://www.boswa.com/boswabits/</LI>
</UL>
</P>
<P>Dunce is a simple chatterbot (conversational AI) and a language for
programming such chatterbots. It uses a basic regex pattern matching
and a semi-neural rule/response firing mechanism (with excitement/decay
cycles).</P>
<P>Dunce is listed about halfway down the page.</P>

<P>
<A NAME="EcoSim"></A> </P>
<DT><B>EcoSim</B><DD><P>
<UL>
<LI>Web site: http://www.offis.de/projekte/projekt.php?id=140</LI>
</UL>
</P>
<P>NOTE: the above web site has info on EcoSim but no code to download.</P>
<P>In EcoSim an ecosystem is described by all static and dynamic
properties of the individuals involved in the system as well as time
varying properties of the environment. Individuals change their state
over time or due to internal and external events. The environment is
also defined via dynamic objects which can change. Supports on the fly
analysis and animation of generated data. It is a C++ class library
designed to support individual-oriented modelling and simulation
of ecological systems.</P>

<P>
<A NAME="Evo"></A> </P>
<DT><B>Evo</B><DD><P>
<UL>
<LI>Web site: http://omicrongroup.org/evo/</LI>
</UL>
</P>
<P>Evo is a software development framework that allows developers to build
complex alife simulations. Using Evo, researchers can easily build
systems of independent agents interacting with one another and with
their environment. Evo implements biological operators such as genetic
recombination and mutation to evolve the behavior of agents so that
they are more adapted to their environment.</P>

<P>
<A NAME="Grany-3"></A> </P>
<DT><B>Grany-3</B><DD><P>
<UL>
<LI>Web site: http://zarb.org/&nbsp;gc/html/grany.html</LI>
</UL>
</P>
<P>Grany-3 is a full-featured cellular automaton simulator, made in C++
with Gtk--, flex++/bison++, doxygen and gettext, useful to granular
media physicists.</P>

<P>
<A NAME="IBAL"></A> </P>
<DT><B>IBAL</B><DD><P>
<UL>
<LI>Web site: http://www.eecs.harvard.edu/~avi/IBAL/</LI>
</UL>
</P>
<P>IBAL (pronounced "eyeball") is a general-purpose language for
probabilistic modeling, parameter estimation and decision making. It
generalizes Bayesian networks, hidden Markov models, stochastic context
free grammars, Markov decision processes, and allows many new
possibilities. It also provides a convenient programming-language
framework with libraries, automatic type checking and so on.</P>

<P>
<A NAME="IDEAL"></A> </P>
<DT><B>IDEAL</B><DD><P>
<UL>
<LI>Web site: http://yoda.cis.temple.edu:8080/ideal/</LI>
</UL>
</P>
<P>IDEAL is a test bed for work in influence diagrams and
Bayesian networks. It contains various inference algorithms
for belief networks and evaluation algorithms for influence
diagrams. It contains facilities for creating and editing
influence diagrams and belief networks.</P>
<P>IDEAL is written in pure Common Lisp and so it will run in
Common Lisp on any platform. The emphasis in writing IDEAL has
been on code clarity and providing high level programming
abstractions. It thus is very suitable for experimental
implementations which need or extend belief network
technology.</P>
<P>At the highest level, IDEAL can be used as a subroutine
library which provides belief network inference and influence
diagram evaluation as a package. The code is documented in a
detailed manual and so it is also possible to work at a lower
level on extensions of belief network methods.</P>
<P>IDEAL comes with an optional graphic interface written in
CLIM. If your Common Lisp also has CLIM, you can run the
graphic interface.</P>

<P>
<A NAME="Illuminator"></A> </P>
<DT><B>Illuminator</B><DD><P>
<UL>
<LI>Web site: http://documents.cfar.umd.edu/resources/source/illuminator.html</LI>
</UL>
</P>
<P>Illuminator is a toolset for developing OCR and Image
Understanding applications.  Illuminator has two major parts: a
library for representing, storing and retrieving OCR
information, heretofore called dafslib, and an X-Windows "DAFS"
file viewer, called illum. Illuminator and DAFS lib were
designed to supplant existing OCR formats and become a standard
in the industry. They particularly are extensible to handle more
than just English.</P>
<P>The features of this release:
<UL>
<LI>5 magnification levels for images</LI>
<LI>flagged characters and words</LI>
<LI>unicode support -- American, British, French, German,
Greek, Italian, MICR, Norwegian, Russian, Spanish, Swedish, 
keyboards </LI>
<LI>reads DAFS, TIFF's, PDA's (image only)</LI>
<LI>save to DAFS, ASCII/UTF or Unicode</LI>
<LI>Entity Viewer - shows properties, character choices,
bounding boxes image fragment for a selected entity, change 
type, change content, hierarchy mode</LI>
</UL>
</P>

<P>
<A NAME="Jet's Neural Architecture"></A> </P>
<DT><B>Jet's Neural Architecture</B><DD><P>
<UL>
<LI>Web site: http://www.voltar-confed.org/jneural/</LI>
</UL>
</P>
<P>Jet's Neural Architecture is a C++ framework for doing neural net
projects. The goals of this project were to make a fast, flexible
neural architecture that isn't stuck to one kind of net and to make
sure that end users could easily write useful applications. All the
documentation is also easily readable.</P>

<P>
<A NAME="Neural Networks at your Fingertips"></A> </P>
<DT><B>Neural Networks at your Fingertips</B><DD><P>
<UL>
<LI>Web site: http://www.neural-networks-at-your-fingertips.com/</LI>
</UL>
</P>
<P>A set of ANSI C packages that illustrate Adaline networks,
back-propagation, the Hopfield model, BAM, Boltzman, CPN, SOM, and
ART1. Coded in portable, self-contained ANSI C. With complete example
applications from a variety of well-known application domains.</P>

<P>
<A NAME="Neureka ANS"></A> </P>
<DT><B>Neureka ANS (nn/xnn)</B><DD><P>
<UL>
<LI>FTP site: ftp://ftp.ii.uib.no/pub/neureka/</LI>
</UL>
</P>
<P>nn is a high-level neural network specification language. The
current version is best suited for feed-forward nets, but
recurrent models can and have been implemented, e.g. Hopfield
nets, Jordan/Elman nets, etc.  In nn, it is easy to change
network dynamics. The nn compiler can generate C code or
executable programs (so there must be a C compiler available),
with a powerful command line interface (but everything may also
be controlled via the graphical interface, xnn). It is possible
for the user to write C routines that can be called from inside
the nn specification, and to use the nn specification as a
function that is called from a C program. Please note that no
programming is necessary in order to use the network models that
come with the system (`netpack').</P>
<P>xnn is a graphical front end to networks generated by the nn
compiler, and to the compiler itself. The xnn graphical
interface is intuitive and easy to use for beginners, yet
powerful, with many possibilities for visualizing network data.</P>
<P>NOTE: You have to run the install program that comes with this
to get the license key installed. It gets put (by default) in
/usr/lib. If you (like myself) want to install the package
somewhere other than in the /usr directory structure (the
install program gives you this option) you will have to set up
some environmental variables (NNLIBDIR &amp; NNINCLUDEDIR are
required). You can read about these (and a few other optional
variables) in appendix A of the documentation (pg 113).</P>

<P>
<A NAME="NEURObjects"></A> </P>
<DT><B>NEURObjects</B><DD><P>
<UL>
<LI>Web site: http://www.disi.unige.it/person/ValentiniG/NEURObjects/</LI>
</UL>
</P>
<P>NEURObjects is  a set   of C++ library   classes for neural networks
development.  The main goal of  the library consists in supporting
researchers and practitioners in developing new neural network methods
and applications, exploiting the potentialities  of object-oriented
design and  programming.  NEURObjects provides also general purpose
applications for classification problems and can be used for fast
prototyping  of inductive  machine learning applications.</P>

<P>
<A NAME="OSCAR"></A> </P>
<DT><B>OSCAR</B><DD><P>
<UL>
<LI>Web site: http://oscarhome.soc-sci.arizona.edu/ftp/OSCAR-web-page/oscar.html</LI>
</UL>
</P>
<P>The goal of the OSCAR project is the formulation of a general theory of
rationality and its implementation in an artificial rational agent. The
function of artificial agents is to draw conclusions and make decisions
on the basis of information supplied to them. OSCAR is a fully
implemented architecture for rational agents, based upon a general
purpose defeasible reasoner.  OSCAR is written in Common Lisp and is
free for educational and research purposes.</P>

<P>
<A NAME="PAI"></A> </P>
<DT><B>PAI</B><DD><P>
<UL>
<LI>Web site: http://utenti.quipo.it/claudioscordino/pai.html</LI>
</UL>
</P>
<P>AI (Programmable Artificial Intelligence) is a program capable of
having a conversation in its mother tongue, English. Written in
C++.</P>

<P>
<A NAME="pygene"></A> </P>
<DT><B>pygene</B><DD><P>
<UL>
<LI>Web site: http://www.freenet.org.nz/python/pygene/</LI>
</UL>
</P>
<P>pygene is a simple and easily understandable library for genetic
algorithms and genetic programming in python. Includes examples
such as the travelling salesman problem.</P>

<P>
<A NAME="PyIE"></A> </P>
<DT><B>PyIE</B><DD><P>
<UL>
<LI>repo: https://www.dfwpython.org/repo/Projects/PyIE/</LI>
</UL>
</P>
<P>PyIE is a hypothesis based, agenda driven, object oriented inference
engine written in Python. Inferencing modes include back chaining,
opportunistic forward chaining and explicit forward chaining. The
first-class object base supports metaclasses, classes, objects and
multiple, dynamic inheritance.  All objects are first class objects and
all attributes are slot values, i.e. data members attached to some
object.</P>
<P>PyIE uses a TMS (truth maintenance system) for first level (condition
change) non-monotonic reasoning. User defined metaclasses are being
explored to support second level (belief change) non-monotonic
reasoning.</P>

<P>
<A NAME="Python ANN"></A> </P>
<DT><B>Simple Neural Net (in Python)</B><DD><P>
<UL>
<LI>Web site: http://www.amk.ca/python/unmaintained/</LI>
</UL>
</P>
<P>Simple neural network code, which implements a class for 3-level
networks (input, hidden, and output layers). The only learning
rule implemented is simple backpropagation. No documentation (or
even comments) at all, because this is simply code that I use to
experiment with. Includes modules containing sample datasets
from Carl G. Looney's NN book. Requires the Numeric
extensions.</P>

<P>
<A NAME="Python Fuzzy Logic Module"></A> </P>
<DT><B>Python Fuzzy Logic Module</B><DD><P>
<UL>
<LI>FTP site: ftp://ftp.csh.rit.edu/pub/members/retrev/</LI>
</UL>
</P>
<P>A simple python module for fuzzy logic. The file is 'fuz.tar.gz' in
this directory. The author plans to also write a simple genetic
algorithm and a neural net library as well. Check the 00_index file in
this directory for release info.</P>

<P>
<A NAME="QUANT1"></A> </P>
<DT><B>QUANT1</B><DD><P>
<UL>
<LI>Web site: http://linux.irk.ru/projects/QUANT/</LI>
</UL>
</P>
<P>This project seems to have gone proprietary. The only trace I can find
via google is at
http://www.zurich.co.uk/strategicrisk/softwaresupport/Quant1.htm.</P>
<P>QUANT/1 stands for type QUANTifier. It aims to be an alternative to
Prolog-like (Resulutional-like) systems. Main features include a lack
of necessity for eliminating Quantifiers, scolemisation, ease of
comprehension, large scale formulae operation, acceptance of nonHorn
formulaes, and Iterative deeping. The actual library implemented in
this project is called ATPPCF (Automatic Theorem Prover in calculus of
Positively Constructed Formulae).</P>
<P>ATPPCF will be a library (inference engine) and an extension of the
Predicate Calculus Language as a new logical language. The library will
be incorporable in another software such as TCL, Python, Perl. The
engine's primary inference method will be the "search of inference in
language of Positively Constructed Formulas (PCFs)" (a subset of
Predicate Calculus well translated in both directions). The language
will be used as scripting language to the engine. But there will be
possibility to replace it with extensions languages of main software.</P>

<P>
<A NAME="SCNN"></A> </P>
<DT><B>SCNN</B><DD><P>
<UL>
<LI>Web site: http://www.uni-frankfurt.de/fb13/iap/e_ag_rt/SCNN/</LI>
</UL>
</P>
<P>SCNN is an universal simulating system for Cellular Neural
Networks (CNN).  CNN are analog processing neural networks
with regular and local interconnections, governed by a set of
nonlinear ordinary differential equations. Due to their local
connectivity, CNN are realized as VLSI chips, which operates
at very high speed.</P>

<P>
<A NAME="SPI"></A> </P>
<DT><B>Symbolic Probabilistic Inference (SPI)</B><DD><P>
<UL>
<LI>FTP site: ftp://ftp.engr.orst.edu/pub/dambrosi/spi/</LI>
<LI>Paper (ijar-94.ps): ftp://ftp.engr.orst.edu/pub/dambrosi/</LI>
</UL>
</P>
<P>Contains Common Lisp function libraries to implement SPI type baysean
nets. Documentation is very limited.
Features:
<UL>
<LI>Probabilities, Local Expression Language Utilities, Explanation,
Dynamic Models, and a TCL/TK based GUI.</LI>
</UL>
</P>

<P>
<A NAME="SPRLIB-ANNLIB"></A> </P>
<DT><B>SPRLIB/ANNLIB</B><DD><P>
<UL>
<LI>Web site: http://www.ph.tn.tudelft.nl/~sprlib/</LI>
</UL>
</P>
<P>SPRLIB (Statistical Pattern Recognition Library) was developed
to support the easy construction and simulation of pattern
classifiers. It consist of a library of functions (written in C)
that can be called from your own program. Most of the well-known
classifiers are present (k-nn, Fisher, Parzen, ....), as well as
error estimation and dataset generation routines.</P>
<P>ANNLIB (Artificial Neural Networks Library) is a neural network
simulation library based on the data architecture laid down by
SPRLIB. The library contains numerous functions for creating,
training and testing feed-forward networks.  Training algorithms
include back-propagation, pseudo-Newton, Levenberg-Marquardt,
conjugate gradient descent, BFGS.... Furthermore, it is possible
- due to the datastructures' general applicability - to build
Kohonen maps and other more exotic network architectures using
the same data types.</P>

<P>
<A NAME="Sugal"></A> </P>
<DT><B>Sugal</B><DD><P>
<UL>
<LI>Web site: http://www.trajan-software.demon.co.uk/sugal.htm</LI>
</UL>
</P>
<P>Sugal [soo-gall] is the SUnderland Genetic ALgorithm system.
The aim of Sugal is to support research and implementation in Genetic
Algorithms on a common software platform. As such, Sugal supports a
large number of variants of Genetic Algorithms, and has extensive
features to support customization and extension.</P>

<P>
<A NAME="ThoughtTreasure"></A> </P>
<DT><B>ThoughtTreasure</B><DD><P>
<UL>
<LI>Web site: http://www.signiform.com/tt/htm/tt.htm</LI>
</UL>
</P>
<P>ThoughtTreasure is a project to create a database of commonsense rules
for use in any application. It consists of a database of a little over
100K rules and a C API to integrate it with your applications. Python,
Perl, Java and TCL wrappers are already available.</P>

<P>
<A NAME="TIN"></A> </P>
<DT><B>TIN</B><DD><P>
<UL>
<LI>Web site: http://www.jetlag.demon.nl/</LI>
</UL>
</P>
<P>This program simulates primitive life-forms, equipped with some
basic instincts and abilities, in a 2D environment consisting of
cells.  By mutation new generations can prove their success, and thus
passing on "good family values".</P>
<P>The brain of a TIN can be seen as a collection of processes, each
representing drives or impulses to behave a certain way, depending on the
state/perception of the environment ( e.g. presence of food, walls,
neighbors, scent traces) These behavior process currently are : eating,
moving, mating, relaxing, tracing others, gathering food and killing. The
process with the highest impulse value takes control, or in other words:
the tin will act according to its most urgent need.</P>

<P>
<A NAME="Ummon"></A> </P>
<DT><B>Ummon</B><DD><P>
<UL>
<LI>Web site: http://www.spacetide.com/projects/ummon/</LI>
</UL>
</P>
<P>Ummon is an advanced Open Source chatterbot. The main principle of the
bot is that it has no initial knowledge of either words or grammar; it
learns everything "on the fly." Numerous AI techniques will be explored
in the development of Ummon to achieve realistic "human" communication
with support for different, customizable personalities.</P>

<P>
<A NAME="ViSe"></A> </P>
<DT><B>Virtual Secretary Project (ViSe)</B><DD><P>(Tcl/Tk)
<UL>
<LI>Web site: http://www.vise.cs.uit.no/vise/</LI>
</UL>
</P>
<P>The motivation of the Virtual Secretary project is to construct
user-model-based intelligent software agents, which could in
most cases replace human for secretarial tasks, based on modern
mobile computing and computer network. The project includes two
different phases: the first phase (ViSe1) focuses on information
filtering and process migration, its goal is to create a secure
environment for software agents using the concept of user
models; the second phase (ViSe2) concentrates on agents'
intelligent and efficient cooperation in a distributed
environment, its goal is to construct cooperative agents for
achieving high intelligence. (Implemented in Tcl/TclX/Tix/Tk)</P>

<P>
<A NAME="Zeus"></A> </P>
<DT><B>Zeus</B><DD><P>
<UL>
<LI>Web site: http://more.btexact.com/projects/agents/zeus/</LI>
</UL>
</P>
<P>The construction of multi-agent systems involves long development
times and requires solutions to some considerable technical
difficulties. This has motivated the development of the ZEUS
toolkit, which provides a library of software components and tools
that facilitate the rapid design, development and deployment of
agent system</P>


</DL>
</P>


<H2><A NAME="ss9.2">9.2</A> <A HREF="AI-Alife-HOWTO.html#toc9.2">Dead projects.</A>
    </H2>

<P>
<DL>

<P>
<A NAME="FIPA-OS"></A> </P>
<DT><B>FIPA-OS</B><DD><P>
<UL>
<LI>Web site: http://fipa-os.sourceforge.net/index.htm</LI>
</UL>
</P>
<P>FIPA-OS is an open source implementation of the mandatory elements
contained within the FIPA specification for agent interoperability. In
addition to supporting the FIPA interoperability concepts, FIPA-OS also
provides a component based architecture to enable the development of
domain specific agents which can utilise the services of the FIPA
Platform agents. It is implemented in Java.</P>

<P>
<A NAME="NuPIC"></A> </P>
<DT><B>NuPIC</B><DD><P>
<UL>
<LI>Web site: http://www.numenta.com/</LI>
</UL>
</P>
<P>The Numenta Platform for Intelligent Computing (NuPIC) is built around
HTM networds (Hierarchical Temporal Memory). Based on Jeff Hawkins idea
as laid out in his On Intelligence book. NuPIC consists of the Numenta
Tools Framework and the Numenta Runtime Engine.</P>
<P>Free for non-commercial use.</P>

<P>
<A NAME="PDKB"></A> </P>
<DT><B>PDKB</B><DD><P>
<UL>
<LI>Web site: http://lynx.eaze.net/~pdkb/web/</LI>
<LI>SourceForge site: http://sourceforge.net/projects/pdkb/</LI>
</UL>
</P>
<P>Public Domain Knowledge Bank (PDKB) is an Artificial Intelligence
Knowledge Bank of common sense rules and facts. It is based on the Cyc
Upper Ontology and the MELD language.</P>

<P>
<A NAME="RobocodeNG"></A> </P>
<DT><B>RobocodeNG</B><DD><P>
<UL>
<LI>Web site: http://robocodeng.sourceforge.net/</LI>
</UL>
</P>
<P>Merged together with original 
<A HREF="#Robocode">Robocode</A>
 as of version 1.1.</P>
<P>Extension of Robocode, the battling bot AI programming game. Like its
parent, it is written in Java and meant as a learning environment.</P>

<P>
<A NAME="Sulawesi"></A> </P>
<DT><B>Sulawesi</B><DD><P>
<UL>
<LI>Web site: http://wearables.essex.ac.uk/sulawesi/</LI>
</UL>
</P>
<P>A framework called Sulawesi has been designed and implemented to
tackle what has been considered to be important challenges in a
wearable user interface. The ability to accept input from any
number of modalities, and perform if necessary a translation to any
number of modal outputs. It does this primarily through a set
of proactive agents to act on the input.</P>

<P>
<A NAME="TresBel"></A> </P>
<DT><B>TresBel</B><DD><P>
<UL>
<LI>Abstract: http://iridia.ulb.ac.be/Projects/imple.html</LI>
<LI>Direct Download: ftp://iridia.ulb.ac.be/pub/hongxu/software/TresBel.tar.Z</LI>
</UL>
</P>
<P>This project seems to have been superseded by 
<A HREF="#Pulcinella">Pulcinella</A>
.</P>
<P>Libraries containing (Allegro) Common Lisp code for Belief Functions
(aka. Dempster-Shafer evidential reasoning) as a representation
of uncertainty. Very little documentation. Has a limited GUI.</P>


</DL>
</P>

<HR>
</BODY>
</HTML>
