<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Linux Complete Backup and Recovery HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><link rel="stylesheet" href="../bookstyle.css"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
></A
>Linux Complete Backup and Recovery HOWTO</H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Charles Curley</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:charlescurley at charlescurley dot com"
>charlescurley at charlescurley dot com</A
>&#62;</TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.1</TD
><TD
ALIGN="LEFT"
>2006-03-28</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added notes for NTFS. Edited the To Do list. Started work on LVM and using <A
HREF="http://www.finnix.org/"
TARGET="_top"
>finnix</A
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.0</TD
><TD
ALIGN="LEFT"
>2005-10-12</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Notes for Fedora Core 4. Removed notes for older versions of FC and Red Hat. Also, changes in the writeup and scripts to reflect using <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> instead of <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. See the scripts for change notes. Changed some scripts so that long lines don't fall off the right side of printed pages (oops).</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.8</TD
><TD
ALIGN="LEFT"
>2005-02-19</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added notes for Fedora Core 3</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.7</TD
><TD
ALIGN="LEFT"
>2004-05-11</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Adjusted copyright language.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.6</TD
><TD
ALIGN="LEFT"
>2004-04-29</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> notes, Syslinux, PPART, QtParted, some other rescue CDs, and made some fixes.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.5</TD
><TD
ALIGN="LEFT"
>2003-12-19</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Fedora 1 and GRUB notes.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.4</TD
><TD
ALIGN="LEFT"
>2003-08-17</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Some notes on burning CD-ROMs, and more on files to exclude.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.3</TD
><TD
ALIGN="LEFT"
>2003-04-24</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Substituted new email address and URL for old.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.2</TD
><TD
ALIGN="LEFT"
>2003-02-12</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Added Red Hat 8.0 notes, support for FAT32, split the first stage restore scripts, and other minor changes. Notes on <A
HREF="#AMANDA"
>Amanda</A
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.1</TD
><TD
ALIGN="LEFT"
>2002-09-10</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>New code to handle ext3 partitions in <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, and a note on <A
HREF="#INITRD"
><TT
CLASS="FILENAME"
>initrd</TT
></A
>.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0</TD
><TD
ALIGN="LEFT"
>2002-07-24</TD
><TD
ALIGN="LEFT"
>Revised by: c^2</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>We now use bz2 compression in the first stage, have the run time option to check for bad blocks, and have a script that runs the entire first stage.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><A
NAME="AEN77"
></A
><P
></P
><P
>Imagine your disk drive has just become a very expensive hockey puck. Imagine you have had a fire, and your computer case now looks like something Salvador Dal&#297; would like to paint. Now what?</P
><P
>Total restore, sometimes called bare metal recovery, is the process of rebuilding a computer after a catastrophic failure. In order to make a total restoration, you must have complete backups, not only of your file system, but of partition information and other data. This HOWTO is a step-by-step tutorial on how to back up a Linux computer so as to be able to make a bare metal recovery, and how to make that bare metal recovery. It includes some related scripts.</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#INTRO"
>Introduction</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#COPYRIGHT"
>Copyright Information</A
></DT
><DT
>1.2. <A
HREF="#DISCLAIMERS"
>Disclaimers</A
></DT
><DT
>1.3. <A
HREF="#NEWVERSIONS"
>New Versions</A
></DT
><DT
>1.4. <A
HREF="#CREDITS"
>Credits</A
></DT
><DT
>1.5. <A
HREF="#FEEDBACK"
>Feedback</A
></DT
><DT
>1.6. <A
HREF="#TRANSLATIONS"
>Translations</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#OVERVIEW"
>Overview</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#LIMITATIONS"
>Limitations</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#PREPARATION"
>Preparation</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#INSTALLINGZIPDRIVE"
>Installing the ZIP Drive</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#CREATINGTHESTAGE1BACKUP"
>Creating the Stage 1 Back Up</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#THEMEANDVARIATIONS"
>Theme And Variations</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#FIRSTSTAGERESTORE"
>First Stage Restore</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#BOOTING"
>Booting</A
></DT
><DT
>5.2. <A
HREF="#RESTORATION"
>Restoration</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#SECONDSTAGERESTORATION"
>Second Stage Restoration</A
></DT
><DT
>7. <A
HREF="#DISTRIBUTIONSPECIFICNOTES"
>Distribution Specific Notes</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#FEDORA3"
>Fedora Core 3 and 4</A
></DT
><DT
>7.2. <A
HREF="#KNOPPIX"
>Knoppix</A
></DT
><DT
>7.3. <A
HREF="#AEN583"
>finnix</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#APPLICATIONSPECIFICNOTES"
>Application Specific Notes</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#LVM"
>Logical Volume Manager</A
></DT
><DT
>8.2. <A
HREF="#SELINUX"
>Selinux</A
></DT
><DT
>8.3. <A
HREF="#GRUB"
>GRUB</A
></DT
><DT
>8.4. <A
HREF="#TRIPWIRE"
>Tripwire</A
></DT
><DT
>8.5. <A
HREF="#SQUID"
>Squid</A
></DT
><DT
>8.6. <A
HREF="#ARKEIA"
>Arkeia</A
></DT
><DT
>8.7. <A
HREF="#AMANDA"
>Amanda</A
></DT
><DT
>8.8. <A
HREF="#NTFS"
>NTFS</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#SOMEADVICEFORDISASTERRECOVERY"
>Some Advice for Disaster Recovery</A
></DT
><DT
>10. <A
HREF="#WHATNOW"
>What Now?</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#TODO"
>To Do</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#THESCRIPTS"
>The Scripts</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#FIRSTSTAGE"
>First Stage</A
></DT
><DT
>11.2. <A
HREF="#SECONDSTAGE"
>Second Stage</A
></DT
><DT
>11.3. <A
HREF="#BACKUPSERVERSCRIPTS"
>Backup Server Scripts</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#RESOURCES"
>Resources</A
></DT
><DT
>A. <A
HREF="#APPENDIX1GFDL"
>GNU Free Documentation License</A
></DT
><DD
><DL
><DT
>0. <A
HREF="#GFDL02"
>PREAMBLE</A
></DT
><DT
>1. <A
HREF="#GFDL03"
>APPLICABILITY AND DEFINITIONS</A
></DT
><DT
>2. <A
HREF="#GFDL04"
>VERBATIM COPYING</A
></DT
><DT
>3. <A
HREF="#GFDL05"
>COPYING IN QUANTITY</A
></DT
><DT
>4. <A
HREF="#GFDL06"
>MODIFICATIONS</A
></DT
><DT
>5. <A
HREF="#GFDL07"
>COMBINING DOCUMENTS</A
></DT
><DT
>6. <A
HREF="#GFDL08"
>COLLECTIONS OF DOCUMENTS</A
></DT
><DT
>7. <A
HREF="#GFDL09"
>AGGREGATION WITH INDEPENDENT WORKS</A
></DT
><DT
>8. <A
HREF="#GFDL10"
>TRANSLATION</A
></DT
><DT
>9. <A
HREF="#GFDL11"
>TERMINATION</A
></DT
><DT
>10. <A
HREF="#GFDL12"
>FUTURE REVISIONS OF THIS LICENSE</A
></DT
><DT
>11. <A
HREF="#GFDL13"
>How to use this License for your documents</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INTRO"
></A
>1. Introduction</H1
><P
>The normal bare metal restoration process is: install the operating system from the product disks. Install the backup software, so you can restore your data. Restore your data. Then you get to restore functionality by verifying your configuration files, permissions, etc.</P
><P
>   The process and scripts explained in this HOWTO will save re-installing the operating system. The process explained here will restore only files that were backed up from the production computer. Your configuration will be intact when you restore the system, which should save you hours of verifying configurations and data.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="COPYRIGHT"
></A
>1.1. Copyright Information</H2
><P
>Copyright © 2001 through last date of modification Charles Curley and distributed under the terms of the GNU Free Documentation License (GFDL) license, stated below. Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.1 or any later version published by the Free Software Foundation; with no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the license is included in the section entitled <A
HREF="#APPENDIX1GFDL"
><SPAN
CLASS="QUOTE"
>"GNU Free Documentation License"</SPAN
></A
>.</P
><P
>If you have any questions, please contact <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-howto at metalab.unc.edu"
>linux-howto at metalab.unc.edu</A
>&#62;</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="DISCLAIMERS"
></A
>1.2. Disclaimers</H2
><P
> No liability for the contents of this documents can be accepted by the author, the <A
HREF="http://www.tldp.org/"
TARGET="_top"
>Linux Documentation Project</A
> or anyone else. Use the concepts, examples and other content at your own risk. There may be errors and inaccuracies that may damage your system. Proceed with caution, and, although errors are unlikely, the author take no responsibility for them.</P
><P
> All copyrights are held by their by their respective owners, unless specifically noted otherwise.  Use of a term in this document should not be regarded as affecting the validity of any trademark or service mark.</P
><P
>Naming of particular products or brands should not be seen as endorsements.</P
><P
>You are strongly recommended to take a backup of your system before major installation and backups at regular intervals. In addition, you are strongly recommended to use a sacrificial experimental computer when mucking with the material, especially the scripts, in this HOWTO.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NEWVERSIONS"
></A
>1.3. New Versions</H2
><P
>You can find this document at its <A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO.html"
TARGET="_top"
>home page</A
> or at the <A
HREF="http://www.tldp.org/"
TARGET="_top"
>Linux Documentation Project</A
> web site in many formats. Please comment to <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:charlescurley at charlescurley dot com"
>charlescurley at charlescurley dot com</A
>&#62;</TT
></P
><P
>Depending on your browser, you may have to hold down the shift button while you click on these in order to get them to download.</P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.chunky.html.tar.bz2"
TARGET="_top"
>bzip2 compressed chunky (lots of small pages. Faster reading.) HTML</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.smooth.html.tar.bz2"
TARGET="_top"
>bzip2 compressed smooth (one monster page -- no chunks. Easier to search.) HTML</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.ps.bz2"
TARGET="_top"
>bzip2 compressed postscript (US letter format)</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.pdf.bz2"
TARGET="_top"
>bzip2 compressed PDF (US letter format)</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.txt.bz2"
TARGET="_top"
>bzip2 compressed raw ASCII text</A
>.</P
></LI
><LI
><P
>Use the <A
HREF="http://www.charlescurley.com/Linux-Complete-Backup-and-Recovery-HOWTO/Linux-Complete-Backup-and-Recovery-HOWTO.tar.bz2"
TARGET="_top"
>source</A
>, Luke.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CREDITS"
></A
>1.4. Credits</H2
><P
>This document is derived from two articles originally published in <A
HREF="http://www.linuxjournal.com/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Linux Journal</I
></A
>. My thanks to <I
CLASS="CITETITLE"
>Linux Journal</I
> for reverting the rights to those articles, thereby helping make this HOWTO possible.</P
><P
>Thanks to Joy Y Goodreau for excellent HOWTO editing, and to David Palomares for correcting the spelling of Salvador Dal&#297;'s name.</P
><P
>Also, thanks to <A
HREF="mailto:pon at iki dot fi"
TARGET="_top"
>Pasi Oja-Nisula</A
> for a bug fix and information on <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FEEDBACK"
></A
>1.5. Feedback</H2
><P
>    Feedback is most certainly welcome for this document. Without your corrections, suggestions and other input, this document wouldn't exist. Please send your additions, comments and criticisms to me at: <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:charlescurley at charlescurley dot com"
>charlescurley at charlescurley dot com</A
>&#62;</TT
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TRANSLATIONS"
></A
>1.6. Translations</H2
><P
>Not everyone speaks English. Volunteers are welcome.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="OVERVIEW"
></A
>2. Overview</H1
><P
>The process shown below is not easy, and can be hazardous to your data. Practice it before you need it! Do as I did, and <EM
>practice on a sacrificial computer</EM
>!</P
><P
>The original target computer for this HOWTO was a Pentium computer. Originally, it had a <A
HREF="http://www.redhat.com"
TARGET="_top"
>Red Hat</A
> 7.1 Linux server or workstation installation on one IDE hard drive. Since then, I have used a number of computers, and they have been ugraded to Red Hat 8.0 and <A
HREF="http://fedora.redhat.com/"
TARGET="_top"
>Fedora Cores 1, 3 and 4.</A
>. The target computer does not have vast amounts of data because the computer was set up as a <SPAN
CLASS="QUOTE"
>"sacrificial"</SPAN
> test bed. That is, I did not want to test this process with a production computer and production data. Also, I did a fresh installation before I started the testing so that I could always re-install if I needed to revert to a known configuration.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The sample commands will show, in most cases, what I had to type to recover the target system. You may have to use similar commands, but with different parameters. It is up to you to be sure you duplicate your setup, and not the test computer's setup.</P
></TD
></TR
></TABLE
></DIV
><P
>The basic procedure is set out in W. Curtis Preston, <A
HREF="http://www.oreilly.com/catalog/unixbr/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Unix Backup &#38; Recovery</I
></A
>, O'Reilly &#38; Associates, 1999, which I have favorably reviewed in <A
HREF="http://www2.linuxjournal.com/lj-issues/issue78/3839.html"
TARGET="_top"
><I
CLASS="CITETITLE"
>Linux Journal</I
></A
>. However, the book is a bit thin on specific, real-time questions. For example, exactly which files do you back up? What metadata should you preserve, and how? This document explores those questions.</P
><P
>Before beginning the process set forth in this HOWTO you will need to back up your system with a typical backup tool such as Amanda, <SPAN
CLASS="TRADEMARK"
>BRU</SPAN
>&#8482;, tar, <SPAN
CLASS="TRADEMARK"
>Arkeia</SPAN
>&reg; or cpio. The question, then, is how to get from toasted hardware to the point where you can run the restoration tool that will restore your data.</P
><P
>Users of Red Hat Package Manager (RPM) based Linux distributions should also save RPM metadata as part of their normal backups. The following is in one of the scripts in this HOWTO:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>rpm -Va | sort +2 -t ' ' | uniq &#62; /etc/rpmVa.txt</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>It provides a basis for comparison after a bare metal restoration.</P
><P
>To get to this point, must have:</P
><P
></P
><UL
><LI
><P
>Your hardware up and running again, with replacement components as needed. The BIOS should be correctly configured, including time and date, and hard drive parameters. At the moment, there is no provision for using a different hard drive.</P
></LI
><LI
><P
>   A parallel port <A
HREF="http://www.iomega.com/"
TARGET="_top"
><SPAN
CLASS="TRADEMARK"
>Iomega</SPAN
>&reg;</A
> <A
HREF="http://www.iomega.com/zip/products/par100_250.html"
TARGET="_top"
><SPAN
CLASS="TRADEMARK"
>ZIP</SPAN
>&reg; drive</A
> or equivalent. You will need at least 30 MB of space. A modern Linux installation with several kernels installed may run to over 100 MB.</P
></LI
><LI
><P
>Your backup media.</P
></LI
><LI
><P
>A minimal Linux system that will allow you to run the restoration software, which we will call the restoration Linux.</P
></LI
></UL
><P
>To get there, you need at least two stages of backup, and possibly three. Exactly what you back up and in which stage you back it up is determined by your restoration process. For example, if you are restoring a tape server, you may not need networking during the restoration process. So only back up networking in your regular backups.</P
><P
>You will restore in stages as well. In stage one, we build partitions, file systems, etc. and restore a minimum of files from the ZIP disk. The goal of stage one is to be able to boot to a running computer with a network connection, tape drives, restoration software, or whatever we need for stage two.</P
><P
>The second stage, if it is necessary, consists of restoring backup software and any relevant databases. For example, suppose you use Arkeia and you are building a bare metal recovery ZIP disk for your backup server. Arkeia keeps a huge database on the server's hard drives. You can recover the database from the tapes, if you want. Instead, why not tar and gzip the whole arkeia directory (at /usr/knox), and save that to another computer over nfs or ssh? Stage one, as we have defined it below, does not include X, so you will have some experimenting to do if you wish to back up X as well as your backup program. Some restore programs require X.</P
><P
>Of course, if you are using some other backup program, you may have some detective work to do to. You will have to find out the directories and files it needs to run. If you use tar, gzip, cpio, mt or dd for your backup and recovery tools, they will be saved to and restored from our ZIP disk as part of the stage one process describe below.</P
><P
>The last stage is a total restoration from tape or other media. After you have done that last stage, you should be able to boot to a fully restored and operational system.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LIMITATIONS"
></A
>2.1. Limitations</H2
><P
>This HOWTO is restricted to making a minimal backup such that, having then restored that backup to new hardware (<SPAN
CLASS="QUOTE"
>"bare metal"</SPAN
>), you can then use your regular backups to restore a completely working system. This HOWTO does not deal with your regular backups at all.</P
><P
>Even within that narrow brief, this HOWTO is not exhaustive. You still have some research, script editing, and testing to do.</P
><P
>The scripts here restore the partition data exactly as found on the source hard drive. This is nice if you are restoring on an identical computer or at least an identical hard drive, but that is often not the case. For now, there are two remedies (which will make more sense after you've read the rest of the HOWTO):</P
><P
></P
><UL
><LI
><P
>Edit the partition table input file. I've done that a few times. You can also do this to add new partitions or delete existing ones (but edit the scripts that use the partition table input file as well).</P
></LI
><LI
><P
>Hand build a new partition table and go from there. That is one reason why <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> does not call the hard drive rebuilding script. Use the <A
HREF="#MAKE.DEV.HDA"
>rebuilding script</A
>.</P
></LI
></UL
><P
>The scripts shown here only handle ext2fs, FAT12, FAT16 and FAT32. Until some eager volunteer supplies code for doing so in these scripts, you will need other tools for backing up and restoring file systems we haven't covered. <A
HREF="http://www.partimage.org/"
TARGET="_top"
>Partition Image</A
> looks like a useful candidate here.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="PREPARATION"
></A
>3. Preparation</H1
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Do your normal backups on their regular schedule. This HOWTO is useless if you don't do that.</P
></TD
></TR
></TABLE
></DIV
><P
>Build yourself a rescue disk. I now use <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>. See the notes on <A
HREF="#KNOPPIX"
>Knoppix</A
> below. However, Knoppix has a problem: no LVM support. If you want to recover logical volumes, get a distribution that supports them. For this I use <A
HREF="http://www.finnix.org/"
TARGET="_top"
>finnix</A
>.</P
><P
>In the past, I have used <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. It is well documented and packs a lot of useful tools onto one floppy diskette. Unfortunately, the changes I've had to make in the scripts to handle more recent Linux systems cause problems for <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. The <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> 2.0.103 tar is based on <A
HREF="http://www.busybox.net/"
TARGET="_top"
>busybox</A
>, so remarks about it may apply to other Linux disties which use busybox.</P
><P
>We will call whatever Linux you use the <SPAN
CLASS="QUOTE"
>"restoration Linux"</SPAN
>.</P
><P
>Next, figure out how to do the operating system backup you will need so that you can restore your normal backup. I followed Preston's advice and used an Iomega parallel port ZIP drive. The drives get approximately 90 MB of useful storage to a disk. I need about 85 MB to back up my desktop, so a 100MB ZIP drive may be pushing your luck.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="INSTALLINGZIPDRIVE"
></A
>3.1. Installing the ZIP Drive</H2
><P
>Installing the ZIP drive is covered in the <A
HREF="http://www.tldp.org/HOWTO/mini/ZIP-Drive.html"
TARGET="_top"
>ZIP Drive HOWTO</A
>, available at <A
HREF="http://www.tldp.org/"
TARGET="_top"
>the Linux Documentation Project</A
> and at its home page, <A
HREF="http://www.njtcom.com/dansie/zip-drive.html"
TARGET="_top"
>http://www.njtcom.com/dansie/zip-drive.html</A
>. </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="CREATINGTHESTAGE1BACKUP"
></A
>4. Creating the Stage 1 Back Up</H1
><P
>Having made your production backups, you need to preserve your partition information so that you can rebuild your partitions.</P
><P
>The script <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> scans a hard drive for partition information, and saves it in three files. The first is an executable script, called <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.x</TT
></A
> (where <SPAN
CLASS="QUOTE"
>"x"</SPAN
> is the name of the device file, e.g. hda). Second is <A
HREF="#MOUNT.DEV.HDA"
><TT
CLASS="FILENAME"
>mount.dev.x</TT
></A
>, which creates mount points and mounts the newly created partitions on them. The last, <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.x</TT
></A
>, is the commands necessary for <B
CLASS="COMMAND"
>fdisk</B
> to build the partitions. You specify which hard drive you want to build scripts for (and thus the file names) by naming the associated device file as the argument to <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>. For example, on a typical IDE system,</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>make.fdisk /dev/hda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>spits out the scripts <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
>, <A
HREF="#MOUNT.DEV.HDA"
><TT
CLASS="FILENAME"
>mount.dev.hda</TT
></A
> and the input file for <B
CLASS="COMMAND"
>fdisk</B
>, <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
>.</P
><P
>In addition, if <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> encounters a FAT partition, it preserves the partition's boot sector in a file named <TT
CLASS="FILENAME"
>dev.xy</TT
>, where x is the drive's device name (e.g. sdc, hda) and y is the partition number. The boot sector is the first sector, 512 bytes, of the partition. This sector is restored at the same time the partitions are rebuilt, in the script <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
>.</P
><P
>Fortunately, the price of hard drives is plummeting almost as fast as the public's trust in politicians after an election. So it is good that the output files are text, and allow hand editing. That's the most difficult but most flexible way to rebuild on a larger replacement drive. (See the <A
HREF="#TODO"
>To Do list</A
>.)</P
><P
>Other metadata are preserved in the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>. The script saves the partition information in the file <TT
CLASS="FILENAME"
>fdisk.hda</TT
> in the root of the ZIP disk. It is a good idea to print this file and your <TT
CLASS="FILENAME"
>/etc/fstab</TT
> so that you have hard copy should you ever have to restore the partition data manually. You can save a tree by toggling between two virtual consoles, running <B
CLASS="COMMAND"
>fdisk</B
> in one and catting <TT
CLASS="FILENAME"
>/etc/fstab</TT
> or <TT
CLASS="FILENAME"
>/fdisk.hda</TT
> as needed. However, doing so is error prone.</P
><P
>You will also want to preserve files relevant to your restoration method. For example, if you use nfs to save your data, you will need to preserve hosts.allow, hosts.deny, exports, etc. Also, if you are using any network-backed restoration process, such as Amanda or Quick Restore, you will need to preserve networking files like HOSTNAME, hosts, etc. and the relevant software tree.</P
><P
>The simplest way to handle these and similar questions is to preserve the entire etc directory.</P
><P
>There is no way a 100 MB ZIP drive is going to hold a server installation of a modern distribution of Linux. We have to be much more selective than simply preserving the whole kazoo. What files do we need?</P
><P
></P
><UL
><LI
><P
>The boot directory.</P
></LI
><LI
><P
>The /etc directory and subdirectories.</P
></LI
><LI
><P
>Directories needed at boot time.</P
></LI
><LI
><P
>Device files in /dev.</P
></LI
></UL
><P
>To determine the directories needed at boot, we look at the boot initialization file <TT
CLASS="FILENAME"
>/etc/rc.sysinit</TT
>. It sets its own path like so:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>PATH=/bin:/sbin:/usr/bin:/usr/sbin
export PATH</PRE
></FONT
></TD
></TR
></TABLE
><P
>Trial and error indicated that we needed some other directories as well, such as <TT
CLASS="FILENAME"
>/dev</TT
>. In Linux, you can't do much without device files.</P
><P
>In reading the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>, note that we aren't necessarily saving files that are called with absolute paths.</P
><P
>We may require several iterations of back up, test the bare metal restore, re-install from CD and try again, before we have a working backup script. While I worked on this HOWTO, I made five such iterations before I had a successful restoration. That is one reason why it is essential to use scripts whenever possible. Test thoroughly!</P
><P
>One thing you can do on an RPM based system is use the <B
CLASS="COMMAND"
>rpm</B
> program to determine which files are where. For example, to get a complete list of the files used by the openssh package, run:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>rpm -ql openssh</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>There are some things you don't need, like the man pages. You can inspect each one and decide whether to back it up or not.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The second stage of restoration is run without overwriting previously restored files. This means that the files restored in the first stage are the ones that will be used after full restoration. So update your bare metal backups whenever you update files in these directories!</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The version of <B
CLASS="COMMAND"
>tar</B
> included in <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> does not preserve ownership when it restores. This may cause problems for applications like <A
HREF="#AMANDA"
>Amanda</A
>. A backup and restoration tool, Amanda has several directories owned by its own eponymous user. The solution is:</P
><P
></P
><UL
><LI
><P
>Note which directories and files are not owned by root.</P
></LI
><LI
><P
>Note their owners.</P
></LI
><LI
><P
>Arrange to set the ownership correctly as part of the restoration process. E.g:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>chown -R amanda:disk /var/lib/amanda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You can also add that line to your scripts for second state restoration, such as <A
HREF="#RESTORE.TESTER"
><TT
CLASS="FILENAME"
>restore.tester</TT
></A
>.</P
></LI
></UL
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>WARNING</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
><A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> does not support restoring owners by UID/GID. To make backups suitable for restoring with <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, remove the tar command line option <SPAN
CLASS="QUOTE"
>"--numeric-owner"</SPAN
> from the command line options for tar in the function crunch in the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="THEMEANDVARIATIONS"
></A
>4.1. Theme And Variations</H2
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN321"
></A
>4.1.1. No ZIP drive</H3
><P
>This backup process used to requires you to have the ZIP disk drive present at each backup. It now creates the ZIP disk's contents in a directory, which you can back up over the net. Then you only need to build a ZIP disk (with <B
CLASS="COMMAND"
>cp -rp</B
>) on the backup server when you need to restore.</P
><P
>The backup process will be faster than directly writing to the ZIP drive, but you should check that the resulting directory will fit on your ZIP disk (with the output of <B
CLASS="COMMAND"
>du -hs $target.zip</B
> in the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>)! See the definition of the variable <TT
CLASS="VARNAME"
>zip</TT
> in that script.</P
><P
>My laptop has problems running both a network card and a ZIP drive, so this is the process I use to back it up. I keep a backup image as well as the current one, so that I have a fallback in case the computer crashes during a backup.</P
><P
>Alternatively, you could build several ZIP disks' worth of backup on the hard drive, and feed them to the system on restore.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="AEN332"
></A
>4.1.2. CD-ROM</H3
><P
>This is similar to the no ZIP drive option above. Save your backups to a directory on your hard drive, as noted. Then use <B
CLASS="COMMAND"
>mkisofs</B
> to create an ISO 9660 image from that directory, and burn it. This does not work with some CD-ROM based Linuxes, like <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, because the Linux has to have the CD-ROM drive. Unless you have two CD-ROM drives, say one in a USB clamshell. I have a DVD burner set up this way with exactly this in mind.</P
><P
>Or look at <A
HREF="http://www.knoppix.net/wiki/Knoppix_Remastering_Howto"
TARGET="_top"
>remastering</A
> Knoppix with your first and second stage backups on the CD-ROM/DVD. You should also be able to <A
HREF="http://www.finnix.org/Remastering_Finnix"
TARGET="_top"
>remaster finnix</A
>.</P
><P
>These days many computers come with a CD-ROM drive but no floppy diskette. And floppy drives do fail. So it's a good idea to burn your CD-ROM with a bootable image on it. The bad news is that the <SPAN
CLASS="QUOTE"
>"El Torito"</SPAN
> format supports 1.2 MB, 1.44 MB and 2.88 MB floppies, and <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> uses a 1.7 MB floppy. The good news is that you can get a 2.88 MB version, <TT
CLASS="FILENAME"
>tomsrtbt-2.0.103.ElTorito.288.img</TT
>, from the same mirrors where you get the floppy image. Place a <EM
>copy</EM
>
<A
NAME="AEN345"
HREF="#FTN.AEN345"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>
 in the root directory of the backup files. Then use the <B
CLASS="COMMAND"
>mkisofs</B
> command line option -b to specify <TT
CLASS="FILENAME"
>tomsrtbt-2.0.103.ElTorito.288.img</TT
> as the boot image file.</P
><P
>The only down side of this process is that many older BIOSes do not support 2.88 MB floppy images on CD-ROMs. Most of those will boot to a <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> floppy.</P
><P
>An alternative is to use <A
HREF="http://syslinux.zytor.com/"
TARGET="_top"
>Syslinux</A
>. It is not dependent on a floppy diskette image, and you can build your own CD with a number of tools, such as <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, on it.</P
><P
>You may have to adjust the BIOS options to allow the computer to boot to CD-ROM drive. If you can't do that, either because the BIOS won't support booting to CD-ROM, or because you can't get into the BIOS, see <A
HREF="http://btmgr.webframe.org/"
TARGET="_top"
>Smart Boot Manager (SBM)</A
> as described in the <A
HREF="#RESOURCES"
>Resources</A
>.</P
><P
><EM
>Test</EM
> your CDs on the drive you will use at restoration time. If you find you need to hack the scripts, you can copy them to <TT
CLASS="FILENAME"
>/tmp</TT
>, a RAM disk under <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, and edit them there. The scripts will run there. As a RAM disk is volatile, be sure to save your changes before you reboot!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="AEN362"
></A
>4.1.3. Multiple ZIP disks</H3
><P
>By splitting up the two first stage scripts, <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> and <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>, you could spread the first stage metadata across multiple ZIP disks.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="AEN369"
></A
>4.1.4. Excluding From First Stage Saving</H3
><P
>There are time when you need to squeeze a few megabytes from the first stage data, especially when you are pushing the limit of your ZIP disk. The function <B
CLASS="COMMAND"
>crunch</B
> in the script <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
> takes multiple parameters to feed to <B
CLASS="COMMAND"
>tar</B
>. It can also take the <B
CLASS="COMMAND"
>--exclude</B
> parameter. So, for example, you can exclude the <TT
CLASS="FILENAME"
>samba</TT
> and <TT
CLASS="FILENAME"
>X11</TT
> directories under <TT
CLASS="FILENAME"
>/etc</TT
> like so:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>crunch etc --exclude etc/samba --exclude etc/X11 etc</PRE
></FONT
></TD
></TR
></TABLE
><P
>Why those two? Because they're hard drive space hogs and we don't need them at boot time.</P
><P
>If you keep multiple kernels around, you can eliminate the modules for all of the kernels you won't boot to. Check your <TT
CLASS="FILENAME"
>lilo.conf</TT
> or <TT
CLASS="FILENAME"
>grub.conf</TT
>to see which kernel you will use, and then check <TT
CLASS="FILENAME"
>/lib/modules</TT
> for module directories you can exclude.</P
><P
>How to find more good candidates for exclusion? List the target directories with <B
CLASS="COMMAND"
>ls -alSr</B
> for individual files, and <B
CLASS="COMMAND"
>du | sort -n</B
> for directories.</P
><P
>Another (probably neater) way to exclude directories is to put a complete list of directories into a file, then refer to it via the tar option <TT
CLASS="FILENAME"
>--exclude-from=FILENAME</TT
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="INITRD"
></A
>4.1.5. Initrd</H3
><P
>If your system uses an initial RAM disk, or initrd, to boot, make sure that <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
> creates the directory <TT
CLASS="FILENAME"
>/initrd</TT
>. The easiest way to do this is to ensure that it is included in the list of directories used in the directory creating loop toward the end.</P
><P
>Your system will probably use an initrd if it boots from a SCSI drive or has root on an ext3fs partition. Check <TT
CLASS="FILENAME"
>/etc/lilo.conf</TT
> to see if it calls for one.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="FIRSTSTAGERESTORE"
></A
>5. First Stage Restore</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BOOTING"
></A
>5.1. Booting</H2
><P
>The first thing to do is to verify that the hardware time is set correctly. Use the BIOS setup for this. How close to exact you have to set the time depends on your applications. For restoration, within a few minutes of exact time should be accurate enough. This will allow time-critical events to pick up where they left off when you finally launch the restored system.</P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="BOOTINGTOMSRTBT"
></A
>5.1.1. tomsrtbt</H3
><P
>Before booting <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, make sure your ZIP drive is installed on a parallel port, either <TT
CLASS="FILENAME"
>/dev/lp0</TT
> or <TT
CLASS="FILENAME"
>/dev/lp1</TT
>. The start-up software will load the parallel port ZIP drive driver for you.</P
><P
>The next step is to set the video mode. I usually like to see as much on the screen as I can. When the option to select a video mode comes, I use mode 6, 80 columns by 60 lines. Your hardware may or may not be able to handle high resolutions like that, so experiment with it.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="BOOTINGKNOPPIX"
></A
>5.1.2. Knoppix</H3
><P
>These instructions will probably work with other CD-ROM or USB pen Linuxes, but you may have to vary them to suit.</P
><P
>Before booting <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, make sure your ZIP drive (or substitute) is installed on a parallel port, either <TT
CLASS="FILENAME"
>/dev/lp0</TT
> or <TT
CLASS="FILENAME"
>/dev/lp1</TT
>. Knoppix does not load the parallel port ZIP drive driver for you. Instead, use the command <B
CLASS="COMMAND"
>modprobe ppa</B
> (as root) to install it.</P
><P
>Boot <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> as usual. I find it faster and more useful to boot to a console. At the boot menu, use the command <SPAN
CLASS="QUOTE"
>"knoppix 2"</SPAN
>. Then become the root user, with <B
CLASS="COMMAND"
>su -</B
>. For the password, just hit return.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="BOOTINGFINNIX"
></A
>5.1.3. Finnix</H3
><P
>One option for booing <A
HREF="http://www.finnix.org/"
TARGET="_top"
>finnix</A
> is the "toram" option, which lets you move the whole kazoo into RAM. that in turn should let you load another CD, with your first stage data, into the CD drive.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="RESTORATION"
></A
>5.2. Restoration</H2
><P
>These instructions assume you are running <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>. If you are using a different Linux for your restore system, you may have to adjust these instructions a bit. For example, you should always run these scripts as root even if some other user gives you the requisite privileges.</P
><P
>Once the restoration Linux has booted and you have a console, mount the ZIP drive. It is probably a good idea to mount it read only:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>mount /dev/sda1 /mnt -o ro</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Check to be sure it is there:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>ls -l /mnt</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>On <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> or <A
HREF="http://www.finnix.org/"
TARGET="_top"
>finnix</A
>, you may want to make a directory under <TT
CLASS="FILENAME"
>/mnt</TT
> and mount it there, like so:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>mkdir /mnt/zip</B
>
# <B
CLASS="COMMAND"
>mount /dev/sda1 /mnt/zip -o ro</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>At this point, you can run the restoration automatically or manually. Use the automated restore if you don't need to make any changes as you go along.</P
><P
>One consideration here is whether you have multiple hard drives. If your Linux installation mounts partitions on multiple hard drives, you must mount the root partition first. This is to ensure that mount point directories are created on the partition where they belong. The script <TT
CLASS="FILENAME"
>first.stage</TT
> will run the scripts to mount the drives in the order in which they are created. If you have created them (in the script <TT
CLASS="FILENAME"
>save.metadata</TT
>) in the order in which they cascade from root, the mounting process should work just fine.</P
><P
>If you have multiple hard drives, and they cross-mount, you are on your own. Either combine and edit the scripts to mount them in the correct order, or do it manually.</P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="AEN449"
></A
>5.2.1. Automated</H3
><P
>The automatic process calls each of the manual scripts in proper order. It does not allow for manual intervention, say for creating file systems that this HOWTO does not support. To run the first stage restore automatically, enter the command:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>/mnt/root.bin/first.stage</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If you want to check for back blocks, add the <B
CLASS="COMMAND"
>-c</B
> option.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="AEN456"
></A
>5.2.2. Manually</H3
><P
>To run the process manually, change to the directory where the scripts are on the ZIP drive.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>cd /mnt/root.bin</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Now run the script(s) that will restore the partition information and create file systems. You may run them in any order. e.g.:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>./make.dev.hda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If you want to check for back blocks, add the <B
CLASS="COMMAND"
>-c</B
> option.</P
><P
>This script will:</P
><P
></P
><UL
><LI
><P
>Clean out the first 1024 bytes of the hard drive, killing off any existing partition table and master boot record (MBR).</P
></LI
><LI
><P
>Recreate the partitions from the information gathered when you ran <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>.</P
></LI
><LI
><P
>Make ext2 and ext3 file system partitions and Linux swap partitions as appropriate. If you provide the <B
CLASS="COMMAND"
>-c</B
> option to the script, it will also check for bad blocks.</P
></LI
><LI
><P
>Make some types of FAT partitions.</P
></LI
></UL
><P
>Now is a good time to check the geometry of the drive. Sometimes different versions of Linux pick up different geometries, so the geometry implicit in the file <TT
CLASS="FILENAME"
>dev.hdX</TT
> is incorrect. To force it to be correct on <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, edit <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.x</TT
></A
>. Use the -C, -H and -S options to fdisk to specify the cylnders, heads and sectors, respectively. Those you can get from the file <TT
CLASS="FILENAME"
>fdisk.hdX</TT
> in the root directory of the ZIP drive. Then re-run it.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>If you have other operating systems or file systems to restore, now is a good time to do so. When you've done that, reboot to your restoration Linux and continue restoring.</P
></TD
></TR
></TABLE
></DIV
><P
>Now run the script(s) that create mount points and mount the partitions to them.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>./mount.dev.hda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Once you have created all your directories and mounted partitions to them, you can run the script <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>./restore.metadata</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>This will restore the contents of the ZIP drive to the hard drive.</P
><P
>You should see a directory of the ZIP disk's root directory, then a list of the archive files as they are restored. Tar on <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
> will tell you that tar's block size is 20, and that's fine. You can ignore it. Be sure that lilo prints out its results:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Added linux *</PRE
></FONT
></TD
></TR
></TABLE
><P
>   That will be followed by the output from a <SPAN
CLASS="QUOTE"
>"<B
CLASS="COMMAND"
>df -m</B
>"</SPAN
> command.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="AEN503"
></A
>5.2.3. Finishing Touches</H3
><P
>If you normally boot directly to X, you could have some problems. To be safe, change your boot run level temporarily.</P
><P
>If you use grub to boot, in the grub selection window, select the kernel you want to boot. Press <SPAN
CLASS="QUOTE"
>"e"</SPAN
> to edit, and append a space and the number <SPAN
CLASS="QUOTE"
>"3"</SPAN
> tot he kernel line. Confirm the new line, then hit <SPAN
CLASS="QUOTE"
>"b"</SPAN
> to boot.</P
><P
>If you don't use grub, before you reboot edit <TT
CLASS="FILENAME"
>/target/etc/inittab</TT
>. Find the line that looks like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>id:5:initdefault:</PRE
></FONT
></TD
></TR
></TABLE
><P
>and change it to this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>id:3:initdefault:</PRE
></FONT
></TD
></TR
></TABLE
><P
>Now, you can gracefully reboot. Remove the medium from your boot drive if you haven't already done so, and give the computer the three fingered salute, or its equivalent:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>shutdown -r now</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>or</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># <B
CLASS="COMMAND"
>reboot</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>The computer will shut down and reboot.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SECONDSTAGERESTORATION"
></A
>6. Second Stage Restoration</H1
><P
>As the computer reboots, go back to the BIOS and verify that the clock is more or less correct.</P
><P
>Once you have verified the clock is correct, exit the BIOS and reboot to the hard drive. You can simply let the computer boot in its normal sequence. You will see a lot of error messages, mostly along the lines of <SPAN
CLASS="QUOTE"
>"I can't find blah! Waahhh!"</SPAN
> If you have done your homework correctly up until now, those error messages won't matter. You don't need linuxconf or apache to do what you need to do.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>As an alternative, you can boot to single user mode (at the lilo prompt, enter <B
CLASS="COMMAND"
>linux single</B
>), but you will have to configure your network manually and fire up sshd or whatever daemons you need to restore your system. How you do those things is very system specific.</P
></TD
></TR
></TABLE
></DIV
><P
>You should be able to log into a root console (no X -- no users, sorry). You should now be able to use the network, for example to nfs mount the backup of your system.</P
><P
>If you did the two stage backup I suggested for Arkeia, you can now restore Arkeia's database and executables. You should be able to run</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>/etc/rc.d/init.d/arkeia start</PRE
></FONT
></TD
></TR
></TABLE
><P
>and start the server. If you have the GUI installed on another computer with X installed, you should now be able to log in to Arkeia on your tape server, and prepare your restoration.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>NOTE</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>When you restore, read the documentation for your restoration programs carefully. For example, tar does not normally restore certain characteristics of files, like suid bits. File permissions are set by the user's umask. To restore your files exactly as you saved them, use tar's p option. Similarly, make sure your restoration software will restore everything exactly as you saved it.</P
></TD
></TR
></TABLE
></DIV
><P
>To restore the test computer:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>restore.all</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>If you used tar for your backup and restoration, and used the -k (keep old files, don't overwrite) option, you will see a lot of this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>tar: usr/sbin/rpcinfo: Could not create file: File exists
tar: usr/sbin/zdump: Could not create file: File exists
tar: usr/sbin/zic: Could not create file: File exists
tar: usr/sbin/ab: Could not create file: File exists</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is normal, as tar is refusing to overwrite files you restored during the first stage of restoration.</P
><P
>Then reboot. On the way down, you will see a lot of error messages, such as <SPAN
CLASS="QUOTE"
>"no such pid."</SPAN
> This is a normal part of the process. The shutdown code is using the pid files from daemons that were running when the backup was made to shut down daemons that were not started on the last boot. Of course there's no such pid.</P
><P
>Your system should come up normally, with a lot fewer errors than it had before; ideally no errors. The acid test of how well your restore works on an RPM based system is to verify all packages:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>rpm -Va | sort +2 -t ' ' | uniq &#62; ~/foo.txt
diff /etc/rpmVa.txt ~/foo.txt</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Prelinking error messages are normal and you can ignore them. Or you may run the command <B
CLASS="COMMAND"
>/etc/cron.daily/prelink</B
> to remove them.</P
><P
>Some files, such as configuration and log files, will have changed in the normal course of things, and you should be able to mentally filter those out of the report. You can redirect the output to a file, and diff it against the one that was made at backup time (/etc/rpmVa.txt), thereby speeding up this step considerably. Emacs users should check out its diff facilities.</P
><P
>Now you should be up and running. It is time to test your applications, especially those that run as daemons. The more sophisticated the application, the more testing you may need to do. If you have remote users, disable them from using the system, or make it <SPAN
CLASS="QUOTE"
>"read only"</SPAN
> while you test it. This is especially important for databases, to prevent making any corruption or data loss worse than it already might be.</P
><P
>If you normally boot to X, and disabled it above, test X before you re-enable it. Re-enable it by changing that one line in /etc/inittab back to:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>id:5:initdefault:</PRE
></FONT
></TD
></TR
></TABLE
><P
>You should now be ready for rock and roll -- and some aspirin and a couch.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="DISTRIBUTIONSPECIFICNOTES"
></A
>7. Distribution Specific Notes</H1
><P
>Below are distribution notes from past experiences. If you have additional notes that you would like to add for other distributions, please forward them to me.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FEDORA3"
></A
>7.1. Fedora Core 3 and 4</H2
><P
>The scripts now reflect Fecorda Core 4, so you should not have to make any changes to these <A
HREF="#THESCRIPTS"
>scripts</A
>.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>I tested the above on a fresh installation of FC3. I had problems with devices after booting when I worked with a system that had been upgraded from FC2 to FC3.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="KNOPPIX"
></A
>7.2. Knoppix</H2
><P
>I recently started using <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>. <A
HREF="mailto:pon at iki dot fi"
TARGET="_top"
>Pasi Oja-Nisula</A
> reports:</P
><A
NAME="AEN571"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>For me the best thing about using Knoppix is that I don't need a specific boot medium for each machine, but I can use the same tools all the time. And hardware support in Knoppix is really great. I don't have that much experience with different platforms, but all the machines I've tried have worked fine, scsi drivers are found and so on.</P
><P
>I'm doing this recovery thing by copying the backups over the network to other machine. The restore involves booting the Knoppix cd, fetching the metadata.tar.gz from the network machine. Then make.dev, mount.dev, fetching the other tar.gz files, grub and reboot. Some typing involved but thanks to your scripts it's quite straighforward. Unless changing from ide to scsi or something, but even then it's not that difficult, since Linux is easy to restore to different hardware.</P
></BLOCKQUOTE
><P
>Let me add to that that <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> detects USB devices for you, which is really nice. They make excellent (and roomier) substitutes for the ZIP drive.</P
><P
>Also see <A
HREF="http://www-106.ibm.com/developerworks/linux/library/l-knopx.html?ca=dgr-lnxw04Knoppix"
TARGET="_top"
><SPAN
CLASS="QUOTE"
>"System recovery with Knoppix"</SPAN
></A
>.</P
><P
>Do your restore as user <SPAN
CLASS="QUOTE"
>"root"</SPAN
> rather than as user <SPAN
CLASS="QUOTE"
>"knoppix"</SPAN
>. Otherwise you may get some directories and files owned by an oddball user or group. Also, for <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
>, we tar the first stage stuff saving numeric user &#38; group values instead of by name. The names may point to different numbers on knoppix, so we would be restoring the files incorrectly.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN583"
></A
>7.3. finnix</H2
><P
><A
HREF="Http://Www.Finnix.Org/"
TARGET="_top"
>Finnix</A
> has some of the same advantages of Knoppix. In addition, it runs in command line mode with mouse support, which is great for the task at hand. It's small, under 100 MB as of this writing, so you can remaster it with your first stage data on it. It boots quickly. And it has LVM support. And Zile, a subset of Emacs. I am pleased with <A
HREF="http://www.finnix.org/"
TARGET="_top"
>finnix</A
> for this use.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="APPLICATIONSPECIFICNOTES"
></A
>8. Application Specific Notes</H1
><P
>Here are some notes about backing up particular applications.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="LVM"
></A
>8.1. Logical Volume Manager</H2
><P
>Handling logical volumes turns out to be a bit of a trick: use the <A
HREF="http://www.finnix.org/"
TARGET="_top"
>finnix</A
> distribution's startup code to turn LVM on and off. This results in distribution specific code for the first stage of restoration. It is generated in <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>. To edit it, search <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> on <SPAN
CLASS="QUOTE"
>"Hideous"</SPAN
>.</P
><P
>LVM required the addition of two new LVM specific scripts, <A
HREF="#MAKE.LVS"
>make.lvs</A
> and <A
HREF="#MOUNT.LVS"
>mount.lvs</A
>. They are only generated and used if there are logical volumes present.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="SELINUX"
></A
>8.2. Selinux</H2
><P
>Selinux is disabled on the test machines. <TT
CLASS="FILENAME"
>/selinux</TT
> is not backed up in any of these scripts. At a guess, you should probably disable selinux after the first stage restoration, and you will probably have some selinux specific tasks to perform before turning it back on.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="GRUB"
></A
>8.3. GRUB</H2
><P
>The default bootloader in <A
HREF="#FEDORA3"
>Fedora</A
> is the <A
HREF="http://www.gnu.org/software/grub/"
TARGET="_top"
>Grand Unified Bootloader (GRUB)</A
>. It has to run at the end of the first stage, or you won't be able to boot thereafter. To preserve it for first stage restoration, make the following changes:</P
><P
></P
><UL
><LI
><P
>Edit the penultimate stanza of <A
HREF="#RESTORE.METADATA"
><TT
CLASS="FILENAME"
>restore.metadata</TT
></A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># Now install the boot sector.
# chroot $target /sbin/lilo -C /etc/lilo.conf
chroot $target /sbin/grub-install /dev/hda</PRE
></FONT
></TD
></TR
></TABLE
></LI
><LI
><P
>Add the following stanza to <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># Grub requires these at installation time.
if [ -d  usr/share/grub ] ; then # Red Hat/Fedora
  crunch usr.share.grub usr/share/grub
fi
if [ -d  usr/lib/grub ] ; then # SuSE
  crunch usr.lib.grub usr/lib/grub
fi</PRE
></FONT
></TD
></TR
></TABLE
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TRIPWIRE"
></A
>8.4. Tripwire</H2
><P
>If you run Tripwire or any other application that maintains a database of file metadata, rebuild that database immediately after restoring.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="SQUID"
></A
>8.5. Squid</H2
><P
>Squid is a HTTP proxy and cache. As such it keeps a lot of temporary data on the hard drive. There is no point in backing that up. Insert <SPAN
CLASS="QUOTE"
>"--exclude /var/spool/squid"</SPAN
> into the appropriate tar command in your second stage backup script. Then, get squid to rebuild its directory structure for you. Tack onto the tail end of the second stage restore script a command for squid to initialize itself. Here is how I did it over ssh in <A
HREF="#RESTORE.TESTER"
><TT
CLASS="FILENAME"
>restore.tester</TT
></A
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>ssh $target "mkdir /var/spool/squid ; chown squid:squid /var/spool/squid;\
      /usr/sbin/squid -z;touch /var/spool/squid/.OPB_NOBACKUP"</PRE
></FONT
></TD
></TR
></TABLE
><P
>The last command creates a file of length 0 called .OPB_NOBACKUP. This is for the benefit of <A
HREF="#ARKEIA"
>Arkeia</A
>, and tells Arkeia not to back up below this directory</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="ARKEIA"
></A
>8.6. Arkeia</H2
><P
>These notes are based on testing with Arkeia 4.2.</P
><P
><A
HREF="http://www.arkeia.com/"
TARGET="_top"
>Arkeia</A
> is a backup and restore program that runs on a wide variety of platforms. You can use Arkeia as part of a bare metal restoration scheme, but there are two caveats.</P
><P
>The first is probably the most problematic, as absent any more elegant solution you have to hand select the directories to restore in the navigator at restoration time. The reason is that, apparently, Arkeia has no mechanism for not restoring files already present on the disk, nothing analogous to <B
CLASS="COMMAND"
>tar</B
>'s -p option. If you simply allow a full restore, the restore will crash as Arkeia over-writes a library which is in use at restore time, e.g. <TT
CLASS="FILENAME"
>lib/libc-2.1.1.so</TT
>. Hand selection of directories to restore is at best dicey, so I recommend against it.</P
><P
>The second caveat is that you have to back up the Arkeia data dictionary and/or programs. To do that, modify the <TT
CLASS="FILENAME"
>save.metatdata</TT
> script by adding Arkeia to the list of directories to save:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
># arkeia specific:
tar cf - usr/knox | gzip -c &#62; $zip/arkeia.tar.gz</PRE
></FONT
></TD
></TR
></TABLE
><P
>You <EM
>must</EM
> back up the data dictionary this way because Arkeia does not back up the data dictionary. This is one of my complaints about Arkeia, and I solve it on my own computer by saving the data dictionary to tape with <A
HREF="http://www.estinc.com/"
TARGET="_top"
>The TOLIS Group's BRU</A
>.</P
><P
>The data dictionary will be restored in the script <TT
CLASS="FILENAME"
>restore.metadata</TT
> automatically.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AMANDA"
></A
>8.7. Amanda</H2
><P
><A
HREF="http://www.amanda.org/"
TARGET="_top"
>Amanda</A
> (The Advanced Maryland Automatic Network Disk Archiver) works quite well with this set of scripts. Use the normal Amanda back-up process, and build your first stage data as usual. Amanda stores the data on tape in GNU tar or cpio format, and you can recover from individual files to entire backup images. The nice thing about recovering entire images is that you can then use variants on the scripts in this HOWTO to restore from the images, or direct from tape. I was able to restore my test machine with the directions from W. Curtis Preston's <A
HREF="http://www.oreilly.com/catalog/unixbr/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Unix Backup &#38; Recovery</I
></A
>. For more information on it, see the <A
HREF="#RESOURCES"
>Resources</A
>. The Amanda chapter from the book is <A
HREF="http://www.backupcentral.com/amanda.html"
TARGET="_top"
>on line</A
>.</P
><P
>I made two changes to the script <A
HREF="#RESTORE.TESTER"
><TT
CLASS="FILENAME"
>restore.tester</TT
></A
>. First, I changed it to accept a file name as an argument. Then, since Amanda's <B
CLASS="COMMAND"
>amrestore</B
> decompresses the data as it restores it, I rewrote it to cat the file into the pipe instead of decompressing it.</P
><P
>The resulting line looks like this:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>cat $file | ssh $target "umask 000 ; cd / ; tar -xpkf - "</PRE
></FONT
></TD
></TR
></TABLE
><P
>where <B
CLASS="COMMAND"
>$file</B
> is the script's argument, the image recovered from the tape by <B
CLASS="COMMAND"
>amrestore</B
>.</P
><P
>Since the command line arguments to <B
CLASS="COMMAND"
>tar</B
> prohibit over-writing, restore from images in the <EM
>reverse</EM
> of the order in which they were made. Restore most recent first.</P
><P
>Amanda does require setting ownership by hand if you back up the amanda data directory with <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>. Something like:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>bash# <B
CLASS="COMMAND"
>chown -R amanda:disk /var/lib/amanda</B
></PRE
></FONT
></TD
></TR
></TABLE
><P
>You can also add that line to your scripts for second state restoration, such as <A
HREF="#RESTORE.TESTER"
><TT
CLASS="FILENAME"
>restore.tester</TT
></A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="NTFS"
></A
>8.8. NTFS</H2
><P
>OK, NTFS isn't an application. It is a file system used by Microsoft operating system Windows NT and its descendents, including Windows 2000 and Windows XP. You can back it up and restore to it from Linux with <B
CLASS="COMMAND"
>ntfsclone</B
>, one of the NTFS utilities in the ntfsprogs suite, available from <A
HREF="http://linux-ntfs.sourceforge.net/downloads.html"
TARGET="_top"
>http://linux-ntfs.sourceforge.net/downloads.html</A
>.</P
><P
>These scripts will create NTFS partitions, but will not put a file system on them. It is not clear from the docs whether <B
CLASS="COMMAND"
>ntfsclone</B
> will lay down a file system on a virgin partition or not.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SOMEADVICEFORDISASTERRECOVERY"
></A
>9. Some Advice for Disaster Recovery</H1
><P
>You should take your ZIP disk for each computer and the printouts you made, and place them in a secure location in your shop. You should store copies of these in your off-site backup storage location. The major purpose of off-site backup storage is to enable disaster recovery, and restoring each host onto replacement hardware is a part of disaster recovery.</P
><P
>You should also have several restoration Linux floppies or CD-ROMS, and possibly some ZIP drives in your off-site storage as well. Also, have copies of the rescue linux distribution on several of your computers so that they back each other up.</P
><P
>You should probably have copies of this HOWTO, with your site-specific annotations on it, with your backups and in your off-site backup storage.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="WHATNOW"
></A
>10. What Now?</H1
><P
>This HOWTO results from experiments on one computer. No doubt you will find some directories or files you need to back up in your first stage backup. I have not dealt with saving and restoring X on the first stage, nor have I touched at all on processors other than Intel.</P
><P
>I would appreciate your feedback as you test and improve these scripts on your own computers. I also encourage vendors of backup software to document how to do a minimal backup of their products. I'd like to see the whole Linux community sleep just a little better at night.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="TODO"
></A
>10.1. To Do</H2
><P
>Volunteers are most welcome. Check with me before you start on one of these in case someone else is working on it already.</P
><P
></P
><UL
><LI
><P
>We have no way to determine the label of a swap partition. This means that there is no way to provide the swap partition's label when restoring. We could assume that a system with a single swap partition (as indicated by fdisk) has the label used in the swap partition line in <TT
CLASS="FILENAME"
>/etc/fstab</TT
>, but that only works on single hard drive systems, and could produce subtle errors in systems with multiple swap partitions.</P
><P
>The work-around is to add the label by hand by re-running <TT
CLASS="FILENAME"
>mkswap</TT
> with the -L option on it. Sigh.</P
></LI
><LI
><P
>A partition editor to adjust partition boundaries in the <TT
CLASS="FILENAME"
>dev.hdx</TT
> file. This will let users adjust partitions for a different hard drive, or the same one with different geometry, or to adjust partition sizes within the same hard drive. A GUI would probably be a good idea here. On the other tentacle, the FSF's <A
HREF="http://www.gnu.org/software/parted"
TARGET="_top"
><TT
CLASS="FILENAME"
>parted</TT
></A
> looks like it will fill part of the bill. It does re-size existing partitions, but with restrictions.</P
></LI
><LI
><P
><A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> currently only recognizes some FAT partitions, not all. Add code to <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> to recognize others and make appropriate instructions to rebuild them in the output files.</P
></LI
><LI
><P
>For FAT12 or FAT16 partitions we do not format, write zeros into the partition so that Mess-DOS 6.x does not get confused. See the notes on <B
CLASS="COMMAND"
>fdisk</B
> for an explanation of the problem.</P
></LI
><LI
><P
>Translations into other (human) languages.</P
></LI
><LI
><P
>I've referred to Red Hat Package Manager (rpm) from time to time. What are the equivalent deb commands?</P
></LI
><LI
><P
>Modify the first stage backup code to only save the current kernel.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="THESCRIPTS"
></A
>11. The Scripts</H1
><P
>See the notes in the beginning of each script for a summary of what it does.</P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="FIRSTSTAGE"
></A
>11.1. First Stage</H2
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="MAKE.FDISK"
></A
>11.1.1. <TT
CLASS="FILENAME"
>make.fdisk</TT
></H3
><P
>This script, run at backup time, creates scripts similar to <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
> and <A
HREF="#MOUNT.DEV.HDA"
><TT
CLASS="FILENAME"
>mount.dev.x</TT
></A
>, below, for you to run at restore time. It also produces data files similar to <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
>, below. The name of the script and data file produced depends on the device given this script as a a parameter. That script, run at restore time, builds the partitions on the hard drive. <TT
CLASS="FILENAME"
>make.fdisk</TT
> is called from <A
HREF="#SAVE.METADATA"
><TT
CLASS="FILENAME"
>save.metadata</TT
></A
>, below.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /usr/bin/perl

# A perl script to create a script and input file for fdisk to
# re-create the partitions on the hard disk, and format the Linux and
# Linux swap partitions. The first parameter is the fully qualified
# path of the device of the hard disk, e.g. /dev/hda. The two
# resulting files are the script make.dev.x and the data file dev.x
# (where x is the hard drive described, e.g. hda, sdc). make.dev.x is
# run at restore time to rebuild hard drive x, prior to running
# restore.metadata. dev.x is the input file for fdisk.

# Time-stamp: &#60;2006-04-08 15:23:55 ccurley make.fdisk&#62;

# Copyright 2001 through the last date of modification Charles Curley
# except for the subroutine cut2fmt.

# cut2fmt Copyright (c) 1998 Tom Christiansen, Nathan Torkington and
# O'Reilly &#38; Associates, Inc.  Permission is granted to use this code
# freely EXCEPT for book publication.  You may use this code for book
# publication only with the explicit permission of O'Reilly &#38;
# Associates, Inc.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# In addition, as a special exception, Tom Christiansen, Nathan
# Torkington and O'Reilly &#38; Associates, Inc.  give permission to use
# the code of this program with the subroutine cut2fmt (or with
# modified versions of the subroutine cut2fmt that use the same
# license as the subroutine cut2fmt), and distribute linked
# combinations including the two.  You must obey the GNU General
# Public License in all respects for all of the code used other than
# the subroutine cut2fmt.  If you modify this file, you may extend
# this exception to your version of the file, but you are not
# obligated to do so.  If you do not wish to do so, delete this
# exception statement and the subroutine cut2fmt from your version.

# You can also contact the Free Software Foundation at
# http://www.fsf.org/

# Changes:

# 2006-04-08: Primitive LVM support. It is kludgy in that it uses
# first stage restoration distribution (finnix) specific code to turn
# LVM on and off, but otherwise seems to work.

# 2006-03-28: We have a problem if swap partitions have
# labels. There's no way to retrieve the label from a swap
# partition. If we have one &#38; only one swap partition, then we can
# pull it out of /etc/fstab. Otherwise the user is on her own. We scan
# fstab for swap mount points that have labels for their devices. If
# there is one and only one, we assume that's it, otherwise pass.

# 2005-10-29: We now provide the geometry as an argument to fdisk
# (which does not work on tomsrtbt). We also save data for sfdisk, and
# write out make.dev.xxx so that it will use sfdisk if it finds it.

# 2005-08-14: Due to experience on Knoppix, we now add the code to
# change the partition types to the end of the fdisk input file
# instead of right after creating the partition.

# 2004 04 10: fdisk v &#62; 2.11 has wider columns. Added code to select
# the appropriate cut string based on fdisk's version.

# 2004 04 09: Added support for Mandrake's idea of devfs. On Mandrake,
# everything is mounted with devfs. So the mount devices are buried
# deep in places like /dev/ide/host0/bus0/target0/lun0/part1 instead
# of places like /dev/hda1, where $DEITY intended they should be. We
# have to reverse from the long devfs device to the shorter old style
# that tomsrtbt uses. The alternative is to keep track in an array of
# which devfs device belongs to which short device.

# 2003 12 29: Changed the regex for detecting whether a file system is
# read-write in the code that builds the mount file(s). The old test
# does not work if mount returns multiple parameters in the 5th field,
# e.g. (rw,errors=remount-ro) on some debian systems. This regex
# assumes that the rw parameter is always listed first, which may not
# always be the case. If it fails, take out the '\('. Thanks to Pasi
# Oja-Nisula &#60;pon at iki dot fi&#62; for pointing this out.

# 2003 01 09: Added support for FAT32. We now create two scripts for
# each hard drive, make.dev.[as]dx and mount.dev.[as]dx. These create
# and make file systems on each partition, and make mount points and
# mount them.

# 2002 12 25: added support to handle W95 extended (LBA) (f) and W95
# FAT 32 partitions. I have tested this for primary but not logical
# partitions.

# 2002 09 08: Added minimal support for ext3fs. We now detect mounted
# ext3fs partitions &#38; rebuild but with no options. The detection
# depends on the command line "dumpe2fs &#60;device&#62; 2&#62;/dev/null | grep -i
# journal" producing no output for an ext2fs, and output (we don't
# care what) for an ext3fs.

# This could stand extension to support non-default ext3 options such
# as the type of journaling. Volunteers?

# 2002 07 25: Bad block checking is now a command line option (-c) at
# the time the product script is run.

# 2002 07 03: Corrected the mechanism for specifying the default
# drive.

# 2001 11 25: Changed the way mke2fs gets its bad block
# list. badblocks does not guess at the block size, so you have to get
# it (from dumpe2fs) and feed it to badblocks. It is simpler to just
# have mke2fs call badblocks, but you do loose the ability to have a
# writing test easily. -- C^2

# 2001 11 25: Changed the regex that extracts partition labels from
# the mount command. This change does not affect the results at all,
# it just makes it possible to use Emacs' perl mode to indent
# correctly. I just escaped the left bracket in the regex. -- C^2

# Discussion:

# fdisk will spit out a file of the form below if you run it as "fdisk
# -l".

# root@tester ~/bin $ fdisk -l /dev/hda

# Disk /dev/hda: 64 heads, 63 sectors, 1023 cylinders
# Units = cylinders of 4032 * 512 bytes

#    Device Boot    Start       End    Blocks   Id  System
# /dev/hda1             1         9     18112+  83  Linux
# /dev/hda2            10      1023   2044224    5  Extended
# /dev/hda5            10       368    723712+  83  Linux
# /dev/hda6           369       727    723712+  83  Linux
# /dev/hda7           728       858    264064+  83  Linux
# /dev/hda8           859       989    264064+  83  Linux
# /dev/hda9           990      1022     66496+  82  Linux swap

# What fdisk does not do is provide output suitable for later
# importing into fdisk, a la sfdisk. This script parses the output
# from fdisk and creates an input file for fdisk. Use the input file
# like so:

# fdisk /dev/hdx &#60; dev.hdx

# For the bare metal restore package, this script also builds a script
# that will execute the above command so you can run it from your zip
# disk. Because the bare metal restore scripts all are in /root/bin,
# the data file and script created by this script are also placed
# there. The same script also creates appropriate Linux file systems,
# either ext2fs, or Linux swap. There is limited support for FAT12,
# FAT16 and FAT32. For anything else, you're on your own.

# Note for FAT32: According to the MS KB, there are more than one
# reserved sectors for FAT32, usually 32, but it can vary. Do a search
# in M$'s KB for "boot sector" or BPB for the gory details. For more
# info than you really need on how boot sectors are used, see
# http://support.microsoft.com/support/kb/articles/Q140/4/18.asp

# You can also edit dev.x to change the sizes of partitions. Don't
# forget, if you change the size of a FAT partition across the 32MB
# boundary, you need to change the type as well! Run "fdisk /dev/hda"
# or some such, then the l command to see the available partition
# types. Then go ahead and edit dev.x appropriately. Also, when moving
# partition boundarys with hand edits, make sure you move both logical
# and extended partition boundaries appropriately.

# Bad block checking right now is a quick read of the partition. A
# writing check is also possible but more difficult. You have to run
# badblocks as a separate command, and pass the bad block list to
# mke2fs in a file (in /tmp, which is a ram disk). You also have to
# know how large the blocks are, which you learn by running
# dumpe2fs. It gets messy and I haven't done it yet. You probably
# don't need it for a new hard drive, but if you have had a hard drive
# crash on you and you are reusing it (while you are waiting for its
# replacement to come in, I presume), then I highly recommend it. Let
# me know how you do it.

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# cut2fmt figures out the format string for the unpack function we use
# to slice and dice the output from fdisk. From Christiansen and
# Torkington, Perl Cookbook 5.

sub cut2fmt {
    my (@positions) = @_;
    my $template    = '';
    my $lastpos     = 1;

    foreach $place (@positions) {
        $template .= "A" . ($place - $lastpos) . " ";
        $lastpos = $place;
    }

    $template .= "A*";
    return $template;
}


# Sub gpl, a subroutine to ship the GPL and other header information
# to the current output file.

sub gpl {
    my $FILE = shift;
    my $year = shift;

    print $FILE &#60;&#60;FINIS;

# Copyright $year through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

FINIS

}

sub getBootSector {
    my $infile = $_[0];
    my $outfile = $_[1];

    $systemcmd = "dd if=$infile of=$outfile bs=512 count=1 &#38;&#62; /dev/null ";
    system ($systemcmd);
}


# If we have one &#38; only one swap partition, then this must be
# it. Otherwise the user is on her own. We scan fstab for swap mount
# points that have labels for their devices. If there is one and only
# one, we assume that's it, otherwise pass.

sub getswaplabel {
    my $dev = $_[0];

    $fstabpid = open (FSTAB, "&#60; /etc/fstab")
        or die "Couldn't fork: $!\n";
    while (defined (my $line = &#60;FSTAB&#62;)) {
        chop ($line);
        @fstabs = split (" ", $line);
        if (@fstabs[1] eq "swap") {
            $swaplabel = @fstabs[0];
            if ($swaplabel =~ /LABEL/) {
                $swaps++;
                $sl = substr ($swaplabel, 6);
            }
#           print ("\"@fstabs[0]\", \"@fstabs[1]\", \"$sl\", $swaps.\n");
            break;
        }
    }
    close (FSTAB);

#   print "label is $sl.\n";

    if ($swaps == 1) {
        $ret = "mkswap \$blockcheck -L $sl";
        $ret .= " $dev\n\n";
    } else {
        $ret = "mkswap \$blockcheck $dev\n\n";
    }

#   print ("Returning :$ret\n");

    return $ret;
}

# dolvm is a subroutine to handle LVM partitions. This is
# experimental....

$lvms = 0;			# true if we've been here before

sub dolvm {

    print ("In dolvm ()...\n");

    if ($lvms == 0) {
        $lvms = 1;

        # Scan /etc/fstab for the logical volumes and write a script to
        # make file systems on them and another to mount 'em later on.

        $mklvs = open (MKLVS, "&#62; make.lvs")
            or die "Couldn't fork: $!\n";

        print MKLVS &#60;&#60;FINIS;
#! /bin/sh

# A script to create file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.
FINIS

        &#38;gpl (*MKLVS, "2006");


        print MKLVS &#60;&#60;FINIS;

export blockcheck=\$1;

if [ "\$blockcheck" != "-c" ] &#38;&#38; [ -n "\$blockcheck" ]
then
    echo "\${0}: Build file systems on logical volumes."
    echo "\${0}: -c: block check during file system making."
    exit 1;
fi

export LVM_SYSTEM_DIR=\$(pwd)/lvm

FINIS

        $mtlvs = open (MTLVS, "&#62; mount.lvs")
            or die "Couldn't fork: $!\n";

        print MTLVS &#60;&#60;FINIS;
#! /bin/sh

# A script to mount file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.
FINIS

        &#38;gpl (*MTLVS, "2006");


        # Now cycle through all the known logical volumes &#38; set them
        # up. N.B.: This has been tested on a machine with only one
        # LV. But it *should* work.

        $pvdisp = open (PVDISP, "pvdisplay -c |")
            or die ("Can't open LVM display.\n");
        while (defined (my $pv = &#60;PVDISP&#62;)) {
            chop ($pv);
            print ("$pv\n");
            @pv = split (":", $pv);
            $uid = @pv[11];
            $pvname = @pv[1];
            $phv = @pv[0];
            print ("pv $pvname has uid $uid.\n");

            # back up the LVM's lvm details. Get the config files.
            system ("vgcfgbackup -f LVM.backs.$pvname $pvname");

            print (MKLVS "echo \"y\\n\" | pvcreate -ff --uuid \"$uid\"\\\n");
            print (MKLVS "    --restorefile lvm/archive/${pvname}_*.vg $phv\n");
            print (MKLVS "vgcfgrestore --file LVM.backs.$pvname $pvname\n\n");
        }

        print (MKLVS "# Hideously disty dependent!\nif [ -e /etc/init.d/lvm ] ; then\n");
        print (MKLVS "    /etc/init.d/lvm start\nfi\n\n");

        $fstabpid = open (FSTAB, "&#60; /etc/fstab")
            or die "Couldn't fork: $!\n";
        while (defined (my $line = &#60;FSTAB&#62;)) {
            chop ($line);
            @fstabs = split (" ", $line);
            if (@fstabs[0] =~ /VolGroup/ ) {
                #           print ("$line\n");
                if (@fstabs[2] eq "swap") {
                    print (MKLVS "echo\necho making LV @fstabs[0] a swap partition.\n");
                    print (MKLVS "mkswap \$blockcheck @fstabs[0]\n\n");
                } elsif (@fstabs[2] == "ext3") {
                    print (MKLVS "echo\necho making LV @fstabs[0], @fstabs[1],");
					print (MKLVS " an ext3 partition.\n");
                    print (MKLVS "mke2fs -j \$blockcheck @fstabs[0]\n\n");

                    print (MTLVS "mkdir -p /target$fstabs[1]\n");
                    print (MTLVS "mount @fstabs[0] /target$fstabs[1]\n\n");
                } elsif (@fstabs[2] == "ext2") {
                    print (MKLVS "echo\necho making LV @fstabs[0], @fstabs[1],");
					print (MKLVS " an ext2 partition.\n");
                    print (MKLVS "mke2fs \$blockcheck @fstabs[0]\n\n");

                    print (MTLVS "mkdir -p /target$fstabs[1]\n");
                    print (MTLVS "mount @fstabs[0] /target$fstabs[1]\n\n");
                } else {
                    print ("Opps, unknown type of logical volume, @fstabs[0]\n");
                }
            }
        }
        print (MTLVS "mount | grep -i \"/target\"\n");

        close (FSTAB);
        close (MKLVS);
        close (MTLVS);

        chmod 0700, "${outputfilepath}make.lvs";
        chmod 0700, "${outputfilepath}mount.lvs";

        # Copy the LVM configuration to where we can get at it...

        system ("cp -rp /etc/lvm .");

    }

    print ("Leaving dolvm ()...\n");

    return ($ret);
}


# Begin main line code.

# Provide a default device.

# print "\$ARGV[0] is $ARGV[0].\n";

$device = defined ($ARGV[0]) ? $ARGV[0] : "/dev/hda";

# Need to check to see if $device is a sym link. If it is, the mount
# point is the target of the link. (Mandrake) Otherwise we search for
# mount points on $device. Fedora, Red Hat.

if ( -l $device) {

    # It is a sym link. Get the target of the link, then make it into
    # an absolute path, preserving the numbering.

    $mountdev = '/dev/' . readlink ($device);
    $mountdev =~ s|ide/host(\d+)/bus(\d+)/target(\d+)/lun(\d+)/disc
        |ide/host\1/bus\2/target\3/lun\4|x;
} else {
    # not a sym link; just assign it.
    $mountdev = $device;
}

# print "Device is $device; mount device is $mountdev.\n";

# Prepare format string. Here are two format strings I have found
# useful. Here, column numbers are 1 based, i.e. the leftmost column
# is column 1, not column 0 as in Emacs.

# We select a format string according to fdisk's version.

$fdpid = open (FDVER, "fdisk -v |") or die "Couldn't fork: $!\n";
while (&#60;FDVER&#62;) {
    @_ = unpack ("A7 A*", $_);
    $fdver=$_[1];
    $fdver =~ s/[^\d.]//g; # strip non-numbers, non-periods, as in "2.12pre".
}

# print "fdisk version is $fdver\n";

if ($fdver &#60; 2.12) {
# fdisk to 2.11?? Red Hat, Fedora Core 1
    $fmt = cut2fmt (11, 19, 24, 34, 45, 49);
} else {
# fdisk 2.12 &#38; up?? Mandrake 10.0, Fedora Core 2
    $fmt = cut2fmt (12, 14, 26, 38, 50, 55);
}
# print "Format string is $fmt.\n";

# define fields in the array @_.
$dev = 0;
$bootable = 1;
$firstcyl = 2;
$lastcyl = 3;
$parttype = 5;
$partstring = 6;

$target = "\/target";

$outputfilename = $device;
$outputfilename =~ s/\//./g;
$outputfilename = substr ($outputfilename, 1, 100);

$outputfilepath = "/root/bin/";


# Make a hash of the labels.
$mpid = open (MOUNT, "mount -l |") or die "Couldn't fork: $!\n";
while (&#60;MOUNT&#62;) {
    if ($_ =~ /^$mountdev/i) { # is this a line with a partition in it?
#       print $_;               # print it just for grins
        split;
        if ($_[6] ne "") {      # only process if there actually is a label
            $_[6] =~ s/[\[\]]//g; # strike [ and ].
            $labels{$_[0]} = $_[6];
#           print "The label of file device $_[0] is $labels{$_[0]}.\n";
        }


        # We only mount if it's ext2fs or ext3fs and read and write.

        if ($_[4] =~ /ext[23]/ and $_[5] =~ /\(rw/ ) {
            if ($_[0] =~ /ide/i) {

                # We have a devfs system, e.g. Mandrake. This code
                # converts back from the devfs designation to the old
                # /dev/hd* designation for tomsrtb. I have NOT checked
                # this out for drives other than /dev/hda. Also, this
                # code does not handle SCSI drives.

                if ( $_[0] =~ /target0/ &#38;&#38; $_[0] =~ /bus0/ ) {
                    $letter = 'a';
                } elsif ( $_[0] =~ /target1/ &#38;&#38; $_[0] =~ /bus0/) {
                    $letter = 'b';
                } elsif ( $_[0] =~ /target0/ &#38;&#38; $_[0] =~ /bus1/) {
                    $letter = 'c';
                } else {
                    $letter = 'd';
                }
                $_[0] =~ s|/ide/host\d+/bus\d+/target\d+/lun\d+/part|/hd|g;
                $_[0] =~ s/hd/hd$letter/;
            }
            $mountpoints{$_[2]} = $_[0];
#             print "$_[2] is the mountpoint for tomsrtbt";
#             print " device $mountpoints{$_[2]}.\n";
        }
    }
}
close (MOUNT);

# Get sfdisk output. If we have sfdisk at restore time (e.g. Knoppix),
# we'll use it.

system "sfdisk -d $device &#62; $outputfilepath${outputfilename}.sfd";

# Otherwise we'll use the output from fdisk, which may or may not be
# any more accurate.

$fpid = open (FDISK, "fdisk -l $device |") or die "Couldn't fork: $!\n";

open (OUTPUT, "&#62; $outputfilepath${outputfilename}")
    or die "Couldn't open output file $outputfilepath${outputfilename}.\n";

while (&#60;FDISK&#62;) {
    if ($_ =~ /^$device/i) {    # is this a line with a partition in it?
#       print $_;               # print it just for grins
        chop;                   # kill trailing \r
        @_ = unpack ($fmt, $_);

        # Now strip white spaces from cylinder numbers, white space &#38;
        # leading plus signs from partition type.
        @_[$firstcyl] =~ s/[ \t]+//;
        @_[$lastcyl] =~ s/[ \t]+//;
        @_[$parttype] =~ s/[+ \t]+//;

        $partnumber = substr(@_[$dev], 8, 10); # get partition number for this line
        # just for grins
#         print "  $partnumber, @_[$firstcyl], @_[$lastcyl],";
#         print " @_[$parttype], @_[$partstring]\n";

        # Here we start creating the input to recreate the partition
        # this line represents.

        print OUTPUT "n\n";
        if ($partnumber &#60; 5) {
            # primary Linux partition
            if (@_[$parttype] == 83) {
                print OUTPUT "p\n$partnumber\n@_[$firstcyl]\n";
                # in case it's all on one cylinder
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                # Now detect if this is an ext3 (journaling)
                # partition. We do this using dumpe2fs to dump the
                # partition and grepping on "journal". If the
                # partition is ext2, there will be no output. If it is
                # ext3, there will be output, and we use that fact to
                # set a command line switch. The command line switch
                # goes into an associative array (hash) so we don't
                # have to remember to reset it to the null string when
                # we're done.

                $dpid = open (DUMPE2FS,
                              "dumpe2fs @_[$dev] 2&#62;/dev/null | grep -i journal |")
                    or die "Couldn't fork: $!\n";
                while (&#60;DUMPE2FS&#62;) {
#                   print "Dumpe2fs: $_";
                    $ext3{$_[$dev]} = "-j ";
                    last;
                }
                close (DUMPE2FS);

                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{$_[$dev]}\$blockcheck";
                    $format .= " -L $labels{@_[$dev]} @_[$dev]\n\n";
                } else {
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{$_[$dev]}\$blockcheck @_[$dev]\n\n";
                }

                # extended partition
            } elsif (@_[$parttype] == 5) {
                # print ("Creating Extended Partition.\n");
                print OUTPUT "e\n$partnumber\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                # extended partition, Win95 Ext'd (LBA)
            } elsif (@_[$parttype] eq "f") {
                # print ("Creating Extended LBA Partition.\n");
                print OUTPUT "e\n$partnumber\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\nf\n";

                # primary Linux swap partition
            } elsif (@_[$parttype] == 82) {
                print OUTPUT "p\n$partnumber\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n82\n";
                $format .= "echo\necho Making @_[$dev] a swap partition.\n";
                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "mkswap \$blockcheck -L $labels{@_[$dev]}";
                    $format .= " @_[$dev]\n\n";
                } else {
                    $format .= getswaplabel (@_[$dev]);
                }

                # Primary mess-dos partition. We don't handle hidden
                # partitions.

            } elsif ( @_[$parttype] == 1 || @_[$parttype] == 4 || @_[$parttype] == 6
                      || @_[$parttype] eq "b" || @_[$parttype] eq "c"
                      || @_[$parttype] eq "e" ) {
                # print ("Making DOS primary partition.\n");

                getBootSector (@_[$dev], "$outputfilepath$outputfilename$partnumber");

                print OUTPUT "p\n$partnumber\n@_[$firstcyl]\n";
                # in case it's all on one cylinder
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
                $format .= "echo\necho formatting $checking@_[$dev]\n";
                $format .= "mkdosfs \$blockcheck";
                if ( @_[$parttype] == b || @_[$parttype] == c) {
                    # We have a W9x FAT32 partition. Add a command line switch.
                    $format .= " -F 32";
                }
                $format .= " @_[$dev]\n";
                $format .= "# restore FAT boot sector.\n";
                $format .= "dd if=$outputfilename$partnumber";
                $format .= " of=@_[$dev] bs=512 count=1\n\n";

            } elsif ( @_[$parttype] == "8e") {
                $format .= dolvm ();
            } else {
                # anything else partition
                print OUTPUT "p\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
            }

        } else {
            # logical Linux partition
            if (@_[$parttype] == 83) {
                print OUTPUT "l\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }

                # Now detect if this is an ext3 (journaling)
                # partition. We do this using dumpe2fs to dump the
                # partition and grepping on "journal". If the
                # partition is ext2, there will be no output. If it is
                # ext3, there will be output, and we use that fact to
                # set a command line switch. The command line switch
                # goes into an associative array (hash) so we don't
                # have to remember to reset it to the null string when
                # we're done.

                $dpid = open (DUMPE2FS,
                              "dumpe2fs @_[$dev] 2&#62;/dev/null | grep -i journal |")
                    or die "Couldn't fork: $!\n";
                while (&#60;DUMPE2FS&#62;) {
#                   print "Dumpe2fs: $_";
                    $ext3{$_[$dev]} = "-j ";
                    last;
                }
                close (DUMPE2FS);

                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{@_[$dev]}\$blockcheck";
                    $format .= " -L $labels{@_[$dev]} @_[$dev]\n\n";
                } else {
                    $format .= "echo\necho formatting $checking@_[$dev]\n";
                    $format .= "mke2fs $ext3{@_[$dev]}\$blockcheck @_[$dev]\n\n";
                }

                # logical Linux swap partition
            } elsif (@_[$parttype] == 82 ) {
                print OUTPUT "l\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n82\n";
                $format .= "echo\necho Making @_[$dev] a swap partition.\n";
                if ($labels{@_[$dev]}) { # do we have a label?
                    $format .= "mkswap \$blockcheck -L $labels{@_[$dev]}";
                    $format .= " @_[$dev]\n\n";
                } else {
                    $format .= getswaplabel (@_[$dev]);
                }

                # Logical mess-dos partition. We don't handle hidden
                # partitions.

            } elsif ( @_[$parttype] == 1 || @_[$parttype] == 4 || @_[$parttype] == 6
                      || @_[$parttype] eq "b" || @_[$parttype] eq "c"
                      || @_[$parttype] eq "e" ) {
#               print ("Making DOS logical partition.\n");

                getBootSector (@_[$dev], "$outputfilepath$outputfilename$partnumber");

                print OUTPUT "l\n$partnumber\n@_[$firstcyl]\n";
                # in case it's all on one cylinder
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
                $format .= "echo\necho formatting $checking@_[$dev]\n";
                $format .= "mkdosfs \$blockcheck";
                if ( @_[$parttype] == b || @_[$parttype] == c) {
                    # We have a W9x FAT32 partition. Add a command line switch.
                    $format .= " -F 32";
                }
                $format .= " @_[$dev]\n";
                $format .= "# restore FAT boot sector.\n";
                $format .= "dd if=$outputfilename$partnumber";
                $format .= " of=@_[$dev] bs=512 count=1\n\n";

            } elsif ( @_[$parttype] == "8e") {
                $format .= dolvm ();
            } else {
                # anything else partition
                print OUTPUT "l\n@_[$firstcyl]\n";
                if (@_[$firstcyl] ne @_[$lastcyl]) {
                    print OUTPUT "@_[$lastcyl]\n";
                }
                $typechanges .= "t\n$partnumber\n@_[$parttype]\n";
            }
        }

        # handle bootable partitions
        if (@_[$bootable] =~ /\*/) {
            print OUTPUT "a\n$partnumber\n";
        }
    } else {
        # If we got here, the current line does not have a partition in it.

        # Get the geometry for fdisk. Force fdisk to use the current
        # geometry at restoration time. Comment this out for
        # tomstrbt's fdisk; it doesn't like it.

        if ($_ =~ /heads.*sectors.*cylinders/i) {
#           print $_;               # again, for grins.
            chop;
            @geometry = split (/ /, $_);
            $geometry = "-H $geometry[0] -S $geometry[2] -C $geometry[4]";
#           print $geometry;
        }
    }
}

# Append all the partition type changes, validate, and print out the
# results.

print OUTPUT "${typechanges}v\nw\n";

close (OUTPUT);
close (FDISK);


open (OUTPUT, "&#62; ${outputfilepath}make.$outputfilename")
    or die "Couldn't open output file ${outputfilepath}make.$outputfilename.\n";

print OUTPUT &#60;&#60;FINIS;
#! /bin/sh

# A script to restore the partition data of a hard drive and format
# the partitions. Created at bare metal backup time by the Perl script
# make.fdisk.
FINIS

&#38;gpl (*OUTPUT, "2001");

print OUTPUT &#60;&#60;FINIS;

swapoff -a
# Hideously disty dependent!
if [ -e /etc/init.d/lvm ] ; then
    /etc/init.d/lvm stop
fi

export blockcheck=\$1;

if [ "\$blockcheck" != "-c" ] &#38;&#38; [ -n "\$blockcheck" ]
then
    echo "\${0}: automated restore with no human interaction."
    echo "\${0}: -c: block check during file system making."
    exit 1;
fi

FINIS

# Clean the old partition table out. Turn off swap in case we're using
# it.

print OUTPUT "dd if=/dev/zero of=$device bs=512 count=2\n\nsync\n\n";


# command for fdisk

$fdiskcmd .= "# see if we have sfdisk &#38; if so use it.\n";
$fdiskcmd .= "if which sfdisk ; then\n";
$fdiskcmd .= "  echo \"Using sfdisk.\"\n";
$fdiskcmd .= "  sfdisk --force $geometry $device &#60; ${outputfilename}.sfd\n";
$fdiskcmd .= "else\n";
$fdiskcmd .= "  echo \"using fdisk.\"\n";
$fdiskcmd .= "  fdisk $geometry $device \&#60; $outputfilename\n";
$fdiskcmd .= "fi\n\nsync\n\n";


print OUTPUT $fdiskcmd;
print OUTPUT $format;

print OUTPUT "fdisk -l \"$device\"\n";

close (OUTPUT);

# Now build the script that will build the mount points on the root
# and other partitions.

open (OUTPUT, "&#62; ${outputfilepath}mount.$outputfilename")
    or die "Couldn't open output file ${outputfilepath}make.$outputfilename.\n";

print OUTPUT &#60;&#60;FINIS;
#! /bin/sh

# A script to create a minimal directory tree on the target hard drive
# and mount the partitions on it. Created at bare metal backup time by
# the Perl script make.fdisk.
FINIS

&#38;gpl (*OUTPUT, "2001");

print OUTPUT &#60;&#60;FINIS;

# WARNING: If your Linux system mount partitions across hard drive
# boundaries, you will have multiple "mount.dev.* scripts. You must
# ensure that they run in the proper order. The root partition should
# be mounted first, then the rest in the order they cascade. If they
# cross mount, you'll have to handle that manually.

FINIS


# We have a hash of mount points and devices in %mountpoints. However,
# we have to process them such that directories are built on the
# appropriate target partition. E.g. where /usr/local is on its own
# partition, we have to mount /usr before we build /usr/local. We can
# ensure this by sorting them. Shorter mount point paths will be built
# first. We can't sort a hash directly, so we use an array.

# We build commands to create the appropriate mount points and then
# mount the partitions to the mount points. This is in preparation for
# untarring the contents of the ZIP disk, done in restore.metadata.

foreach $point ( sort keys %mountpoints) {
    print OUTPUT "\n# $point is the mountpoint for";
    print OUTPUT " tomsrtbt device $mountpoints{$point}.\n";
    print OUTPUT "mkdir -p $target$point\n";
    print OUTPUT "mount $mountpoints{$point} $target$point\n";
}

print OUTPUT "\nmount | grep -i \"/target\"\n";

close (OUTPUT);

# These scripts are dangerous &#38; should only be visible to root.

chmod 0700, "${outputfilepath}make.$outputfilename";
chmod 0700, "${outputfilepath}mount.$outputfilename";
chmod 0600, "${outputfilepath}${outputfilename}*";</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="MAKE.DEV.HDA"
></A
>11.1.2. <TT
CLASS="FILENAME"
>make.dev.hda</TT
></H3
><P
>This script is a sample of the sort produced by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, above. It uses data files like <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
>, below. It builds partitions and puts file systems on some of them. This is the first script run at restore time.</P
><P
>If you are brave enough to edit <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
> (q.v.), say, to add a new partition, you may need to edit this script as well.</P
><P
>If you want make.dev.hda to check for bad blocks when it puts a file system on the partitions, use a "-c" command line option.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore the partition data of a hard drive and format
# the partitions. Created at bare metal backup time by the Perl script
# make.fdisk.

# Copyright 2001 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.


export blockcheck=$1;

if [ "$blockcheck" != "-c" ] &#38;&#38; [ -n "$blockcheck" ]
then
    echo "${0}: automated restore with no human interaction."
    echo "${0}: -c: block check during file system making."
    exit 1;
fi

dd if=/dev/zero of=/dev/hda bs=512 count=2

swapoff -a
sync

# see if we have sfdisk &#38; if so use it.
if which sfdisk ; then
  echo "Using sfdisk."
  sfdisk  -H 128 -S 63 -C 523 /dev/hda &#60; dev.hda.sfd
else
  echo "using fdisk."
  fdisk  -H 128 -S 63 -C 523 /dev/hda &#60; dev.hda
fi

sync

echo
echo formatting /dev/hda1
mkdosfs $blockcheck /dev/hda1
# restore FAT boot sector.
dd if=dev.hda1 of=/dev/hda1 bs=512 count=1

echo
echo formatting /dev/hda2
mke2fs -j $blockcheck -L /boot /dev/hda2

echo
echo formatting /dev/hda3
mke2fs -j $blockcheck -L / /dev/hda3

echo Making /dev/hda5 a swap partition.
mkswap $blockcheck /dev/hda5

fdisk -l "/dev/hda"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="MAKE.LVS"
></A
>11.1.3. <TT
CLASS="FILENAME"
>make.lvs</TT
></H3
><P
><TT
CLASS="FILENAME"
>make.lvs</TT
> is generated by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, but only if logical volumes are present. As the name suggests, it builds the logical volumes and makes file systems on them.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to create file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.

# Copyright 2006 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.


export blockcheck=$1;

if [ "$blockcheck" != "-c" ] &#38;&#38; [ -n "$blockcheck" ]
then
    echo "${0}: Build file systems on logical volumes."
    echo "${0}: -c: block check during file system making."
    exit 1;
fi

export LVM_SYSTEM_DIR=$(pwd)/lvm.cfg

echo "y\n" | pvcreate -ff --uuid "CCmw0N-0We2-HzRS-jRZa-FkC7-NxTc-oAfvpX"\
     --restorefile lvm.cfg/archive/VolGroup00_*.vg   /dev/hda3
vgcfgrestore --file LVM.backs VolGroup00

# Hideously disty dependent!
if [ -e /etc/init.d/lvm ] ; then
     /etc/init.d/lvm start
fi

echo
echo making LV /dev/VolGroup00/LogVol00 an ext3 partition.
mke2fs -j $blockcheck /dev/VolGroup00/LogVol00

echo
echo making LV /dev/VolGroup00/LogVol02 an ext3 partition.
mke2fs -j $blockcheck /dev/VolGroup00/LogVol02

echo
echo making LV /dev/VolGroup00/LogVol01 a swap partition.
mkswap $blockcheck /dev/VolGroup00/LogVol01&#13;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="MOUNT.DEV.HDA"
></A
>11.1.4. <TT
CLASS="FILENAME"
>mount.dev.hda</TT
></H3
><P
>This script is a sample of the sort produced by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, above. It builds mount points and mounts partitions on them, making the target file system ready for restoring files. This is the second script run at restore time.</P
><P
>If you are brave enough to edit <A
HREF="#DEV.HDA"
><TT
CLASS="FILENAME"
>dev.hda</TT
></A
> (q.v.), say, to add a new partition, you may need to edit this script as well.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to create a minimal directory tree on the target hard drive
# and mount the partitions on it. Created at bare metal backup time by
# the Perl script make.fdisk.

# Copyright 2001 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.


# WARNING: If your Linux system mount partitions across hard drive
# boundaries, you will have multiple "mount.dev.* scripts. You must
# ensure that they run in the proper order. The root partition should
# be mounted first, then the rest in the order they cascade. If they
# cross mount, you'll have to handle that manually.


# / is the mountpoint for tomsrtbt device /dev/hda3.
mkdir /target/
mount /dev/hda3 /target/

# /boot is the mountpoint for tomsrtbt device /dev/hda2.
mkdir /target/boot
mount /dev/hda2 /target/boot

mount | grep -i "/dev/hda"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="MOUNT.LVS"
></A
>11.1.5. <TT
CLASS="FILENAME"
>mount.lvs</TT
></H3
><P
><TT
CLASS="FILENAME"
>mount.lvs</TT
> is generated by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, but only if logical volumes are present. As the name suggests, it mounts the logical volumes ready for restoration.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to mount file systems on logical volumes. Created at bare
# metal backup time by the Perl script make.fdisk.

# Copyright 2006 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

mkdir -p /target/
mount /dev/VolGroup00/LogVol00 /target/

mkdir -p /target/home
mount /dev/VolGroup00/LogVol02 /target/home

mount | grep -i "/target"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="DEV.HDA"
></A
>11.1.6. <TT
CLASS="FILENAME"
>dev.hda</TT
></H3
><P
>This data file is used at restore time. It is fed to <B
CLASS="COMMAND"
>fdisk</B
> by the script <A
HREF="#MAKE.DEV.HDA"
><TT
CLASS="FILENAME"
>make.dev.hda</TT
></A
>. It is produced at backup time by <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>. Those familiar with <B
CLASS="COMMAND"
>fdisk</B
> will recognize that each line is an <B
CLASS="COMMAND"
>fdisk</B
> command or value, such as a cylinder number. Thus, it is possible to change the partition sizes and add new partitions by editing this file. That's why the penultimate command is <B
CLASS="COMMAND"
>v</B
>, to verify the partition table before it is written.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>n
p
1
1
29
a
1
n
p
2
30
44
n
e
3
45
1023
n
l
45
944
n
l
945
1023
t
1
6
t
6
82
v
w</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="SAVE.METADATA"
></A
>11.1.7. <TT
CLASS="FILENAME"
>save.metadata</TT
></H3
><P
>This is the first script to run as part of the backup process. It calls <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
>, above. If you have a SCSI hard drive or multiple hard drives to back up, edit the call to <A
HREF="#MAKE.FDISK"
><TT
CLASS="FILENAME"
>make.fdisk</TT
></A
> appropriately.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to save certain meta-data off to the boot partition. Useful for
# restoration.

# Time-stamp: &#60;2006-04-05 20:37:09 ccurley save.metadata&#62;

# Copyright 2000 through the last date of modification, Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at
# http://www.fsf.org/

# 2006-03-26: had a deprecated option in the sort options; fixed that.

# 2005-09-09: Added a line to create a boot disk ISO in the ZIP drive.

# 2005-08-30: Modernized sub-shell calls, a few other tweaks.

# 2005-07-29: Fedora Core 4 mods. Name of the directory to be saved
# has to be last. Also, we now specify --numeric-owner so as to avoid
# UID problems when using some live CD systems. And we now save to
# /var instead of a mounted ZIP disk.

# 2005-02-19: Fedora Core 3 mods.

# 2003 01 08: We now age the output from rpm -VA to make back
# comparisons easier.

# The loop that creates directories now has the -p option for mkdir,
# which means you can create parents on the fly if they don't already
# exist.

# initrd is now in the list of directories to create automatically.

# We now exclude more stuff when building the tarballs.

# 2002 07 01: Went to bzip2 to compress the archives, for smaller
# results. This is important in a 100MB ZIP disk. Also some general
# code cleanup.

# 2002 07 01: The function crunch will tar and BZIP2 the
# archives. This is cleaner than the old code, and has better safety
# checking.


# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.


# Crunch: A function to compress the contents of a directory and put
# the archive onto the ZIP disk.

# The first parameter is the name of the archive file to be
# created. The backup location, $zip, will be prepended and the
# extension, "tar.bz2" will be appended.

# All following parameters will be taken as additional directories or
# files to be put into the archive.

function crunch {

if [ -z "$1" ] || [ -z "$2" ]	# Checks if parameter #1 or #2 is zero length.
then
   echo "-Parameter #1 or #2 is missing.-"  # Also if no parameter is passed.
   return 1
else
   local file=$1		# The archive file to create
   shift			# Discard the file name
   local dirs=$@		# The director[y|ies] to archive
   local tarcmd="tar --numeric-owner -cjf"	# The tar command.

   local tarit="$tarcmd  $zip/$file.tar.bz2 $dirs"
   echo $tarit
   $tarit			# do it!!

   error=$?			# Preserve the exit code

   if [ $error != 0 ]		# Did we fail?
   then				# Yes
      echo "Tar failed with error $error"
      echo $tarcmd $zip/$file.tar.bz2 $dirs
      exit $error		# return tar's exit code as ours
   fi

   return 0			# For error testing if needed.
fi
}

# Begin the main line code
export zip="/var/bare.metal";	# Where we will put archives. Not the ZIP drive here.
#  export save="/mnt/save";

RPMVABACKS=/etc			# where we keep our backups
RPMVAROOT=rpmVa			# The root name of the pg backups
ANC=${RPMVABACKS}/${RPMVAROOT}.anc	# name for the oldest (ancient) backup
OLD=${RPMVABACKS}/${RPMVAROOT}.old	# name for the middling oldest backup
NEW=${RPMVABACKS}/${RPMVAROOT}.txt	# name for the newest backup

if [ -f ${ANC} ]; then
echo "Deleting ${ANC}"
rm ${ANC}
fi

if [ -f ${OLD} ]; then
echo "Aging ${OLD}"
mv ${OLD} ${ANC}
fi

if [ -f ${NEW} ]; then
echo "Aging ${NEW}"
mv ${NEW} ${OLD}
fi


# Now we save hard drive information. Run make.fdisk on each hard
# drive in the order in which it mounted from the root partition. That
# is, run it first on the hard drive with your root partition, then
# any hard drives that mount to the first hard drive, then any hard
# drives that mount to those. For example, if your root partition is
# on /dev/sdc, run "make.fdisk /dev/sdc" first.

# The reason for this is that make.fdisk produces a script to make
# mount points and then mount the appropriate partition to them during
# first stage restore. Mount points must be created on the partition
# where they will reside. The partitions must be mounted in this
# order. For example, if your /var and /var/ftp are both separate
# partitions, then you must mount /, create /var, then mount /var,
# then create /var/ftp. The order in which the script "first.stage"
# runs the mounting scripts is based on their time of creation.

# If necessary, put a line, "sleep 1" between calls to make.fdisk.

echo "Saving hard drive info"
make.fdisk /dev/hda

# back up RPM metadata

echo "Verifying RPMs."

rpm -Va | sort -t ' ' -k 3 | uniq &#62; ${NEW}

echo "Finished verifying RPMs; now mounting the ZIP drive."

# Make sure we have the ZIP drive mounted.
# umount $zip
# modprobe ppa			# Driver for 100MB parallel port ZIP disk
# mount $zip			# It should have ext2fs on partition 1.

# clean it all out
# rm -r $zip/*
# mkdir -p $zip/lost+found

# Since we aren't saving to ZIP disk, we age the local copy.
rm -r $zip.old
mv $zip $zip.old
mkdir $zip

echo -e "$(hostname) bare metal ZIP disk, created $(date)" &#62; $zip/README.txt
uname -a &#62;&#62; $zip/README.txt

# Preserve the release information. Tested with Red Hat/Fedora, should
# work with SuSE, Mandrake and other RPM based systems. Debian
# equivalent, anyone?

for releasefile in $(ls /etc/*release*) ; do
  # echo $releasefile
  if [ -e $releasefile ] &#38;&#38; [ ! -L $releasefile ] ; then
    cat $releasefile &#62;&#62; $zip/README.txt
  fi
done

echo "Building the ZIP drive backups."

# These are in case we need to refer to them while rebuilding. The
# rebuilding process should be mostly automated, but you never
# know....

fdisk -l /dev/hda &#62; $zip/fdisk.hda

ls -al /mnt &#62; $zip/ls.mnt.txt
ls -al / &#62; $zip/ls.root.txt

cd /

# Build our minimal archives on the ZIP disk. These appear to be
# required so we can restore later on.

crunch root --exclude root/.cpan --exclude root/.mozilla --exclude root/down root
crunch boot boot
crunch etc --exclude etc/samba --exclude etc/X11 --exclude etc/gconf etc
crunch lib lib

crunch usr.sbin usr/sbin
crunch usr.bin --exclude usr/bin/emacs-x --exclude usr/bin/emacs-21.4-x\
 --exclude usr/bin/emacsclient --exclude usr/bin/emacs-nox --exclude\
  usr/bin/gs --exclude usr/bin/pine --exclude usr/bin/gimp-1.2\
   --exclude usr/bin/doxygen --exclude usr/bin/postgres --exclude\
    usr/bin/gdb --exclude usr/bin/kmail --exclude usr/bin/splint\
	 --exclude usr/bin/odbctest --exclude usr/bin/php --exclude \
	 usr/bin/xchat --exclude usr/bin/gnucash --exclude usr/bin/pdfetex\
	  --exclude usr/bin/pdftex --exclude usr/bin/smbcacls\
	   --exclude usr/bin/evolution-calendar --exclude usr/bin/xpdf\
	    --exclude usr/bin/xmms usr/bin
crunch sbin sbin
crunch bin bin
crunch dev dev

# RH8. Fedora 1 puts them in /lib
# crunch kerberos usr/kerberos/lib/

# Now optional saves.

# arkeia specific:
# crunch arkeia usr/knox

# save these so we can use ssh for restore. *crack* for RH 7.0 login
# authentication.
# RH 8.0
# crunch usr.lib usr/lib/*crack* usr/lib/libz* usr/lib/libssl* usr/lib/libcrypto*
# Fedora 1
# crunch usr.lib usr/lib/*crack* usr/lib/libz* usr/lib/libwrap*\
#  usr/lib/libk* usr/lib/*krb5* /usr/lib/libgss*
# Fedora 3
crunch usr.lib usr/lib/*crack* usr/lib/libz* usr/lib/libwrap*\
 usr/lib/libk* usr/lib/*krb5* usr/lib/libgss*

# Grub requires these at installation time.
crunch usr.share.grub usr/share/grub

# save the scripts we used to create the ZIP disk and the ones we will
# use to restore it.
mkdir $zip/root.bin
cp -p /root/bin/* $zip/root.bin
rm $zip/root.bin/*~ $zip/root.bin/#*#

echo "Testing our results."
find $zip -iname "*.bz2" | xargs bunzip2 -t

# Not a normal part of the process: we duplicate the ZIP disk onto an
# NFS mount elsewhere.

#  echo "Backing the ZIP drive to the NFS mount."

#  umount $save
#  mount $save

#  rm -r $save/zip
#  mkdir -p $save/zip
#  cp -pr $zip $save

# Since we're doing system stuff anyway, make a boot disk ISO image
# suitable for burning. It uses the current kernel.

mkbootdisk --iso --device $zip/bootdisk.$(uname -r).iso $(uname -r)

du -hs ${zip}*
df -m</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="RESTORE.METADATA"
></A
>11.1.8. <TT
CLASS="FILENAME"
>restore.metadata</TT
></H3
><P
>This script restores metadata from the ZIP disk as a first stage restore.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore the meta-data from the ZIP disk. This runs under
# tomsrtbt only after partitions have been rebuilt, file systems made,
# and mounted. It also assumes the ZIP disk has already been
# mounted. Mounting the ZIP disk read only is probably a good idea.

# Time-stamp: &#60;2006-04-05 20:36:49 ccurley restore.metadata&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# 2005-08-03: We now use a relative path, so you can load from
# different places depending on the first stage system you are
# using. Also added some FC4 tricks, and some changes to better
# reproduce the permissions and ownerships.

# 2003 08 23: Oops: tar on tomsrtbt does not respect -p. Try setting
# umask to 0000 instead.

# 2003 02 13: Tar was not preserving permissions on restore. Fixed
# that.

# 2002 07 01: Went to bzip2 to compress the archives, for smaller
# results. This is important in a 100MB ZIP disk. Also some general
# code cleanup.

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

umask 0000

cd ..               # Assume we are in root.bin
zip=$(pwd);         # Where we mount the zip drive.
target="/target";       # Where the hard drive to restore is mounted.

ls -lt $zip/*.bz2       # Warm fuzzies for the user.

cd $target

# Restore the archived metadata files.
for archive in $( ls $zip/*.bz2 ); do
  echo $archive
  ls -al $archive
  bzip2 -dc $archive | tar -xf -
done

# Build the mount points for our second stage restoration and other
# things.

# If you boot via an initrd, make sure you build a directory here so
# the kernel can mount the initrd at boot. tmp/.font-unix is for the
# xfs font server.

for dir in mnt/dosc mnt/zip mnt/imports mnt/nfs proc initrd tmp/.font-unix\
 var/empty/sshd var/log back selinux sys /var/cache/yum /var/lock; do
  mkdir -p $target/$dir
done

for dir in mnt usr usr/share $(ls -d var/*) selinux usr/lib var var/cache/yum; do
  chmod go-w $target/$dir
done

chown root:lock /var/lock
chmod 775 /var/lock

# [root@jhereg /]# ll -d mnt usr usr/share  $(ls -d var/*) selinux usr/lib var var/cache/yum
# drwxr-xr-x   4 root    root     4096 Oct 10 08:55 mnt
# drwxr-xr-x   2 root    root     4096 Oct 10 08:41 selinux
# drwxr-xr-x  14 root    root     4096 Oct 10 08:46 usr
# drwxr-xr-x  40 root    root    12288 Oct 10 10:40 usr/lib
# drwxr-xr-x  63 root    root     4096 Oct 10 11:11 usr/share
# drwxr-xr-x  20 root    root     4096 Oct 10 08:52 var
# drwxr-xr-x   2 root    root     4096 Oct 10 08:51 var/account
# drwxr-xr-x   4 root    root     4096 Oct 10 08:53 var/cache
# drwxr-xr-x   4 root    root     4096 Oct 10 10:44 var/cache/yum
# drwxr-xr-x   3 netdump netdump  4096 Aug 22 13:13 var/crash
# drwxr-xr-x   3 root    root     4096 Oct 10 08:51 var/db
# drwxr-xr-x   3 root    root     4096 Oct 10 08:52 var/empty
# drwxr-xr-x  13 root    root     4096 Oct 10 11:11 var/lib
# drwxr-xr-x   2 root    root     4096 May 22 22:28 var/local
# drwxrwxr-x   4 root    lock     4096 Sep  1 08:37 var/lock
# drwxr-xr-x   7 root    root     4096 Oct 10 11:14 var/log
# lrwxrwxrwx   1 root    root       10 Oct 10 08:42 var/mail -&#62; spool/mail
# drwxr-x---   4 root    named    4096 Aug 22 14:33 var/named
# drwxr-xr-x   2 root    root     4096 May 22 22:28 var/nis
# drwxr-xr-x   2 root    root     4096 May 22 22:28 var/opt
# drwxr-xr-x   2 root    root     4096 May 22 22:28 var/preserve
# drwxr-xr-x   2 root    root     4096 Mar 28  2005 var/racoon
# drwxr-xr-x  13 root    root     4096 Oct 10 11:14 var/run
# drwxr-xr-x  13 root    root     4096 Oct 10 08:53 var/spool
# drwxrwxrwt   2 root    root     4096 Oct 10 11:14 var/tmp
# drwxr-xr-x   3 root    root     4096 Oct 10 08:53 var/yp

# chmod a-w $target/proc        # Restore /proc's read-only permissions

# Set modes
chmod 0111 $target/var/empty/sshd

# For Fedora. First two for xfs.
# chroot $target chown xfs:xfs /tmp/.font-unix
# chmod 1777 $target/tmp/.font-unix # set the sticky bit.
chmod 1777 $target/tmp

# Restore the scripts we used to create the ZIP disk and the ones we will
# use to restore it. These should be the latest &#38; greatest in case we had
# to do any editing during 1st stage restore.
cp -p $zip/root.bin/* $target/root/bin

# Now install the boot sector.
# chroot $target /sbin/lilo -C /etc/lilo.conf
chroot $target /sbin/grub-install /dev/hda

df -m</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="FIRST.STAGE"
></A
>11.1.9. <TT
CLASS="FILENAME"
>first.stage</TT
></H3
><P
>This script runs the entire first stage restore with no operator intervention.</P
><P
>If you want to check for bad blocks when it puts a file system on the partitions, use a "-c" command line option.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A master script to run the other, detailed scripts. Use this script
# only if you want no human intervention in the restore process. The
# only option is -c, which forces bad block checking during formatting
# of the partitions.

# Time-stamp: &#60;2006-04-05 20:35:39 ccurley first.stage&#62;

# Copyright 2002 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# 2005-08-07 We no longer assume the working directory. This is
# because the working directory will vary greatly according to which
# Linux disty you use and how you are doing your restoration.

export blockcheck=$1;

if [ "$blockcheck" != "-c" ] &#38;&#38; [ -n "$blockcheck" ]
then
    echo "${0}: automated restore with no human interaction."
    echo "${0}: -c: block check during file system making."
    exit 1;
fi

for drive in $( ls make.dev.* ); do
    echo $drive$'\a'
    sleep 2
    ./$drive $blockcheck;
done

# If there are any LVM volumes, now is the time to restore them.

if [ -e LVM.backs ] &#38;&#38; [ -e make.lvs ] &#38;&#38; [ -e mount.lvs ]
then
    echo make.lvs$'\a'
    sleep 2
    ./make.lvs

    echo mount.lvs$'\a'
    ./mount.lvs
fi


# WARNING: If your Linux system mount partitions across hard drive
# boundaries, you will have multiple "mount.dev.* scripts. You must
# ensure that they run in the proper order, which the loop below may
# not do. The root partition should be mounted first, then the rest in
# the order they cascade. If they cross mount, you'll have to handle
# that manually. If you have LVMs to deal with, that's a whole 'nother
# kettle of fish.

# The "ls -tr" will list the scripts in the order they are created, so
# it might be a good idea to create them (in the script save.metadata)
# in the order in which you should run them.

for drive in $( ls -tr mount.dev.* ); do
    echo $drive$'\a'
    sleep 2
    ./$drive;
done

./restore.metadata

# People who are really confident may comment this line in.
# reboot</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="SECONDSTAGE"
></A
>11.2. Second Stage</H2
><P
>These scripts run on the computer being backed up or restored.</P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="BACK.UP.ALL"
></A
>11.2.1. <TT
CLASS="FILENAME"
>back.up.all</TT
></H3
><P
>This script saves to another computer via an NFS mount. You can adapt it to save to tape drives or other media.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# Back up the entire system to another computer's drive. To make this
# work, we need a convenient chunk of disk space on the remote computer we
# can nfs mount as /mnt/save.

# Time-stamp: &#60;2003-04-24 09:56:05 ccurley back.up.all&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

save="/mnt/save"

# Make sure it's there
umount $save
mount $save

cd /

rm $save/tester.tar.old.gz
mv $save/tester.tar.gz $save/tester.tar.old.gz

# save everything except /mnt, /proc, and nfs mounted directories.

time tar cf - / --exclude /mnt --exclude /proc --exclude $save\
    | gzip -c &#62; $save/tester.tar.gz&#13;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="BACK.UP.ALL.SSH"
></A
>11.2.2. <TT
CLASS="FILENAME"
>back.up.all.ssh</TT
></H3
><P
>This script does exactly what <A
HREF="#BACK.UP.ALL"
><TT
CLASS="FILENAME"
>back.up.all</TT
></A
> does, but it uses ssh instead of nfs.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# Back up the entire system to another computer's drive. To make this
# work, we need a convenient chunk of disk space on the remote
# computer. This version uses ssh to do its transfer, and compresses
# using bz2. This means this script has to know more about the other
# computer, which does not make for good modularization.

# Time-stamp: &#60;2003-04-24 09:56:52 ccurley back.up.all.ssh&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

save="/backs/tester"
backup_server="charlesc"

# rotate the old backups. Do it all in one line to minimze authentication overhead.
ssh $backup_server "rm $save/tester.tar.old.bz2; mv $save/tester.tar.bz2 \
    $save/tester.tar.old.bz2"

# save everything except /mnt, /proc, and squid directories.

time tar cf - / --exclude /mnt --exclude /proc --exclude /var/spool/squid\
    | ssh $backup_server "bzip2 -9 &#62; $save/tester.tar.bz2"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="RESTORE.ALL"
></A
>11.2.3. <TT
CLASS="FILENAME"
>restore.all</TT
></H3
><P
>This is the restore script to use if you backed up using <A
HREF="#BACK.UP.ALL"
><TT
CLASS="FILENAME"
>back.up.all</TT
></A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore all of the data from an nfs mount. This is our final
# stage restore.

# Time-stamp: &#60;2003-04-24 09:58:51 ccurley restore.all&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

export save="/mnt/save"

mount $save

cd /
gunzip -dc $save/tester.tar.gz | tar -xpkf -

rm /var/run/*.pid

lilo</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="RESTORE.ALL.SSH"
></A
>11.2.4. <TT
CLASS="FILENAME"
>restore.all.ssh</TT
></H3
><P
>This is the restoration script to use if you used <A
HREF="#BACK.UP.ALL.SSH"
><TT
CLASS="FILENAME"
>back.up.all.ssh</TT
></A
> to back up.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore all of the data using ssh and bunzip2. This is
# our final stage restore.

# Copyright 2000 through the last date of modification Charles Curley.

# Time-stamp: &#60;2003-04-24 09:59:10 ccurley restore.all.ssh&#62;

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

save="/backs/tester/"
backup_server="charlesc"

cd /

ssh $backup_server "cat $save/tester.tar.bz2" | bunzip2 | tar -xpkf -

rm /var/run/*.pid

lilo</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BACKUPSERVERSCRIPTS"
></A
>11.3. Backup Server Scripts</H2
><P
>The ssh scripts above have a possible security problem. If you run them on a firewall, the firewall has to have access via ssh to the backup server. In that case, a clever cracker might also be able to crack the backup server. It would be more secure to run backup and restore scripts on the backup server, and let the backup server have access to the firewall. That is what these scripts are for. Rename them to <TT
CLASS="FILENAME"
>get.x</TT
> and <TT
CLASS="FILENAME"
>restore.x</TT
> where <TT
CLASS="FILENAME"
>x</TT
> is the name of the target computer. Edit them (the variable $target's initialization) to use the target computer's host name, or rewrite them to use a command line argument.</P
><P
>These scripts backup and restore the target completely, not just the stage one backup and restore. Also, note that <TT
CLASS="FILENAME"
>get.tester</TT
> backs up the ZIP disk as well, in case you need to replace a faulty ZIP disk.</P
><P
>I use these scripts routinely.</P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="GET.TESTER"
></A
>11.3.1. <TT
CLASS="FILENAME"
>get.tester</TT
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# Back up another computer's drive to this system. To make this work,
# we need a convenient chunk of disk space on this computer. This
# version uses ssh to do its transfer, and compresses using bz2. This
# version was developed so that the system to be backed up won't be
# authenticated to log onto the backup computer. This script is
# intended to be used on a firewall. You don't want the firewall to be
# authenticated to the backup system in case the firewall is cracked.

# Time-stamp: &#60;2006-04-05 20:36:00 ccurley get.tester&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# 2004 04 03: added /sys to the list of excludes. It is a read-only
# pseudo-file system like /proc.

# 2002 07 01: We now set the path on the target to the zip drive with
# a variable. This fixes a bug in the command to eject the zip disk.

# 2002 07 01: The zip disk archives are now in bzip2 format, so this
# script has been changed to reflect that.


# The host name of the computer to be backed up.
target=tester
#zip=/mnt/zip
export zip="/var/bare.metal";	# Where we will put archives. Not the ZIP drive here.

echo Backing up $target

echo Aging the ZIP disk backups.

rm -r $target.old.zip

mv $target.zip $target.old.zip

# ssh $target "modprobe ppa ; mount -r $zip"

echo Copying the ZIP disk.

# -r for recursive copy, -p to preserve times and permissions, -q for
# quiet: no progress meter.

scp -qpr $target:$zip $target.zip

du -hs $target.*zip


echo Aging the archives

rm $target.tar.old.bz2

mv $target.tar.bz2 $target.tar.old.bz2

echo Cleaning out old yum packages
ssh $target "yum clean packages"

echo Backing up $target to the backup server.

# The "--anchored" option is there to prevent --exclude from excluding
# all files with that name. E.g. we only want to exclude /sys, not
# some other sys elsewhere in the file system.

ssh $target "cd / ; tar -cf - --anchored --exclude sys --exclude $zip\
 --exclude $zip.old --exclude mnt --exclude proc --exclude var/spool/squid\
 *" | bzip2 -9 | cat &#62; $target.tar.bz2

# ssh $target "eject $zip"

echo Testing the results.
find . -iname "*.bz2" | xargs bunzip2 -t</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="RESTORE.TESTER"
></A
>11.3.2. <TT
CLASS="FILENAME"
>restore.tester</TT
></H3
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#! /bin/sh

# A script to restore all of the data to tester via ssh. This is our final
# stage restore.

# Time-stamp: &#60;2003-04-24 09:59:45 ccurley restore.tester&#62;

# Copyright 2000 through the last date of modification Charles Curley.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

# You can also contact the Free Software Foundation at http://www.fsf.org/

# For more information contact the author, Charles Curley, at
# http://www.charlescurley.com/.

# The host name of the computer to be restored.

target=tester

bunzip2 -dc $target.tar.bz2 | ssh $target "cd / ; tar -xpkf - "

ssh $target lilo</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="RESOURCES"
></A
>12. Resources</H1
><P
>In no particular order. These are things you might want to investigate for yourself. A listing here should not be taken as an endorsement. In fact, in many case I have not used the product and cannot comment on it.</P
><P
></P
><UL
><LI
><P
><A
HREF="http://osdev.berlios.de/netboot.html"
TARGET="_top"
>Network-booting Your Operating System</A
> describes several techniques for booting across a network, using <A
HREF="http://www.gnu.org/software/grub/"
TARGET="_top"
>grub</A
> and some other tricks. I haven't tried it, but I have a sneaky suspicion that with an especially trained floppy diskette, you could get your entire first stage image onto the computer to be restored.</P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"<A
HREF="http://btmgr.webframe.org/"
TARGET="_top"
>Smart Boot Manager (SBM)</A
> is an OS independent and full-featured boot manager with an easy-to-use user interface. There are some screen shots available."</SPAN
> It is essential if your BIOS will not allow you to boot to CD-ROM and you want to use a CD-ROM based Linux for Stage 1 recovery.</P
></LI
><LI
><P
><A
HREF="http://www.oreilly.com/catalog/unixbr/author.html"
TARGET="_top"
>W. Curtis Preston</A
>'s excellent <A
HREF="http://www.oreilly.com/catalog/unixbr/"
TARGET="_top"
><I
CLASS="CITETITLE"
>Unix Backup &#38; Recovery</I
></A
>. This is the book that got me started on this bare metal recovery stuff. I highly recommend it; <A
HREF="http://www2.linuxjournal.com/lj-issues/issue78/3839.html"
TARGET="_top"
>read my review</A
>.</P
></LI
><LI
><P
>An old (2000) list of <A
HREF="http://www.fokus.gmd.de/linux/linux-distrib-small.html"
TARGET="_top"
>small Linux disties.</A
></P
></LI
><LI
><P
><A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, <SPAN
CLASS="QUOTE"
>"The most Linux on 1 floppy disk."</SPAN
> Tom also has links to other small disties.</P
></LI
><LI
><P
>The <A
HREF="http://www.tldp.org/"
TARGET="_top"
>Linux Documentation Project</A
>. See particularly the <SPAN
CLASS="QUOTE"
>"<I
CLASS="CITETITLE"
>LILO, Linux Crash Rescue HOW-TO</I
>."</SPAN
></P
></LI
><LI
><P
>The Free Software Foundation's <A
HREF="http://www.gnu.org/software/parted"
TARGET="_top"
><TT
CLASS="FILENAME"
>parted</TT
></A
> for editing (enlarging, shrinking, moving) partitions.</P
></LI
><LI
><P
><A
HREF="http://qtparted.sourceforge.net/"
TARGET="_top"
>QtParted</A
> looks to do the same thing with a GUI front end.</P
></LI
><LI
><P
><A
HREF="http://www.partimage.org/"
TARGET="_top"
>Partition Image</A
> for backing up partitions.</P
><P
>From the web page: <SPAN
CLASS="QUOTE"
>"Partition Image is a Linux/UNIX utility which saves partitions in many formats (see below) to an image file. The image file can be compressed in the GZIP/BZIP2 formats to save disk space, and split into multiple files to be copied on removable floppies (ZIP for example), .... The partition can be saved across the network since version 0.6.0."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://sourceforge.net/projects/bacula"
TARGET="_top"
>Bacula</A
> is a GLPled backup product which has bare metal recovery code inspired in part by this HOWTO.</P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"<A
HREF="http://www.feyrer.de/g4u/"
TARGET="_top"
>g4u ('ghost for unix')</A
> is a NetBSD-based bootfloppy/CD-ROM that allows easy cloning of PC harddisks to deploy a common setup on a number of PCs using FTP. The floppy/CD offers two functions. First is to upload the compressed image of a local harddisk to a FTP server. Other is to restore that image via FTP, uncompress it and write it back to disk; network configuration is fetched via DHCP. As the harddisk is processed as a image, any filesystem and operating system can be deployed using g4u."</SPAN
></P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"We present <A
HREF="http://www.cs.utah.edu/flux/papers/frisbee-usenix03-base.html"
TARGET="_top"
>Frisbee</A
>, a system for saving, transferring, and installing entire disk images, whose goals are speed and scalability in a LAN environment. Among the techniques Frisbee uses are an appropriately-adapted method of filesystem-aware compression, a custom application-level reliable multicast protocol, and flexible application-level framing. This design results in a system which can rapidly and reliably distribute a disk image to many clients simultaneously. For example, Frisbee can write a total of 50 gigabytes of data to 80 disks in 34 seconds on commodity PC hardware. We describe Frisbee's design and implementation, review important design decisions, and evaluate its performance."</SPAN
></P
></LI
><LI
><P
>There are a number of USB key disties available. Check <A
HREF="http://www.distrowatch.com/"
TARGET="_top"
>DistroWatch</A
> for details.</P
></LI
><LI
><P
>CD-ROM based rescue kits. This is not intended to be an exhaustive list. If you know of one (or even something that pretends to be one), please <A
HREF="charlescurley at charlescurley dot com"
TARGET="_top"
>let me know</A
>. You may find more recent information at <A
HREF="http://www.distrowatch.com/"
TARGET="_top"
>DistroWatch</A
>.</P
><P
></P
><UL
><LI
><P
>Hugo Rabson's <A
HREF="http://www.microwerks.net/~hugo/"
TARGET="_top"
>Mondo</A
> <SPAN
CLASS="QUOTE"
>"... creates one or more bootable Rescue CD's (or tape+floppies) containing some or all of your filesystem. In the event of catastrophic data loss, you will be able to restore from bare metal."</SPAN
></P
></LI
><LI
><P
>The <A
HREF="http://crashrecovery.org/"
TARGET="_top"
>Crash Recovery Kit for Linux</A
></P
></LI
><LI
><P
><A
HREF="http://www-106.ibm.com/developerworks/linux/library/l-knopx.html?ca=dgr-lnxw04Knoppix"
TARGET="_top"
><SPAN
CLASS="QUOTE"
>"System recovery with Knoppix"</SPAN
></A
> is a good introduction to system recovery in general, and has some useful <A
HREF="http://www.knoppix.org/"
TARGET="_top"
>Knoppix</A
> links.</P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"<A
HREF="http://emergencycd2.sourceforge.net/"
TARGET="_top"
>Cool Linux CD</A
> is live CD with Linux system. This used 2.4 kernel and some free and demo soft."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://www.sysresccd.org/index.en.php"
TARGET="_top"
>SystemRescueCd</A
><SPAN
CLASS="QUOTE"
>" is a linux system on a bootable cdrom for repairing your system and your data after a crash. It also aims to provide an easy way to carry out admin tasks on your computer, such as creating and editing the partitions of the hard disk. It contains a lot of system utilities (parted, partimage, fstools, ...) and basic ones (editors, midnight commander, network tools). It aims to be very easy to use: just boot from the cdrom, and you can do everything. The kernel of the system supports most important file systems (ext2/ext3, reiserfs, xfs, jfs, vfat, ntfs, iso9660), and network ones (samba and nfs)."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://syslinux.zytor.com/"
TARGET="_top"
>Syslinux</A
> builds boot code for floppy diskettes, CD-ROMs and Intel PXE (Pre-Execution Environment) images. It is not dependent on a floppy diskette image. You can build your own CDs with a number of tools, such as <A
HREF="http://www.toms.net/rb"
TARGET="_top"
>tomsrtbt</A
>, on it.</P
></LI
><LI
><P
>In case you'd like to roll your own: <SPAN
CLASS="QUOTE"
>"<A
HREF="http://www.linux-live.org/"
TARGET="_top"
>Linux Live</A
> is a set of bash scripts which allows you to create [your] own LiveCD from every Linux distribution. Just install your favourite distro, remove all unnecessary files (for example man pages and all other files which are not important for you) and then download and run these scripts."</SPAN
></P
></LI
><LI
><P
><SPAN
CLASS="QUOTE"
>"The <A
HREF="http://www.linbox.com/en/ppart.html"
TARGET="_top"
>PPART CD</A
> allows you to generate system recovery bootable CD of previously saved hard disks."</SPAN
></P
></LI
><LI
><P
><A
HREF="http://rescuecd.sourceforge.net/"
TARGET="_top"
> Timo's Rescue CD Set</A
>: <SPAN
CLASS="QUOTE"
>" This set is my approach for an easy way to generate a rescue system on a bootable cd, which can easily be adapted to the own needs. The project evolves more and more into a 'debian on cd' project, so it's not only possible to use the system as a rescuecd, it is also possible to install a whole debian system on cd."</SPAN
></P
></LI
><LI
><P
>The <A
HREF="http://www.frozentech.com/content/livecd.php"
TARGET="_top"
>List of Live CDs</A
> has more CD based disties.</P
></LI
></UL
></LI
></UL
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="APPENDIX1GFDL"
></A
>A. GNU Free Documentation License</H1
><P
>Version 1.1, March 2000</P
><A
NAME="AEN964"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Copyright (C) 2000  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.</P
></BLOCKQUOTE
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL02"
></A
>0. PREAMBLE</H1
><P
>The purpose of this License is to make a manual, textbook,
    or other written document "free" in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it,
    with or without modifying it, either commercially or
    noncommercially.  Secondarily, this License preserves for the
    author and publisher a way to get credit for their work, while not
    being considered responsible for modifications made by
    others.</P
><P
>This License is a kind of "copyleft", which means that
    derivative works of the document must themselves be free in the
    same sense.  It complements the GNU General Public License, which
    is a copyleft license designed for free software.</P
><P
>We have designed this License in order to use it for manuals
    for free software, because free software needs free documentation:
    a free program should come with manuals providing the same
    freedoms that the software does.  But this License is not limited
    to software manuals; it can be used for any textual work,
    regardless of subject matter or whether it is published as a
    printed book.  We recommend this License principally for works
    whose purpose is instruction or reference.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL03"
></A
>1. APPLICABILITY AND DEFINITIONS</H1
><P
>This License applies to any manual or other work that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  The "Document",
    below, refers to any such manual or work.  Any member of the
    public is a licensee, and is addressed as "you".</P
><P
>A "Modified Version" of the Document means any work
    containing the Document or a portion of it, either copied
    verbatim, or with modifications and/or translated into another
    language.</P
><P
>A "Secondary Section" is a named appendix or a front-matter
    section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document's overall subject (or to related matters) and contains
    nothing that could fall directly within that overall subject.
    (For example, if the Document is in part a textbook of
    mathematics, a Secondary Section may not explain any mathematics.)
    The relationship could be a matter of historical connection with
    the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding
    them.</P
><P
>The "Invariant Sections" are certain Secondary Sections
    whose titles are designated, as being those of Invariant Sections,
    in the notice that says that the Document is released under this
    License.</P
><P
>The "Cover Texts" are certain short passages of text that
    are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this
    License.</P
><P
>A "Transparent" copy of the Document means a
    machine-readable copy, represented in a format whose specification
    is available to the general public, whose contents can be viewed
    and edited directly and straightforwardly with generic text
    editors or (for images composed of pixels) generic paint programs
    or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic
    translation to a variety of formats suitable for input to text
    formatters.  A copy made in an otherwise Transparent file format
    whose markup has been designed to thwart or discourage subsequent
    modification by readers is not Transparent.  A copy that is not
    "Transparent" is called "Opaque".</P
><P
>Examples of suitable formats for Transparent copies include
    plain ASCII without markup, Texinfo input format, LaTeX input
    format, SGML or XML using a publicly available DTD, and
    standard-conforming simple HTML designed for human modification.
    Opaque formats include PostScript, PDF, proprietary formats that
    can be read and edited only by proprietary word processors, SGML
    or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML produced by some word
    processors for output purposes only.</P
><P
>The "Title Page" means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly,
    the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such,
    "Title Page" means the text near the most prominent appearance of
    the work's title, preceding the beginning of the body of the
    text.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL04"
></A
>2. VERBATIM COPYING</H1
><P
>You may copy and distribute the Document in any medium,
    either commercially or noncommercially, provided that this
    License, the copyright notices, and the license notice saying this
    License applies to the Document are reproduced in all copies, and
    that you add no other conditions whatsoever to those of this
    License.  You may not use technical measures to obstruct or
    control the reading or further copying of the copies you make or
    distribute.  However, you may accept compensation in exchange for
    copies.  If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</P
><P
>You may also lend copies, under the same conditions stated
    above, and you may publicly display copies.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL05"
></A
>3. COPYING IN QUANTITY</H1
><P
>If you publish printed copies of the Document numbering more
    than 100, and the Document's license notice requires Cover Texts,
    you must enclose the copies in covers that carry, clearly and
    legibly, all these Cover Texts: Front-Cover Texts on the front
    cover, and Back-Cover Texts on the back cover.  Both covers must
    also clearly and legibly identify you as the publisher of these
    copies.  The front cover must present the full title with all
    words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes
    limited to the covers, as long as they preserve the title of the
    Document and satisfy these conditions, can be treated as verbatim
    copying in other respects.</P
><P
>If the required texts for either cover are too voluminous to
    fit legibly, you should put the first ones listed (as many as fit
    reasonably) on the actual cover, and continue the rest onto
    adjacent pages.</P
><P
>If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a
    machine-readable Transparent copy along with each Opaque copy, or
    state in or with each Opaque copy a publicly-accessible
    computer-network location containing a complete Transparent copy
    of the Document, free of added material, which the general
    network-using public has access to download anonymously at no
    charge using public-standard network protocols.  If you use the
    latter option, you must take reasonably prudent steps, when you
    begin distribution of Opaque copies in quantity, to ensure that
    this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you
    distribute an Opaque copy (directly or through your agents or
    retailers) of that edition to the public.</P
><P
>It is requested, but not required, that you contact the
    authors of the Document well before redistributing any large
    number of copies, to give them a chance to provide you with an
    updated version of the Document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL06"
></A
>4. MODIFICATIONS</H1
><P
>You may copy and distribute a Modified Version of the
    Document under the conditions of sections 2 and 3 above, provided
    that you release the Modified Version under precisely this
    License, with the Modified Version filling the role of the
    Document, thus licensing distribution and modification of the
    Modified Version to whoever possesses a copy of it.  In addition,
    you must do these things in the Modified Version:</P
><P
></P
><OL
TYPE="A"
><LI
><P
>Use in the Title Page
      (and on the covers, if any) a title distinct from that of the
      Document, and from those of previous versions (which should, if
      there were any, be listed in the History section of the
      Document).  You may use the same title as a previous version if
      the original publisher of that version gives permission.</P
></LI
><LI
><P
>List on the Title Page,
      as authors, one or more persons or entities responsible for
      authorship of the modifications in the Modified Version,
      together with at least five of the principal authors of the
      Document (all of its principal authors, if it has less than
      five).</P
></LI
><LI
><P
>State on the Title page
      the name of the publisher of the Modified Version, as the
      publisher.</P
></LI
><LI
><P
>Preserve all the
      copyright notices of the Document.</P
></LI
><LI
><P
>Add an appropriate
      copyright notice for your modifications adjacent to the other
      copyright notices.</P
></LI
><LI
><P
>Include, immediately
      after the copyright notices, a license notice giving the public
      permission to use the Modified Version under the terms of this
      License, in the form shown in the Addendum below.</P
></LI
><LI
><P
>Preserve in that license
      notice the full lists of Invariant Sections and required Cover
      Texts given in the Document's license notice.</P
></LI
><LI
><P
>Include an unaltered
      copy of this License.</P
></LI
><LI
><P
>Preserve the section
      entitled "History", and its title, and add to it an item stating
      at least the title, year, new authors, and publisher of the
      Modified Version as given on the Title Page.  If there is no
      section entitled "History" in the Document, create one stating
      the title, year, authors, and publisher of the Document as given
      on its Title Page, then add an item describing the Modified
      Version as stated in the previous sentence.</P
></LI
><LI
><P
>Preserve the network
      location, if any, given in the Document for public access to a
      Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was
      based on.  These may be placed in the "History" section.  You
      may omit a network location for a work that was published at
      least four years before the Document itself, or if the original
      publisher of the version it refers to gives permission.</P
></LI
><LI
><P
>In any section entitled
      "Acknowledgements" or "Dedications", preserve the section's
      title, and preserve in the section all the substance and tone of
      each of the contributor acknowledgements and/or dedications
      given therein.</P
></LI
><LI
><P
>Preserve all the
      Invariant Sections of the Document, unaltered in their text and
      in their titles.  Section numbers or the equivalent are not
      considered part of the section titles.</P
></LI
><LI
><P
>Delete any section
      entitled "Endorsements".  Such a section may not be included in
      the Modified Version.</P
></LI
><LI
><P
>Do not retitle any
      existing section as "Endorsements" or to conflict in title with
      any Invariant Section.</P
></LI
></OL
><P
>If the Modified Version includes new front-matter sections
    or appendices that qualify as Secondary Sections and contain no
    material copied from the Document, you may at your option
    designate some or all of these sections as invariant.  To do this,
    add their titles to the list of Invariant Sections in the Modified
    Version's license notice.  These titles must be distinct from any
    other section titles.</P
><P
>You may add a section entitled "Endorsements", provided it
    contains nothing but endorsements of your Modified Version by
    various parties--for example, statements of peer review or that
    the text has been approved by an organization as the authoritative
    definition of a standard.</P
><P
>You may add a passage of up to five words as a Front-Cover
    Text, and a passage of up to 25 words as a Back-Cover Text, to the
    end of the list of Cover Texts in the Modified Version.  Only one
    passage of Front-Cover Text and one of Back-Cover Text may be
    added by (or through arrangements made by) any one entity.  If the
    Document already includes a cover text for the same cover,
    previously added by you or by arrangement made by the same entity
    you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous
    publisher that added the old one.</P
><P
>The author(s) and publisher(s) of the Document do not by
    this License give permission to use their names for publicity for
    or to assert or imply endorsement of any Modified Version.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL07"
></A
>5. COMBINING DOCUMENTS</H1
><P
>You may combine the Document with other documents released
    under this License, under the terms defined in section 4 above for
    modified versions, provided that you include in the combination
    all of the Invariant Sections of all of the original documents,
    unmodified, and list them all as Invariant Sections of your
    combined work in its license notice.</P
><P
>The combined work need only contain one copy of this
    License, and multiple identical Invariant Sections may be replaced
    with a single copy.  If there are multiple Invariant Sections with
    the same name but different contents, make the title of each such
    section unique by adding at the end of it, in parentheses, the
    name of the original author or publisher of that section if known,
    or else a unique number.  Make the same adjustment to the section
    titles in the list of Invariant Sections in the license notice of
    the combined work.</P
><P
>In the combination, you must combine any sections entitled
    "History" in the various original documents, forming one section
    entitled "History"; likewise combine any sections entitled
    "Acknowledgements", and any sections entitled "Dedications".  You
    must delete all sections entitled "Endorsements."</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL08"
></A
>6. COLLECTIONS OF DOCUMENTS</H1
><P
>You may make a collection consisting of the Document and
    other documents released under this License, and replace the
    individual copies of this License in the various documents with a
    single copy that is included in the collection, provided that you
    follow the rules of this License for verbatim copying of each of
    the documents in all other respects.</P
><P
>You may extract a single document from such a collection,
    and distribute it individually under this License, provided you
    insert a copy of this License into the extracted document, and
    follow this License in all other respects regarding verbatim
    copying of that document.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL09"
></A
>7. AGGREGATION WITH INDEPENDENT WORKS</H1
><P
>A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of
    a storage or distribution medium, does not as a whole count as a
    Modified Version of the Document, provided no compilation
    copyright is claimed for the compilation.  Such a compilation is
    called an "aggregate", and this License does not apply to the
    other self-contained works thus compiled with the Document, on
    account of their being thus compiled, if they are not themselves
    derivative works of the Document.</P
><P
>If the Cover Text requirement of section 3 is applicable to
    these copies of the Document, then if the Document is less than
    one quarter of the entire aggregate, the Document's Cover Texts
    may be placed on covers that surround only the Document within the
    aggregate.  Otherwise they must appear on covers around the whole
    aggregate.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL10"
></A
>8. TRANSLATION</H1
><P
>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section
    4.  Replacing Invariant Sections with translations requires
    special permission from their copyright holders, but you may
    include translations of some or all Invariant Sections in addition
    to the original versions of these Invariant Sections.  You may
    include a translation of this License provided that you also
    include the original English version of this License.  In case of
    a disagreement between the translation and the original English
    version of this License, the original English version will
    prevail.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL11"
></A
>9. TERMINATION</H1
><P
>You may not copy, modify, sublicense, or distribute the
    Document except as expressly provided for under this License.  Any
    other attempt to copy, modify, sublicense or distribute the
    Document is void, and will automatically terminate your rights
    under this License.  However, parties who have received copies, or
    rights, from you under this License will not have their licenses
    terminated so long as such parties remain in full
    compliance.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL12"
></A
>10. FUTURE REVISIONS OF THIS LICENSE</H1
><P
>The Free Software Foundation may publish new, revised
    versions of the GNU Free Documentation License from time to time.
    Such new versions will be similar in spirit to the present
    version, but may differ in detail to address new problems or
    concerns.  See <A
HREF="http://www.gnu.org/copyleft/"
TARGET="_top"
>http://www.gnu.org/copyleft/</A
>.</P
><P
>Each version of the License is given a distinguishing
    version number.  If the Document specifies that a particular
    numbered version of this License "or any later version" applies to
    it, you have the option of following the terms and conditions
    either of that specified version or of any later version that has
    been published (not as a draft) by the Free Software Foundation.
    If the Document does not specify a version number of this License,
    you may choose any version ever published (not as a draft) by the
    Free Software Foundation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GFDL13"
></A
>11. How to use this License for your documents</H1
><P
>To use this License in a document you have written, include
    a copy of the License in the document and put the following
    copyright and license notices just after the title page:</P
><A
NAME="AEN1054"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>      Copyright (c)  YEAR  YOUR NAME.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".</P
></BLOCKQUOTE
><P
>If you have no Invariant Sections, write "with no Invariant
    Sections" instead of saying which ones are invariant.  If you have
    no Front-Cover Texts, write "no Front-Cover Texts" instead of
    "Front-Cover Texts being LIST"; likewise for Back-Cover
    Texts.</P
><P
>If your document contains nontrivial examples of program
    code, we recommend releasing these examples in parallel under your
    choice of free software license, such as the GNU General Public
    License, to permit their use in free software.</P
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN345"
HREF="#AEN345"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>I emphasize copy because <B
CLASS="COMMAND"
>mkisofs</B
> will mung the file in the directory from which it makes the ISO image.</P
></TD
></TR
></TABLE
></BODY
></HTML
>